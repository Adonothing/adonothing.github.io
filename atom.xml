<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Adunas🍀の异世界</title>
  
  
  <link href="https://www.adunas.top/atom.xml" rel="self"/>
  
  <link href="https://www.adunas.top/"/>
  <updated>2024-03-15T16:22:29.000Z</updated>
  <id>https://www.adunas.top/</id>
  
  <author>
    <name>阿杜那斯🍀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>力扣 C++ 算法训练</title>
    <link href="https://www.adunas.top/posts/20240316c.html"/>
    <id>https://www.adunas.top/posts/20240316c.html</id>
    <published>2024-03-15T16:22:29.000Z</published>
    <updated>2024-03-15T16:22:29.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol type="1"><li>链接：<a href="https://leetcode.cn/problems/two-sum/description/">1.两数之和</a>。</li></ol></div><div class="note info flat"><p>我对算法的学习要求和思路为： 1.算法我认为脱胎于数学，先走数学公式，再写算法。用 Latex数学公式符号，可以简单变形后变成变量名字。 2.每个算法要求做成函数的形式，方便将来使用。</p></div><h1 id="编程导航"><a href="./20240221b.html#算法训练">编程导航</a></h1><h1 id="题目重述">题目重述</h1><p>  给定一个整数数组 <code>IntArray</code> 和一个整数目标值<code>IntTarget</code>，请你在该数组中找出和为目标值 IntTarget的那两个整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h1 id="数学建模">数学建模</h1><p>  设一维数组的名称为 <spanclass="math inline">\(A\)</span>，数组的元素个数为 <spanclass="math inline">\(n\)</span>，其中 <span class="math inline">\(n\geq 2\)</span>，元素分别为 <spanclass="math inline">\(a_0\)</span>、<spanclass="math inline">\(a_1\)</span>、···、<spanclass="math inline">\(a_{n-1}\)</span>，且均为整数，并记为 <spanclass="math inline">\(a_i\)</span>，其中 <span class="math inline">\(0\leq i \leq (n - 1)\)</span>，整数目标值为 <spanclass="math inline">\(b\)</span>。取出的两个整数中，其中一个可以同记为<span class="math inline">\(a_i\)</span>，另外一个整数记为 <spanclass="math inline">\(a_j\)</span>，其中 <span class="math inline">\(0\leq j \leq (n - 1)\)</span>，且 <span class="math inline">\(j \neqi\)</span>，<span class="math inline">\(n\)</span>、<spanclass="math inline">\(i\)</span>、<span class="math inline">\(j\)</span>均为整数，若存在 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span>，使得 <span class="math inline">\(a_i +a_j = b\)</span>，求 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span>的值。</p><h1 id="算法代码">算法代码</h1><h2 id="思路">思路</h2><p>  这个没有很深的公式了，直接写就好了。我们可以做差和 <spanclass="math inline">\(0\)</span> 比较：</p><p><span class="math display">\[b - a_i - a_j = 0\]</span></p><h2 id="接口转换">接口转换</h2><table><thead><tr class="header"><th>数学符号</th><th>代码变量</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(A\)</span></td><td>signed int Array[] = {0,1,2}</td><td>输入矩阵</td></tr><tr class="even"><td><span class="math inline">\(n\)</span></td><td>unsigned int n = 3</td><td>元素个数</td></tr><tr class="odd"><td><span class="math inline">\(b\)</span></td><td>signed int b = 2</td><td>输入目标值</td></tr><tr class="even"><td><span class="math inline">\(i\)</span></td><td>unsigned int i = 0</td><td>第 <span class="math inline">\(i\)</span> 个元素</td></tr><tr class="odd"><td><span class="math inline">\(j\)</span></td><td>unsigned int j = 1</td><td>第 <span class="math inline">\(j\)</span> 个元素</td></tr><tr class="even"><td>-</td><td>unsigned int State = 0</td><td>默认为 <span class="math inline">\(0\)</span>，匹配成功为 <spanclass="math inline">\(1\)</span></td></tr></tbody></table><h2 id="代码">代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//匹配状态</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> State = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="comment">//矩阵</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> Array[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">  <span class="comment">//目标值</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">//计算元素个数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> n = <span class="built_in">sizeof</span>(Array)/<span class="built_in">sizeof</span>(<span class="type">signed</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//输出</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i = i + <span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; n; j = j + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(b - Array[i] - Array[j] == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        State = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(State == <span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回数组下标</span></span><br><span class="line">  cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🍰本文记录力扣C++算法的学习内容</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://www.adunas.top/tags/C/"/>
    
    <category term="variable" scheme="https://www.adunas.top/tags/variable/"/>
    
  </entry>
  
  <entry>
    <title>C++ 变量</title>
    <link href="https://www.adunas.top/posts/20240315b.html"/>
    <id>https://www.adunas.top/posts/20240315b.html</id>
    <published>2024-03-15T08:42:27.000Z</published>
    <updated>2024-03-15T08:42:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程导航"><a href="./20240221b.html#变量">编程导航</a></h1><h1 id="基础知识">基础知识</h1><p>  变量的类型有：</p><ol type="1"><li>整数类型：int</li><li>浮点类型（小数类型）：double、float</li><li>字符类型：char</li><li>布尔类型：bool</li><li>字符串类型：string</li><li>数组类型：arry</li><li>对象类型：object</li></ol><h1 id="c">C++</h1><h2 id="查询变量信息">查询变量信息</h2><p>  查询值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TestNumber 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntC = TestNumber;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; IntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; IntC &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p>  查询地址，采用指针的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TestNumber 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntC = TestNumber;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;IntC &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p>这种变量会在每次运行程序时随机分配，所以地址会发生变化。</p><p>  查询所占内存大小，使用函数 <code>sizeof</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TestNumber 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> IntC = TestNumber;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(IntC) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h2 id="整型">整型</h2><h3 id="无符号">无符号</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> UnsignedIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> UnsignedShortIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> UnsignedShortC = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> UnsignedLongIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> UnsignedLongC = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> UnsignedLongLongIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> UnsignedLongLongC = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="未说明符号">未说明符号</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> IntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">short</span> <span class="type">int</span> ShortIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">short</span> ShortC = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">int</span> LongIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> LongC = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> LongLongIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> LongLongC = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="有符号">有符号</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> SignedIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">short</span> <span class="type">int</span> SignedShortIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">short</span> SignedShortC = <span class="number">0</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">int</span> SignedLongIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> SignedLongC = <span class="number">0</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> SignedLongLongIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">long</span> SignedLongLongC = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="测试代码">测试代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TestNumber -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//整型</span></span><br><span class="line">    <span class="comment">//无符号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> UnsignedIntC = TestNumber;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> UnsignedShortIntC = TestNumber;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> UnsignedShortC = TestNumber;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> UnsignedLongIntC = TestNumber;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> UnsignedLongC = TestNumber;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> UnsignedLongLongIntC = TestNumber;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> UnsignedLongLongC = TestNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无特殊说明</span></span><br><span class="line">    <span class="type">int</span> IntC = TestNumber;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> ShortIntC = TestNumber;</span><br><span class="line">    <span class="type">short</span> ShortC = TestNumber;</span><br><span class="line">    <span class="type">long</span> <span class="type">int</span> LongIntC = TestNumber;</span><br><span class="line">    <span class="type">long</span> LongC = TestNumber;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> LongLongIntC = TestNumber;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> LongLongC = TestNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有符号</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> SignedIntC = TestNumber;</span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span> <span class="type">int</span> SignedShortIntC = TestNumber;</span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span> SignedShortC = TestNumber;</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span> <span class="type">int</span> SignedLongIntC = TestNumber;</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span> SignedLongC = TestNumber;</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> SignedLongLongIntC = TestNumber;</span><br><span class="line">    <span class="type">signed</span> <span class="type">long</span> <span class="type">long</span> SignedLongLongC = TestNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;变量&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;|&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//整型</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;|_&quot;</span> &lt;&lt; <span class="string">&quot;整型，取值为：&quot;</span> &lt;&lt; TestNumber &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//无符号</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| |_&quot;</span> &lt;&lt; <span class="string">&quot;无符号&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//整型 unsigned int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;无符号整型 unsigned int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;UnsignedIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(UnsignedIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; UnsignedIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; UnsignedIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//短整型 unsigned short int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;无符号短整型 unsigned short int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;UnsignedShortIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(UnsignedShortIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; UnsignedShortIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; UnsignedShortIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//短型 unsigned short</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;无符号短型 unsigned short&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;UnsignedShortC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(UnsignedShortC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; UnsignedShortC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; UnsignedShortC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长整型 unsigned long int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;无符号长整型 unsigned long int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;UnsignedLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(UnsignedLongIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; UnsignedLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; UnsignedLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长型 unsigned long</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;无符号长型 unsigned long&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;UnsignedLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(UnsignedLongC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; UnsignedLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; UnsignedLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长长整型 unsigned long long int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;无符号长长整型 unsigned long long int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;UnsignedLongLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(UnsignedLongLongIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; UnsignedLongLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; UnsignedLongLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长长型 unsigned long long</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;无符号长长型 unsigned long long&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;UnsignedLongLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(UnsignedLongLongC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; UnsignedLongLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; UnsignedLongLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//无特殊说明</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| |_&quot;</span> &lt;&lt; <span class="string">&quot;无特殊说明&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//整型 int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;整型 int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;IntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(IntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; IntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; IntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//短整型 short int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;短整型 short int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;ShortIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(ShortIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; ShortIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; ShortIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//短型 short</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;短型 short&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;ShortC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(ShortC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; ShortC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; ShortC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长整型 long int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;长整型 long int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;LongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(LongIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; LongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; LongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长型 long</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;长型 long&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;LongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(LongC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; LongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; LongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长长整型 long long int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;长长整型 long long int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;LongLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(LongLongIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; LongLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; LongLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长长型 long long</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;长长型 long long&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;LongLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(LongLongC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; LongLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; LongLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有符号</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| |_&quot;</span> &lt;&lt; <span class="string">&quot;有符号&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//整型 signed int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;有符号整型 signed int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;SignedIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(SignedIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; SignedIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; SignedIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//短整型 signed short int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;有符号短整型 signed short int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;SignedShortIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(SignedShortIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; SignedShortIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; SignedShortIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//短型 signed short</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;有符号短型 signed short&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;SignedShortC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(SignedShortC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; SignedShortC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; SignedShortC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长整型 signed long int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;有符号长整型 signed long int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;SignedLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(SignedLongIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; SignedLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; SignedLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长型 signed long</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;有符号长型 signed long&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;SignedLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(SignedLongC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; SignedLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; SignedLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长长整型 signed long long int</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;有符号长长整型 signed long long int&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;SignedLongLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(SignedLongLongIntC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; SignedLongLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; SignedLongLongIntC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |&quot;</span> &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//长长型 signed long long</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | |_&quot;</span> &lt;&lt; <span class="string">&quot;有符号长长型 signed long long&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;地址：&quot;</span> &lt;&lt; &amp;SignedLongLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;长度：&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(SignedLongLongC) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;十六进制值：&quot;</span> &lt;&lt; std::hex &lt;&lt; SignedLongLongC &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;| | | |_&quot;</span> &lt;&lt; <span class="string">&quot;表达值：&quot;</span> &lt;&lt; std::dec &lt;&lt; SignedLongLongC &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h3 id="总结">总结</h3><ol type="1"><li>无论有符号或者无符号，都可以初始化位一个十进制的负数，都会用相同的补码存储下来，只是表达值不同而已。</li><li>无特殊说明的都是有符号的整型。</li><li>短型不会超过普通的整型，长型不会短于普通的整型。但是具体长度会因为系统位数发生改变。</li></ol><h3 id="规范">规范</h3><p>  其中，Signed 可以省略，默认就是有符号的。而对于长短整型，int就可以省略。但是后面就不进行省略（缩写）了，写全拼。因为虽然简化了，但是可读性变差了。总结下来就是以下内容：</p><h4 id="无符号-1">无符号</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> UnsignedIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> UnsignedShortIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> UnsignedLongIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> UnsignedLongLongIntC = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="有符号-1">有符号</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> SignedIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">short</span> <span class="type">int</span> SignedShortIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">int</span> SignedLongIntC = <span class="number">0</span>;</span><br><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> SignedLongLongIntC = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>四个无符号的，四个有符号的。核心是四个：整型、短整型、长整型、长长整型。</p>]]></content>
    
    
    <summary type="html">🥮本文学习 C++ 变量的特性</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://www.adunas.top/tags/C/"/>
    
    <category term="variable" scheme="https://www.adunas.top/tags/variable/"/>
    
  </entry>
  
  <entry>
    <title>原码反码和补码</title>
    <link href="https://www.adunas.top/posts/20240315a.html"/>
    <id>https://www.adunas.top/posts/20240315a.html</id>
    <published>2024-03-15T07:03:02.000Z</published>
    <updated>2024-03-15T07:03:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程导航"><ahref="./20240221b.html#原码反码和补码">编程导航</a></h1><h1 id="简述">简述</h1><p>  原码、反码和补码是符合计算机硬件中逻辑单元的规则，需要从这个角度去理解。直接构成二进制加减乘除的规则。</p><p>根据实际硬件的最简化原则，最小单元为二进制，且一定是二的倍数。简化考虑一个四位二进制数。这一般与内存的位数有关，但必须是成倍增加，常见的为8 位、16 位和 32 位。</p><p>  所有计算都是二进制数，用 0 和 1计算。这符合高低电平的一个物理规律。</p><h1 id="原理">原理</h1><table style="width:100%;"><colgroup><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th>内存十六进制</th><th>原码</th><th>有符号</th><th>无符号</th><th>反码</th><th>补码（内存二进制）</th><th>人逻辑有符号二进制</th></tr></thead><tbody><tr class="odd"><td>8</td><td>1000</td><td>-8</td><td>8</td><td>1111</td><td>1000</td><td>-0</td></tr><tr class="even"><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td></td></tr><tr class="odd"><td>7</td><td>0111</td><td>7</td><td>7</td><td>0111</td><td>0111</td><td>7</td></tr><tr class="even"><td>6</td><td>0110</td><td>6</td><td>6</td><td>0110</td><td>0110</td><td>6</td></tr><tr class="odd"><td>5</td><td>0101</td><td>5</td><td>5</td><td>0101</td><td>0101</td><td>5</td></tr><tr class="even"><td>4</td><td>0100</td><td>4</td><td>4</td><td>0100</td><td>0100</td><td>4</td></tr><tr class="odd"><td>3</td><td>0011</td><td>3</td><td>3</td><td>0011</td><td>0011</td><td>3</td></tr><tr class="even"><td>2</td><td>0010</td><td>2</td><td>2</td><td>0010</td><td>0010</td><td>2</td></tr><tr class="odd"><td>1</td><td>0001</td><td>1</td><td>1</td><td>0001</td><td>0001</td><td>1</td></tr><tr class="even"><td>0</td><td>0000</td><td>0</td><td>0</td><td>0000</td><td>0000</td><td>0</td></tr><tr class="odd"><td>F</td><td>1001</td><td>-1</td><td>15</td><td>1110</td><td>1111</td><td>-7</td></tr><tr class="even"><td>E</td><td>1010</td><td>-2</td><td>14</td><td>1101</td><td>1110</td><td>-6</td></tr><tr class="odd"><td>D</td><td>1011</td><td>-3</td><td>13</td><td>1100</td><td>1101</td><td>-5</td></tr><tr class="even"><td>C</td><td>1100</td><td>-4</td><td>12</td><td>1011</td><td>1100</td><td>-4</td></tr><tr class="odd"><td>B</td><td>1101</td><td>-5</td><td>11</td><td>1010</td><td>1011</td><td>-3</td></tr><tr class="even"><td>A</td><td>1110</td><td>-6</td><td>10</td><td>1001</td><td>1010</td><td>-2</td></tr><tr class="odd"><td>9</td><td>1111</td><td>-7</td><td>9</td><td>1000</td><td>1001</td><td>-1</td></tr><tr class="even"><td>8</td><td>1000</td><td>-8</td><td>8</td><td>1111</td><td>1000</td><td>-0</td></tr><tr class="odd"><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td><td>-</td></tr><tr class="even"><td>7</td><td>0111</td><td>7</td><td>7</td><td>0111</td><td>0111</td><td>7</td></tr></tbody></table><ol type="1"><li>从 <code>有符号</code> 列入手，以 0位起始，向上增加，向下减小。</li><li>对应 <code>原码</code> 列，其中最高位为符号位，<code>0</code>代表正数，<code>1</code> 代表负数，剩下的全为数值位，三位二进制能表示“0-7”；向上或者向下封顶后会循环，按照计算机的计算逻辑，符号位也会进位，所以最上面一行和最小面一行，发生符号变换，数字进行循环。</li><li>不考虑符号时，可以直接写出 <code>无符号</code> 列。</li><li>对于非负原码，反码就是原码；对于负数原码，反码是将原码除了一位符号位，剩余位全部取反，得到<code>反码</code> 列。</li><li>对于非负原码，补码就是反码，也是原码；对于负数原码，补码是将反码加一，得到<code>补码（内存二进制）</code> 列。</li><li>计算机内存存储的数字位补码，写成十六进制的数，得到<code>内存十六进制</code> 列。</li><li>按照人类书写规则，从补码出发，得到 <code>人逻辑有符号二进制</code>列。</li></ol><p>结论和说明：</p><ol type="1"><li>人类的逻辑和机器的逻辑在负数上有很大的差异，这是原码和补码产生的初衷。原码代表人的思维，补码代表机器的逻辑。而反码时人转化原码和补码的中间产物，视为工具。<ol type="1"><li><code>原码</code> 列的思维前面提到。</li><li><code>补码（内存二进制）</code> 列可以看出，数字是连续的，从 0 到 -1编码数字没有突变，是符合机器的。</li></ol></li><li>补码的补码是原码，也就是说原码和补码是一个互逆过程。同理，原码的反码和补码的反码相同。</li><li>“进位”和“溢出”，对于有符号数，其中除了符号位以外位进位循环，多余的数会溢出，可以假设它会向高位无限借位或进位，因为超出的范围我们并不关心。而在计算机中，用补码表示后，符号位也会参与进位或者借位“循环”，不便于用人类十进制理解了，但是方便了机器。无论如何就像一个时钟一样，是一种循环的规则。</li></ol><h1 id="计算">计算</h1><p>  有了原码、反码和补码后，就可以很方便的进行计算。</p><h2 id="加法">加法</h2><p>  同位相加，与门连接下一位，同为一则进位，以此循环。当然是用计算机存储模式——补码进行计算。</p><h2 id="减法">减法</h2><p>  相减就是相加一个负数。化为加法即可。</p><h2 id="乘法">乘法</h2><p>  向前移位。</p><h2 id="除法">除法</h2><p>  向后移位。</p><h1 id="后记">后记</h1><p>  即无论是有符号还是无符号，计算机内存储的数字的形式不变，有符号和无符号相当于一种转译，显示给人看的。所以计算机计算的时候是一样的。而选择错误的范围和符号后就会导致结果错误。</p>]]></content>
    
    
    <summary type="html">🍘本文厘清原码、反码和补码</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="计算机原理" scheme="https://www.adunas.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>黑马教程-C++基础入门</title>
    <link href="https://www.adunas.top/posts/20240312a.html"/>
    <id>https://www.adunas.top/posts/20240312a.html</id>
    <published>2024-03-12T02:29:16.000Z</published>
    <updated>2024-03-12T02:29:16.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>源文本为黑马程序员的 C++教程，未来会根据自身的学习需求进行编辑调整。视频地址：<ahref="https://www.bilibili.com/video/BV1et411b73Z/?share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">【黑马程序员匠心之作|C++教程从0到1入门编程,学习编程不再难】</a>。</p></div><h1 id="编程导航"><ahref="./20240221b.html#黑马程序员-C++">编程导航</a></h1><h1 id="c初识">C++初识</h1><h2 id="第一个c程序"><ahref="https://www.bilibili.com/video/BV1et411b73Z/?p=2&amp;share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">第一个C++程序</a></h2><p>编写一个C++程序总共分为4个步骤</p><ul><li>创建项目</li><li>创建文件</li><li>编写代码</li><li>运行程序</li></ul><h3 id="创建项目">创建项目</h3><p>​ Visual Studio是我们用来编写C++程序的主要工具，我们先将它打开</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/1541383178746.png" /></p><p><imgsrc="https://picture.adunas.top/Article/20240312a/1541384366413.png" /></p><h3 id="创建文件">创建文件</h3><p>右键源文件，选择添加-&gt;新建项</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/1541383817248.png" /></p><p>给C++文件起个名称，然后点击添加即可。</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/1541384140042.png" /></p><h3 id="编写代码">编写代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行程序">运行程序</h3><p><imgsrc="https://picture.adunas.top/Article/20240312a/1541384818688.png" /></p><style>  .container1 {      width: 100%; /* 设置容器的宽度为90% */      margin: 0 auto; /* 水平居中容器 */      position: relative; /* 设置容器的定位方式为相对定位 */      padding-top: 100%; /* 16大格 * 5大格，高宽比为：0.3125 */      height: 0; /* 设置容器的高度为0，使其自适应内容的高度 */  }    .container-iframe {      position: absolute; /* 设置iframe的定位方式为绝对定位 */      top: 0; /* 将iframe定位到容器的顶部 */      left: 0; /* 将iframe定位到容器的左侧 */      width: 100%; /* 设置iframe的宽度为100% */      height: 100%; /* 设置iframe的高度为100% */      border: none; /* 可选：移除iframe的边框 */  }</style><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCv.html" frameborder="0">    </iframe>  </div><h2 id="注释">注释</h2><p><strong>作用</strong>：在代码中加一些说明和解释，方便自己或其他程序员程序员阅读代码</p><p><strong>两种格式</strong></p><ol type="1"><li><strong>单行注释</strong>：<code>// 描述信息</code><ul><li>通常放在一行代码的上方，或者一条语句的末尾，==对该行代码说明==</li></ul></li><li><strong>多行注释</strong>： <code>/* 描述信息 */</code><ul><li>通常放在一段代码的上方，==对该段代码做整体说明==</li></ul></li></ol><blockquote><p>提示：编译器在编译代码时，会忽略注释的内容</p></blockquote><h2 id="变量">变量</h2><p><strong>作用</strong>：给一段指定的内存空间起名，方便操作这段内存</p><p><strong>语法</strong>：<code>数据类型 变量名 = 初始值;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量的定义</span></span><br><span class="line"><span class="comment">//语法：数据类型  变量名 = 初始值</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCw.html" frameborder="0">    </iframe>  </div><p></b></p><blockquote><p>注意：C++在创建变量时，必须给变量一个初始值，否则会报错</p></blockquote><h2 id="常量">常量</h2><p><strong>作用</strong>：用于记录程序中不可更改的数据</p><p>C++定义常量两种方式</p><ol type="1"><li><strong>#define</strong> 宏常量： <code>#define 常量名 常量值</code><ul><li>==通常在文件上方定义==，表示一个常量</li></ul></li><li><strong>const</strong>修饰的变量<code>const 数据类型 常量名 = 常量值</code><ul><li>==通常在变量定义前加关键字const==，修饰该变量为常量，不可修改</li></ul></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、宏常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> day 7</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一周里总共有 &quot;</span> &lt;&lt; day &lt;&lt; <span class="string">&quot; 天&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//day = 8;  //报错，宏常量不可以修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、const修饰变量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> month = <span class="number">12</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一年里总共有 &quot;</span> &lt;&lt; month &lt;&lt; <span class="string">&quot; 个月份&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//month = 24; //报错，常量是不可以修改的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCA.html" frameborder="0">    </iframe>  </div><h2 id="关键字">关键字</h2><p><strong>作用：</strong>关键字是C++中预先保留的单词（标识符）</p><ul><li><strong>在定义变量或者常量时候，不要用关键字</strong></li></ul><p>C++关键字如下：</p><table><colgroup><col style="width: 17%" /><col style="width: 21%" /><col style="width: 28%" /><col style="width: 19%" /><col style="width: 14%" /></colgroup><thead><tr class="header"><th>asm</th><th>do</th><th>if</th><th>return</th><th>typedef</th></tr></thead><tbody><tr class="odd"><td>auto</td><td>double</td><td>inline</td><td>short</td><td>typeid</td></tr><tr class="even"><td>bool</td><td>dynamic_cast</td><td>int</td><td>signed</td><td>typename</td></tr><tr class="odd"><td>break</td><td>else</td><td>long</td><td>sizeof</td><td>union</td></tr><tr class="even"><td>case</td><td>enum</td><td>mutable</td><td>static</td><td>unsigned</td></tr><tr class="odd"><td>catch</td><td>explicit</td><td>namespace</td><td>static_cast</td><td>using</td></tr><tr class="even"><td>char</td><td>export</td><td>new</td><td>struct</td><td>virtual</td></tr><tr class="odd"><td>class</td><td>extern</td><td>operator</td><td>switch</td><td>void</td></tr><tr class="even"><td>const</td><td>false</td><td>private</td><td>template</td><td>volatile</td></tr><tr class="odd"><td>const_cast</td><td>float</td><td>protected</td><td>this</td><td>wchar_t</td></tr><tr class="even"><td>continue</td><td>for</td><td>public</td><td>throw</td><td>while</td></tr><tr class="odd"><td>default</td><td>friend</td><td>register</td><td>true</td><td></td></tr><tr class="even"><td>delete</td><td>goto</td><td>reinterpret_cast</td><td>try</td><td></td></tr></tbody></table><p><code>提示：在给变量或者常量起名称时候，不要用C++的关键字，否则会产生歧义。</code></p><h2 id="标识符命名规则">标识符命名规则</h2><p><strong>作用</strong>：C++规定给标识符（变量、常量）命名时，有一套自己的规则</p><ul><li>标识符不能是关键字</li><li>标识符只能由字母、数字、下划线组成</li><li>第一个字符必须为字母或下划线</li><li>标识符中字母区分大小写</li></ul><blockquote><p>建议：给标识符命名时，争取做到见名知意的效果，方便自己和他人的阅读</p></blockquote><h1 id="数据类型">数据类型</h1><p>C++规定在创建一个变量或者常量时，必须要指定出相应的数据类型，否则无法给变量分配内存</p><h2 id="整型"><ahref="https://www.bilibili.com/video/BV1et411b73Z/?p=8&amp;share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">整型</a></h2><p><strong>作用</strong>：整型变量表示的是==整数类型==的数据</p><p>C++中能够表示整型的类型有以下几种方式，<strong>区别在于所占内存空间不同</strong>：</p><table><colgroup><col style="width: 23%" /><col style="width: 57%" /><col style="width: 19%" /></colgroup><thead><tr class="header"><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th>取值范围</th></tr></thead><tbody><tr class="odd"><td>short(短整型)</td><td>2字节</td><td>(-2^15 ~ 2^15-1)</td></tr><tr class="even"><td>int(整型)</td><td>4字节</td><td>(-2^31 ~ 2^31-1)</td></tr><tr class="odd"><td>long(长整形)</td><td>Windows为4字节，Linux为4字节(32位)，8字节(64位)</td><td>(-2^31 ~ 2^31-1)</td></tr><tr class="even"><td>long long(长长整形)</td><td>8字节</td><td>(-2^63 ~ 2^63-1)</td></tr></tbody></table><h2 id="sizeof关键字">sizeof关键字</h2><p><strong>作用：</strong>利用 sizeof关键字可以==统计数据类型所占内存大小==，单位为字节。</p><p><strong>语法：</strong> <code>sizeof( 数据类型 / 变量)</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;short 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;int 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;long long 类型所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCB.html" frameborder="0">    </iframe>  </div><p></b></p><blockquote><p><strong>整型结论</strong>：==short &lt; int &lt;= long &lt;= longlong==</p></blockquote><h2 id="实型浮点型">实型（浮点型）</h2><p><strong>作用</strong>：用于==表示小数==</p><p>浮点型变量分为两种：</p><ol type="1"><li>单精度float</li><li>双精度double</li></ol><p>两者的<strong>区别</strong>在于表示的有效数字范围不同。</p><table><thead><tr class="header"><th><strong>数据类型</strong></th><th><strong>占用空间</strong></th><th><strong>有效数字范围</strong></th></tr></thead><tbody><tr class="odd"><td>float</td><td>4字节</td><td>7位有效数字</td></tr><tr class="even"><td>double</td><td>8字节</td><td>15～16位有效数字</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> f1 = <span class="number">3.14f</span>;</span><br><span class="line"><span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; d1&lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;float  sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(f1) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;double sizeof = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(d1) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//科学计数法</span></span><br><span class="line"><span class="type">float</span> f2 = <span class="number">3e2</span>; <span class="comment">// 3 * 10 ^ 2 </span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f2 = &quot;</span> &lt;&lt; f2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> f3 = <span class="number">3e-2</span>;  <span class="comment">// 3 * 0.1 ^ 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;f3 = &quot;</span> &lt;&lt; f3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCC.html" frameborder="0">    </iframe>  </div><h2 id="字符型">字符型</h2><p><strong>作用：</strong>字符型变量用于显示单个字符</p><p><strong>语法：</strong><code>char ch = 'a';</code></p><blockquote><p>注意1：在显示字符型变量时，用单引号将字符括起来，不要用双引号</p></blockquote><blockquote><p>注意2：单引号内只能有一个字符，不可以是字符串</p></blockquote><ul><li>C和C++中字符型变量只占用==1个字节==。</li><li>字符型变量并不是把字符本身放到内存中存储，而是将对应的ASCII编码放入到存储单元</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ch = &quot;abcde&quot;; //错误，不可以用双引号</span></span><br><span class="line"><span class="comment">//ch = &#x27;abcde&#x27;; //错误，单引号内只能引用一个字符</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (<span class="type">int</span>)ch &lt;&lt; endl;  <span class="comment">//查看字符a对应的ASCII码</span></span><br><span class="line">ch = <span class="number">97</span>; <span class="comment">//可以直接用ASCII给字符型变量赋值</span></span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCD.html" frameborder="0">    </iframe>  </div><p>ASCII码表格：</p><table style="width:100%;"><colgroup><col style="width: 13%" /><col style="width: 14%" /><col style="width: 13%" /><col style="width: 9%" /><col style="width: 13%" /><col style="width: 9%" /><col style="width: 13%" /><col style="width: 9%" /></colgroup><thead><tr class="header"><th><strong>ASCII</strong>值</th><th><strong>控制字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th><th><strong>ASCII</strong>值</th><th><strong>字符</strong></th></tr></thead><tbody><tr class="odd"><td>0</td><td>NUT</td><td>32</td><td>(space)</td><td>64</td><td>@</td><td>96</td><td>、</td></tr><tr class="even"><td>1</td><td>SOH</td><td>33</td><td>!</td><td>65</td><td>A</td><td>97</td><td>a</td></tr><tr class="odd"><td>2</td><td>STX</td><td>34</td><td>"</td><td>66</td><td>B</td><td>98</td><td>b</td></tr><tr class="even"><td>3</td><td>ETX</td><td>35</td><td>#</td><td>67</td><td>C</td><td>99</td><td>c</td></tr><tr class="odd"><td>4</td><td>EOT</td><td>36</td><td>$</td><td>68</td><td>D</td><td>100</td><td>d</td></tr><tr class="even"><td>5</td><td>ENQ</td><td>37</td><td>%</td><td>69</td><td>E</td><td>101</td><td>e</td></tr><tr class="odd"><td>6</td><td>ACK</td><td>38</td><td>&amp;</td><td>70</td><td>F</td><td>102</td><td>f</td></tr><tr class="even"><td>7</td><td>BEL</td><td>39</td><td>,</td><td>71</td><td>G</td><td>103</td><td>g</td></tr><tr class="odd"><td>8</td><td>BS</td><td>40</td><td>(</td><td>72</td><td>H</td><td>104</td><td>h</td></tr><tr class="even"><td>9</td><td>HT</td><td>41</td><td>)</td><td>73</td><td>I</td><td>105</td><td>i</td></tr><tr class="odd"><td>10</td><td>LF</td><td>42</td><td>*</td><td>74</td><td>J</td><td>106</td><td>j</td></tr><tr class="even"><td>11</td><td>VT</td><td>43</td><td>+</td><td>75</td><td>K</td><td>107</td><td>k</td></tr><tr class="odd"><td>12</td><td>FF</td><td>44</td><td>,</td><td>76</td><td>L</td><td>108</td><td>l</td></tr><tr class="even"><td>13</td><td>CR</td><td>45</td><td>-</td><td>77</td><td>M</td><td>109</td><td>m</td></tr><tr class="odd"><td>14</td><td>SO</td><td>46</td><td>.</td><td>78</td><td>N</td><td>110</td><td>n</td></tr><tr class="even"><td>15</td><td>SI</td><td>47</td><td>/</td><td>79</td><td>O</td><td>111</td><td>o</td></tr><tr class="odd"><td>16</td><td>DLE</td><td>48</td><td>0</td><td>80</td><td>P</td><td>112</td><td>p</td></tr><tr class="even"><td>17</td><td>DCI</td><td>49</td><td>1</td><td>81</td><td>Q</td><td>113</td><td>q</td></tr><tr class="odd"><td>18</td><td>DC2</td><td>50</td><td>2</td><td>82</td><td>R</td><td>114</td><td>r</td></tr><tr class="even"><td>19</td><td>DC3</td><td>51</td><td>3</td><td>83</td><td>S</td><td>115</td><td>s</td></tr><tr class="odd"><td>20</td><td>DC4</td><td>52</td><td>4</td><td>84</td><td>T</td><td>116</td><td>t</td></tr><tr class="even"><td>21</td><td>NAK</td><td>53</td><td>5</td><td>85</td><td>U</td><td>117</td><td>u</td></tr><tr class="odd"><td>22</td><td>SYN</td><td>54</td><td>6</td><td>86</td><td>V</td><td>118</td><td>v</td></tr><tr class="even"><td>23</td><td>TB</td><td>55</td><td>7</td><td>87</td><td>W</td><td>119</td><td>w</td></tr><tr class="odd"><td>24</td><td>CAN</td><td>56</td><td>8</td><td>88</td><td>X</td><td>120</td><td>x</td></tr><tr class="even"><td>25</td><td>EM</td><td>57</td><td>9</td><td>89</td><td>Y</td><td>121</td><td>y</td></tr><tr class="odd"><td>26</td><td>SUB</td><td>58</td><td>:</td><td>90</td><td>Z</td><td>122</td><td>z</td></tr><tr class="even"><td>27</td><td>ESC</td><td>59</td><td>;</td><td>91</td><td>[</td><td>123</td><td>{</td></tr><tr class="odd"><td>28</td><td>FS</td><td>60</td><td>&lt;</td><td>92</td><td>/</td><td>124</td><td>|</td></tr><tr class="even"><td>29</td><td>GS</td><td>61</td><td>=</td><td>93</td><td>]</td><td>125</td><td>}</td></tr><tr class="odd"><td>30</td><td>RS</td><td>62</td><td>&gt;</td><td>94</td><td>^</td><td>126</td><td>`</td></tr><tr class="even"><td>31</td><td>US</td><td>63</td><td>?</td><td>95</td><td>_</td><td>127</td><td>DEL</td></tr></tbody></table><p>ASCII 码大致由以下<strong>两部分组</strong>成：</p><ul><li>ASCII 非打印控制字符： ASCII 表上的数字 <strong>0-31</strong>分配给了控制字符，用于控制像打印机等一些外围设备。</li><li>ASCII 打印字符：数字 <strong>32-126</strong>分配给了能在键盘上找到的字符，当查看或打印文档时就会出现。</li></ul><h2 id="转义字符">转义字符</h2><p><strong>作用：</strong>用于表示一些==不能显示出来的ASCII字符==</p><p>现阶段我们常用的转义字符有：<code>\n  \\  \t</code></p><table><colgroup><col style="width: 16%" /><col style="width: 52%" /><col style="width: 31%" /></colgroup><thead><tr class="header"><th><strong>转义字符</strong></th><th><strong>含义</strong></th><th><strong>ASCII</strong>码值（十进制）</th></tr></thead><tbody><tr class="odd"><td></td><td>警报</td><td>007</td></tr><tr class="even"><td> 退格(BS) ，将当前位置移到前一列</td><td>008</td><td></td></tr><tr class="odd"><td> 换页(FF)，将当前位置移到下页开头</td><td>012</td><td></td></tr><tr class="even"><td>***</td><td><strong>换行(LF) ，将当前位置移到下一行开头</strong></td><td><strong>010</strong></td></tr><tr class="odd"><td> 回车(CR) ，将当前位置移到本行开头</td><td>013</td><td></td></tr><tr class="even"><td>**</td><td><strong>水平制表(HT) （跳到下一个TAB位置）</strong></td><td><strong>009</strong></td></tr><tr class="odd"><td> 垂直制表(VT)</td><td>011</td><td></td></tr><tr class="even"><td><strong>\\</strong></td><td><strong>代表一个反斜线字符""</strong></td><td><strong>092</strong></td></tr><tr class="odd"><td>'</td><td>代表一个单引号（撇号）字符</td><td>039</td></tr><tr class="even"><td>"</td><td>代表一个双引号字符</td><td>034</td></tr><tr class="odd"><td>?</td><td>代表一个问号</td><td>063</td></tr><tr class="even"><td>\0</td><td>数字0</td><td>000</td></tr><tr class="odd"><td></td><td>8进制转义字符，d范围0~7</td><td>3位8进制</td></tr><tr class="even"><td></td><td>16进制转义字符，h范围0<sub>9，a</sub>f，A~F</td><td>3位16进制</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\\&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\tHello&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCE.html" frameborder="0">    </iframe>  </div><h2 id="字符串型">字符串型</h2><p><strong>作用</strong>：用于表示一串字符</p><p><strong>两种风格</strong></p><ol type="1"><li><strong>C风格字符串</strong>：<code>char 变量名[] = "字符串值"</code></li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line">       </span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCG.html" frameborder="0">    </iframe>  </div><p></b></p><blockquote><p>注意：C风格的字符串要用双引号括起来</p></blockquote><ol start="2" type="1"><li><strong>C++风格字符串</strong>：<code>string  变量名 = "字符串值"</code></li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">   cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCI.html" frameborder="0">    </iframe>  </div><p></b> ​</p><blockquote><p>注意：C++风格字符串，需要加入头文件==#include&lt;string&gt;==</p></blockquote><h2 id="布尔类型-bool">布尔类型 bool</h2><p><strong>作用：</strong>布尔数据类型代表真或假的值</p><p>bool类型只有两个值：</p><ul><li>true --- 真（本质是1）</li><li>false --- 假（本质是0）</li></ul><p><strong>bool类型占==1个字节==大小</strong></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">flag = <span class="literal">false</span>;</span><br><span class="line">cout &lt;&lt; flag &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;size of bool = &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; endl; <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCK.html" frameborder="0">    </iframe>  </div><h2 id="数据的输入">数据的输入</h2><p><strong>作用：用于从键盘获取数据</strong></p><p><strong>关键字：</strong>cin</p><p><strong>语法：</strong> <code>cin &gt;&gt; 变量</code></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//整型输入</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入整型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点型输入</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入浮点型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; d;</span><br><span class="line">cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符型输入</span></span><br><span class="line"><span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入字符型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; ch;</span><br><span class="line">cout &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串型输入</span></span><br><span class="line">string str;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入字符串型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔类型输入</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入布尔型变量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; flag;</span><br><span class="line">cout &lt;&lt; flag &lt;&lt; endl;</span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"><span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运算符">运算符</h1><p><strong>作用：</strong>用于执行代码的运算</p><p>本章我们主要讲解以下几类运算符：</p><table><thead><tr class="header"><th><strong>运算符类型</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr class="odd"><td>算术运算符</td><td>用于处理四则运算</td></tr><tr class="even"><td>赋值运算符</td><td>用于将表达式的值赋给变量</td></tr><tr class="odd"><td>比较运算符</td><td>用于表达式的比较，并返回一个真值或假值</td></tr><tr class="even"><td>逻辑运算符</td><td>用于根据表达式的值返回真值或假值</td></tr></tbody></table><h2 id="算术运算符"><ahref="https://www.bilibili.com/video/BV1et411b73Z/?p=16&amp;share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">算术运算符</a></h2><p><strong>作用</strong>：用于处理四则运算</p><p>算术运算符包括以下符号：</p><table><thead><tr class="header"><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr class="odd"><td>+</td><td>正号</td><td>+3</td><td>3</td></tr><tr class="even"><td>-</td><td>负号</td><td>-3</td><td>-3</td></tr><tr class="odd"><td>+</td><td>加</td><td>10 + 5</td><td>15</td></tr><tr class="even"><td>-</td><td>减</td><td>10 - 5</td><td>5</td></tr><tr class="odd"><td>*</td><td>乘</td><td>10 * 5</td><td>50</td></tr><tr class="even"><td>/</td><td>除</td><td>10 / 5</td><td>2</td></tr><tr class="odd"><td>%</td><td>取模(取余)</td><td>10 % 3</td><td>1</td></tr><tr class="even"><td>++</td><td>前置递增</td><td>a=2; b=++a;</td><td>a=3; b=3;</td></tr><tr class="odd"><td>++</td><td>后置递增</td><td>a=2; b=a++;</td><td>a=3; b=2;</td></tr><tr class="even"><td>--</td><td>前置递减</td><td>a=2; b=--a;</td><td>a=1; b=1;</td></tr><tr class="odd"><td>--</td><td>后置递减</td><td>a=2; b=a--;</td><td>a=1; b=2;</td></tr></tbody></table><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加减乘除</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a1 + b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a1 - b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a1 * b1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; a1 / b1 &lt;&lt; endl;  <span class="comment">//两个整数相除结果依然是整数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; a2 / b2 &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//cout &lt;&lt; a3 / b3 &lt;&lt; endl; //报错，除数不可以为0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个小数可以相除</span></span><br><span class="line"><span class="type">double</span> d1 = <span class="number">0.5</span>;</span><br><span class="line"><span class="type">double</span> d2 = <span class="number">0.25</span>;</span><br><span class="line">cout &lt;&lt; d1 / d2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCM.html" frameborder="0">    </iframe>  </div><p></b></p><blockquote><p>总结：在除法运算中，除数不能为0</p></blockquote><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取模</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b1 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="number">10</span> % <span class="number">3</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a2 % b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b3 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; a3 % b3 &lt;&lt; endl; //取模运算时，除数也不能为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//两个小数不可以取模</span></span><br><span class="line"><span class="type">double</span> d1 = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">double</span> d2 = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; d1 % d2 &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCN.html" frameborder="0">    </iframe>  </div><p></b></p><blockquote><p>总结：只有整型变量可以进行取模运算</p></blockquote><p><strong>示例3：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递增</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置递增</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a++; <span class="comment">//等价于a = a + 1</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//前置递增</span></span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">++b;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//区别</span></span><br><span class="line"><span class="comment">//前置递增先对变量进行++，再计算表达式</span></span><br><span class="line"><span class="type">int</span> a2 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b2 = ++a2 * <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; b2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//后置递增先计算表达式，后对变量进行++</span></span><br><span class="line"><span class="type">int</span> a3 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b3 = a3++ * <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; b3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="container1">      <iframe class="container-iframe" src="https://tool.lu/coderunner/embed/eCO.html" frameborder="0">    </iframe>  </div><p></b></p><blockquote><p>总结：前置递增先对变量进行++，再计算表达式，后置递增相反</p></blockquote><h2 id="赋值运算符">赋值运算符</h2><p><strong>作用：</strong>用于将表达式的值赋给变量</p><p>赋值运算符包括以下几个符号：</p><table><thead><tr class="header"><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr class="odd"><td>=</td><td>赋值</td><td>a=2; b=3;</td><td>a=2; b=3;</td></tr><tr class="even"><td>+=</td><td>加等于</td><td>a=0; a+=2;</td><td>a=2;</td></tr><tr class="odd"><td>-=</td><td>减等于</td><td>a=5; a-=3;</td><td>a=2;</td></tr><tr class="even"><td>*=</td><td>乘等于</td><td>a=2; a*=2;</td><td>a=4;</td></tr><tr class="odd"><td>/=</td><td>除等于</td><td>a=4; a/=2;</td><td>a=2;</td></tr><tr class="even"><td>%=</td><td>模等于</td><td>a=3; a%2;</td><td>a=1;</td></tr></tbody></table><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值运算符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// =</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a += <span class="number">2</span>; <span class="comment">// a = a + 2;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a -= <span class="number">2</span>; <span class="comment">// a = a - 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a *= <span class="number">2</span>; <span class="comment">// a = a * 2</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a /= <span class="number">2</span>;  <span class="comment">// a = a / 2;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// %=</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">a %= <span class="number">2</span>;  <span class="comment">// a = a % 2;</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h2 id="比较运算符">比较运算符</h2><p><strong>作用：</strong>用于表达式的比较，并返回一个真值或假值</p><p>比较运算符有以下符号：</p><table><thead><tr class="header"><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr class="odd"><td>==</td><td>相等于</td><td>4 == 3</td><td>0</td></tr><tr class="even"><td>!=</td><td>不等于</td><td>4 != 3</td><td>1</td></tr><tr class="odd"><td>&lt;</td><td>小于</td><td>4 &lt; 3</td><td>0</td></tr><tr class="even"><td>&gt;</td><td>大于</td><td>4 &gt; 3</td><td>1</td></tr><tr class="odd"><td>&lt;=</td><td>小于等于</td><td>4 &lt;= 3</td><td>0</td></tr><tr class="even"><td>&gt;=</td><td>大于等于</td><td>4 &gt;= 1</td><td>1</td></tr></tbody></table><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a == b) &lt;&lt; endl; <span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a != b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &gt; b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &lt; b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &gt;= b) &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &lt;= b) &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>注意：C和C++ 语言的比较运算中， ==“真”用数字“1”来表示，“假”用数字“0”来表示。==</p></blockquote><h2 id="逻辑运算符">逻辑运算符</h2><p><strong>作用：</strong>用于根据表达式的值返回真值或假值</p><p>逻辑运算符有以下符号：</p><table><colgroup><col style="width: 12%" /><col style="width: 9%" /><col style="width: 9%" /><col style="width: 68%" /></colgroup><thead><tr class="header"><th><strong>运算符</strong></th><th><strong>术语</strong></th><th><strong>示例</strong></th><th><strong>结果</strong></th></tr></thead><tbody><tr class="odd"><td>!</td><td>非</td><td>!a</td><td>如果a为假，则!a为真； 如果a为真，则!a为假。</td></tr><tr class="even"><td>&amp;&amp;</td><td>与</td><td>a &amp;&amp; b</td><td>如果a和b都为真，则结果为真，否则为假。</td></tr><tr class="odd"><td>||</td><td>或</td><td>a || b</td><td>如果a和b有一个为真，则结果为真，二者都为假时，结果为假。</td></tr></tbody></table><p><strong>示例1：</strong>逻辑非</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 非</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; !a &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; !!a &lt;&lt; endl; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结： 真变假，假变真</p></blockquote><p><strong>示例2：</strong>逻辑与</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 与</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0 </span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a &amp;&amp; b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：逻辑==与==运算符总结： ==同真为真，其余为假==</p></blockquote><p><strong>示例3：</strong>逻辑或</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逻辑运算符  --- 或</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 1 </span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; (a || b) &lt;&lt; endl;<span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>逻辑==或==运算符总结： ==同假为假，其余为真==</p></blockquote><h1 id="程序流程结构">程序流程结构</h1><p>C/C++支持最基本的三种程序运行结构：==顺序结构、选择结构、循环结构==</p><ul><li>顺序结构：程序按顺序执行，不发生跳转</li><li>选择结构：依据条件是否满足，有选择的执行相应功能</li><li>循环结构：依据条件是否满足，循环多次执行某段代码</li></ul><h2 id="选择结构"><ahref="https://www.bilibili.com/video/BV1et411b73Z/?p=24&amp;share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">选择结构</a></h2><h3 id="if语句">if语句</h3><p><strong>作用：</strong>执行满足条件的语句</p><p>if语句的三种形式</p><ul><li><p>单行格式if语句</p></li><li><p>多行格式if语句</p></li><li><p>多条件的if语句</p><p>​</p></li></ul><ol type="1"><li>单行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;</code></li></ol><p><imgsrc="https://picture.adunas.top/Article/20240312a/clip_image002.png" /></p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//选择结构-单行if语句</span></span><br><span class="line">   <span class="comment">//输入一个分数，如果分数大于600分，视为考上一本大学，并在屏幕上打印</span></span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;请输入一个分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">   cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;您输入的分数为： &quot;</span> &lt;&lt; score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//if语句</span></span><br><span class="line">   <span class="comment">//注意事项，在if判断语句后面，不要加分号</span></span><br><span class="line">   <span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">   &#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;我考上了一本大学！！！&quot;</span> &lt;&lt; endl;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a>​</p><blockquote><p>注意：if条件表达式后不要加分号</p></blockquote><ol start="2" type="1"><li>多行格式if语句：<code>if(条件)&#123; 条件满足执行的语句 &#125;else&#123; 条件不满足执行的语句 &#125;;</code></li></ol><p><imgsrc="https://picture.adunas.top/Article/20240312a/clip_image002-1541662519170.png" /></p><p>​</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我未考上一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><ol start="3" type="1"><li>多条件的if语句：<code>if(条件1)&#123; 条件1满足执行的语句 &#125;else if(条件2)&#123;条件2满足执行的语句&#125;... else&#123; 都不满足执行的语句&#125;</code></li></ol><p><imgsrc="https://picture.adunas.top/Article/20240312a/clip_image002-1541662566808.png" /></p><p>​</p><p>​</p><p>​</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p><strong>嵌套if语句</strong>：在if语句中，可以嵌套使用if语句，达到更精确的条件判断</p><p>案例需求：</p><ul><li>提示用户输入一个高考考试分数，根据分数做如下判断</li><li>分数如果大于600分视为考上一本，大于500分考上二本，大于400考上三本，其余视为未考上本科；</li><li>在一本分数中，如果大于700分，考入北大，大于650分，考入清华，大于600考入人大。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请输入考试分数：&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了一本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (score &gt; <span class="number">700</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了北大&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">650</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了清华&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了人大&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">500</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了二本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &gt; <span class="number">400</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我考上了三本大学&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;我未考上本科&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p><strong>练习案例：</strong> 三只小猪称体重</p><p>有三只小猪ABC，请分别输入三只小猪的体重，并且判断哪只小猪最重？<imgsrc="https://picture.adunas.top/Article/20240312a/三只小猪.jpg" /></p><h3 id="三目运算符">三目运算符</h3><p><strong>作用：</strong> 通过三目运算符实现简单的判断</p><p><strong>语法：</strong><code>表达式1 ? 表达式2 ：表达式3</code></p><p><strong>解释：</strong></p><p>如果表达式1的值为真，执行表达式2，并返回表达式2的结果；</p><p>如果表达式1的值为假，执行表达式3，并返回表达式3的结果。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">c = a &gt; b ? a : b;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//C++中三目运算符返回的是变量,可以继续赋值</span></span><br><span class="line"></span><br><span class="line">(a &gt; b ? a : b) = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：和if语句比较，三目运算符优点是短小整洁，缺点是如果用嵌套，结构不清晰</p></blockquote><h3 id="switch语句">switch语句</h3><p><strong>作用：</strong>执行多条件分支语句</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 结果<span class="number">1</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 结果<span class="number">2</span>：执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:执行语句;<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请给电影评分 </span></span><br><span class="line"><span class="comment">//10 ~ 9   经典   </span></span><br><span class="line"><span class="comment">// 8 ~ 7   非常好</span></span><br><span class="line"><span class="comment">// 6 ~ 5   一般</span></span><br><span class="line"><span class="comment">// 5分以下 烂片</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> score = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请给电影打分&quot;</span> &lt;&lt; endl;</span><br><span class="line">cin &gt;&gt; score;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;经典&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;非常好&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;一般&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;烂片&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>注意1：switch语句中表达式类型只能是整型或者字符型</p></blockquote><blockquote><p>注意2：case里如果没有break，那么程序会一直向下执行</p></blockquote><blockquote><p>总结：与if语句比，对于多条件判断时，switch的结构清晰，执行效率高，缺点是switch不可以判断区间</p></blockquote><h2 id="循环结构">循环结构</h2><h3 id="while循环语句">while循环语句</h3><p><strong>作用：</strong>满足循环条件，执行循环语句</p><p><strong>语法：</strong><code>while(循环条件)&#123; 循环语句 &#125;</code></p><p><strong>解释：</strong>==只要循环条件的结果为真，就执行循环语句==</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/clip_image002-1541668640382.png" /></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (num &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>注意：在执行循环语句时候，程序必须提供跳出循环的出口，否则出现死循环</p></blockquote><p><strong>while循环练习案例：</strong>==猜数字==</p><p><strong>案例描述：</strong>系统随机生成一个1到100之间的数字，玩家进行猜测，如果猜错，提示玩家数字过大或过小，如果猜对恭喜玩家胜利，并且退出游戏。</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/猜数字.jpg" /></p><h3 id="do...while循环语句">do...while循环语句</h3><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong><code>do&#123; 循环语句 &#125; while(循环条件);</code></p><p><strong>注意：</strong>与while的区别在于==do...while会先执行一次循环语句==，再判断循环条件</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/clip_image002-1541671163478.png" /></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; num &lt;&lt; endl;</span><br><span class="line">num++;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (num &lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：与while循环区别在于，do...while先执行一次循环语句，再判断循环条件</p></blockquote><p><strong>练习案例：水仙花数</strong></p><p><strong>案例描述：</strong>水仙花数是指一个 3位数，它的每个位上的数字的 3次幂之和等于它本身</p><p>例如：1^3 + 5^3+ 3^3 = 153</p><p>请利用do...while语句，求出所有3位数中的水仙花数</p><h3 id="for循环语句">for循环语句</h3><p><strong>作用：</strong> 满足循环条件，执行循环语句</p><p><strong>语法：</strong><code>for(起始表达式;条件表达式;末尾循环体) &#123; 循环语句; &#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p><strong>详解：</strong></p><p><imgsrc="https://picture.adunas.top/Article/20240312a/1541673704101.png" /></p><blockquote><p>注意：for循环中的表达式，要用分号进行分隔</p></blockquote><blockquote><p>总结：while , do...while,for都是开发中常用的循环语句，for循环结构比较清晰，比较常用</p></blockquote><p><strong>练习案例：敲桌子</strong></p><p>案例描述：从1开始数到数字100，如果数字个位含有7，或者数字十位含有7，或者该数字是7的倍数，我们打印敲桌子，其余数字直接打印输出。</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/timg.gif" /></p><h3 id="嵌套循环">嵌套循环</h3><p><strong>作用：</strong>在循环体中再嵌套一层循环，解决一些实际问题</p><p>例如我们想在屏幕中打印如下图片，就需要利用嵌套循环</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/1541676003486.png" /></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//外层循环执行1次，内层循环执行1轮</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p><strong>练习案例：</strong>乘法口诀表</p><p>案例描述：利用嵌套循环，实现九九乘法表</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/0006018857256120_b.jpg" /></p><h2 id="跳转语句">跳转语句</h2><h3 id="break语句">break语句</h3><p><strong>作用:</strong> 用于跳出==选择结构==或者==循环结构==</p><p>break使用的时机：</p><ul><li>出现在switch条件语句中，作用是终止case并跳出switch</li><li>出现在循环语句中，作用是跳出当前的循环语句</li><li>出现在嵌套循环中，跳出最近的内层循环语句</li></ul><p><strong>示例1：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//1、在switch 语句中使用break</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;请选择您挑战副本的难度：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1、普通&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2、中等&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;3、困难&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (num)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您选择的是普通难度&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您选择的是中等难度&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;您选择的是困难难度&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p><strong>示例2：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//2、在循环语句中用break</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//跳出循环语句</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p><strong>示例3：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//在嵌套循环语句中使用break，退出内层循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h3 id="continue语句">continue语句</h3><p><strong>作用：</strong>在==循环语句==中，跳过本次循环中余下尚未执行的语句，继续执行下一次循环</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>注意：continue并没有使整个循环终止，而break会跳出循环</p></blockquote><h3 id="goto语句">goto语句</h3><p><strong>作用：</strong>可以无条件跳转语句</p><p><strong>语法：</strong> <code>goto 标记;</code></p><p><strong>解释：</strong>如果标记的名称存在，执行到goto语句时，会跳转到标记的位置</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">goto</span> FLAG;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;3&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;4&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">FLAG:</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;5&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>注意：在程序中不建议使用goto语句，以免造成程序流程混乱</p></blockquote><h1 id="数组">数组</h1><h2 id="概述">概述</h2><p>所谓数组，就是一个集合，里面存放了相同类型的数据元素</p><p><strong>特点1：</strong>数组中的每个==数据元素都是相同的数据类型==</p><p><strong>特点2：</strong>数组是由==连续的内存==位置组成的</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/1541748375356.png" /></p><h2 id="一维数组">一维数组</h2><h3 id="一维数组定义方式"><ahref="https://www.bilibili.com/video/BV1et411b73Z/?p=42&amp;share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">一维数组定义方式</a></h3><p>一维数组定义的三种方式：</p><ol type="1"><li><code>数据类型  数组名[ 数组长度 ];</code></li><li><code>数据类型  数组名[ 数组长度 ] = &#123; 值1，值2 ...&#125;;</code></li><li><code>数据类型  数组名[ ] = &#123; 值1，值2 ...&#125;;</code></li></ol><p>示例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方式1</span></span><br><span class="line"><span class="comment">//数据类型 数组名[元素个数];</span></span><br><span class="line"><span class="type">int</span> score[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用下标赋值</span></span><br><span class="line">score[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">score[<span class="number">1</span>] = <span class="number">99</span>;</span><br><span class="line">score[<span class="number">2</span>] = <span class="number">85</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用下标输出</span></span><br><span class="line">cout &lt;&lt; score[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; score[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; score[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种定义方式</span></span><br><span class="line"><span class="comment">//数据类型 数组名[元素个数] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line"><span class="comment">//如果&#123;&#125;内不足10个数据，剩余数据用0补全</span></span><br><span class="line"><span class="type">int</span> score2[<span class="number">10</span>] = &#123; <span class="number">100</span>, <span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逐个输出</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; score2[0] &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; score2[1] &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个一个输出太麻烦，因此可以利用循环进行输出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; score2[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义方式3</span></span><br><span class="line"><span class="comment">//数据类型 数组名[] =  &#123;值1，值2 ，值3 ...&#125;;</span></span><br><span class="line"><span class="type">int</span> score3[] = &#123; <span class="number">100</span>,<span class="number">90</span>,<span class="number">80</span>,<span class="number">70</span>,<span class="number">60</span>,<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; score3[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结1：数组名的命名规范与变量名命名规范一致，不要和变量重名</p></blockquote><blockquote><p>总结2：数组中下标是从0开始索引</p></blockquote><h3 id="一维数组数组名">一维数组数组名</h3><p>一维数组名称的<strong>用途</strong>：</p><ol type="1"><li>可以统计整个数组在内存中的长度</li><li>可以获取数组在内存中的首地址</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组名用途</span></span><br><span class="line"><span class="comment">//1、可以获取整个数组占用内存空间大小</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;整个数组所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;每个元素所占内存空间为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组的元素个数为： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过数组名获取到数组首地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组首地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)arr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第一个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数组中第二个元素地址为： &quot;</span> &lt;&lt; (<span class="type">int</span>)&amp;arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr = 100; 错误，数组名是常量，因此不可以赋值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>注意：数组名是常量，不可以赋值</p></blockquote><blockquote><p>总结1：直接打印数组名，可以查看数组所占内存的首地址</p></blockquote><blockquote><p>总结2：对数组名进行sizeof，可以获取整个数组占内存空间的大小</p></blockquote><p><strong>练习案例1</strong>：五只小猪称体重</p><p><strong>案例描述：</strong></p><p>在一个数组中记录了五只小猪的体重，如：int arr[5] ={300,350,200,400,250};</p><p>找出并打印最重的小猪体重。</p><p><strong>练习案例2：</strong>数组元素逆置</p><p><strong>案例描述：</strong>请声明一个5个元素的数组，并且将元素逆置.</p><p>(如原数组元素为：1,3,2,5,4;逆置后输出结果为:4,5,2,3,1);</p><h3 id="冒泡排序">冒泡排序</h3><p><strong>作用：</strong> 最常用的排序算法，对数组内元素进行排序</p><ol type="1"><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，执行完毕后，找到第一个最大值。</li><li>重复以上的步骤，每次比较次数-1，直到不需要比较</li></ol><p><imgsrc="https://picture.adunas.top/Article/20240312a/1541905327273.png" /></p><p><strong>示例：</strong> 将数组 { 4,2,8,0,5,7,1,3,9 } 进行升序排序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">4</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">9</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span> - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span> - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h2 id="二维数组">二维数组</h2><p>二维数组就是在一维数组上，多加一个维度。</p><p><imgsrc="https://picture.adunas.top/Article/20240312a/1541905559138.png" /></p><h3 id="二维数组定义方式">二维数组定义方式</h3><p>二维数组定义的四种方式：</p><ol type="1"><li><code>数据类型  数组名[ 行数 ][ 列数 ];</code></li><li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</code></li><li><code>数据类型  数组名[ 行数 ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li><li><code>数据类型  数组名[  ][ 列数 ] = &#123; 数据1，数据2，数据3，数据4&#125;;</code></li></ol><blockquote><p>建议：以上4种定义方式，利用==第二种更加直观，提高代码的可读性==</p></blockquote><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式1  </span></span><br><span class="line"><span class="comment">//数组类型 数组名 [行数][列数]</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">3</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">4</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">5</span>;</span><br><span class="line">arr[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式2 </span></span><br><span class="line"><span class="comment">//数据类型 数组名[行数][列数] = &#123; &#123;数据1，数据2 &#125; ，&#123;数据3，数据4 &#125; &#125;;</span></span><br><span class="line"><span class="type">int</span> arr2[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式3</span></span><br><span class="line"><span class="comment">//数据类型 数组名[行数][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line"><span class="type">int</span> arr3[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;; </span><br><span class="line"></span><br><span class="line"><span class="comment">//方式4 </span></span><br><span class="line"><span class="comment">//数据类型 数组名[][列数] = &#123; 数据1，数据2 ,数据3，数据4  &#125;;</span></span><br><span class="line"><span class="type">int</span> arr4[][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：在定义二维数组时，如果初始化了数据，可以省略行数</p></blockquote><h3 id="二维数组数组名">二维数组数组名</h3><ul><li>查看二维数组所占内存空间</li><li>获取二维数组首地址</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二维数组数组名</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组一行大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组元素大小： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组行数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组列数： &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(arr[<span class="number">0</span>]) / <span class="built_in">sizeof</span>(arr[<span class="number">0</span>][<span class="number">0</span>]) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组首地址：&quot;</span> &lt;&lt; arr &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第一行地址：&quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第二行地址：&quot;</span> &lt;&lt; arr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第一个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;二维数组第二个元素地址：&quot;</span> &lt;&lt; &amp;arr[<span class="number">0</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结1：二维数组名就是这个数组的首地址</p></blockquote><blockquote><p>总结2：对二维数组名进行sizeof时，可以获取整个二维数组占用的内存空间大小</p></blockquote><h3 id="二维数组应用案例"><strong>二维数组应用案例</strong></h3><p><strong>考试成绩统计：</strong></p><p>案例描述：有三名同学（张三，李四，王五），在一次考试中的成绩分别如下表，<strong>请分别输出三名同学的总成绩</strong></p><table><thead><tr class="header"><th></th><th>语文</th><th>数学</th><th>英语</th></tr></thead><tbody><tr class="odd"><td>张三</td><td>100</td><td>100</td><td>100</td></tr><tr class="even"><td>李四</td><td>90</td><td>50</td><td>100</td></tr><tr class="odd"><td>王五</td><td>60</td><td>70</td><td>80</td></tr></tbody></table><p><strong>参考答案：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> scores[<span class="number">3</span>][<span class="number">3</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="number">100</span>,<span class="number">100</span>,<span class="number">100</span>&#125;,</span><br><span class="line">&#123;<span class="number">90</span>,<span class="number">50</span>,<span class="number">100</span>&#125;,</span><br><span class="line">&#123;<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">string names[<span class="number">3</span>] = &#123; <span class="string">&quot;张三&quot;</span>,<span class="string">&quot;李四&quot;</span>,<span class="string">&quot;王五&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">sum += scores[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; names[i] &lt;&lt; <span class="string">&quot;同学总成绩为： &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h1 id="函数">函数</h1><h2 id="概述-1"><ahref="https://www.bilibili.com/video/BV1et411b73Z/?p=50&amp;share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">概述</a></h2><p><strong>作用：</strong>将一段经常使用的代码封装起来，减少重复代码</p><p>一个较大的程序，一般分为若干个程序块，每个模块实现特定的功能。</p><h2 id="函数的定义">函数的定义</h2><p>函数的定义一般主要有5个步骤：</p><p>1、返回值类型</p><p>2、函数名</p><p>3、参数表列</p><p>4、函数体语句</p><p>5、return 表达式</p><p><strong>语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 函数名 （参数列表）</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">       函数体语句</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span>表达式</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>返回值类型 ：一个函数可以返回一个值。在函数定义中</li><li>函数名：给函数起个名称</li><li>参数列表：使用该函数时，传入的数据</li><li>函数体语句：花括号内的代码，函数内需要执行的语句</li><li>return表达式： 和返回值类型挂钩，函数执行完后，返回相应的数据</li></ul><p><strong>示例：</strong>定义一个加法函数，实现两个数相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = num1 + num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的调用">函数的调用</h2><p><strong>功能：</strong>使用定义好的函数</p><p><strong>语法：</strong><code>函数名（参数）</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> <span class="comment">//定义中的num1,num2称为形式参数，简称形参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = num1 + num2;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//调用add函数</span></span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">add</span>(a, b);<span class="comment">//调用时的a，b称为实际参数，简称实参</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">b = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">sum = <span class="built_in">add</span>(a, b);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sum = &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：函数定义里小括号内称为形参，函数调用时传入的参数称为实参</p></blockquote><h2 id="值传递">值传递</h2><ul><li>所谓值传递，就是函数调用时实参将数值传入给形参</li><li>值传递时，==如果形参发生，并不会影响实参==</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> temp = num1;</span><br><span class="line">num1 = num2;</span><br><span class="line">num2 = temp;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;交换后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num1 = &quot;</span> &lt;&lt; num1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;num2 = &quot;</span> &lt;&lt; num2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//return ; 当函数声明时候，不需要返回值，可以不写return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mian中的 a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mian中的 b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结： 值传递时，形参是修饰不了实参的</p></blockquote><h2 id="函数的常见样式"><strong>函数的常见样式</strong></h2><p>常见的函数样式有4种</p><ol type="1"><li>无参无返</li><li>有参无返</li><li>无参有返</li><li>有参有返</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数常见样式</span></span><br><span class="line"><span class="comment">//1、 无参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//void a = 10; //无类型不可以创建变量,原因无法分配内存</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is test01&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="comment">//test01(); 函数调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、 有参无返</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">(<span class="type">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is test02&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、无参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is test03 &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、有参有返</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">test04</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this is test04 &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span> sum = a + b;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数的声明">函数的声明</h2><p><strong>作用：</strong>告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。</p><ul><li>函数的<strong>声明可以多次</strong>，但是函数的<strong>定义只能有一次</strong></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明可以多次，定义只能一次</span></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="built_in">max</span>(a, b) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h2 id="函数的分文件编写">函数的分文件编写</h2><p><strong>作用：</strong>让代码结构更加清晰</p><p>函数分文件编写一般有4个步骤</p><ol type="1"><li>创建后缀名为.h的头文件<br /></li><li>创建后缀名为.cpp的源文件</li><li>在头文件中写函数的声明</li><li>在源文件中写函数的定义</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现两个数字交换的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//swap.cpp文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main函数文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;swap.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h1 id="指针">指针</h1><h2 id="指针的基本概念"><ahref="https://www.bilibili.com/video/BV1et411b73Z/?p=56&amp;share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">指针的基本概念</a></h2><p><strong>指针的作用：</strong> 可以通过指针间接访问内存</p><ul><li><p>内存编号是从0开始记录的，一般用十六进制数字表示</p></li><li><p>可以利用指针变量保存地址</p><p>​</p></li></ul><h2 id="指针变量的定义和使用">指针变量的定义和使用</h2><p>指针变量定义语法： <code>数据类型 * 变量名；</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指针的定义</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">//定义整型变量a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//指针定义语法： 数据类型 * 变量名 ;</span></span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量赋值</span></span><br><span class="line">p = &amp;a; <span class="comment">//指针指向变量a的地址</span></span><br><span class="line">cout &lt;&lt; &amp;a &lt;&lt; endl; <span class="comment">//打印数据a的地址</span></span><br><span class="line">cout &lt;&lt; p &lt;&lt; endl;  <span class="comment">//打印指针变量p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、指针的使用</span></span><br><span class="line"><span class="comment">//通过*操作指针变量指向的内存</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;*p = &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p>指针变量和普通变量的区别</p><ul><li>普通变量存放的是数据,指针变量存放的是地址</li><li>指针变量可以通过" *"操作符，操作指针变量指向的内存空间，这个过程称为解引用</li></ul><blockquote><p>总结1： 我们可以通过 &amp; 符号 获取变量的地址</p></blockquote><blockquote><p>总结2：利用指针可以记录地址</p></blockquote><blockquote><p>总结3：对指针变量解引用，可以操作指针指向的内存</p></blockquote><h2 id="指针所占内存空间">指针所占内存空间</h2><p>提问：指针也是种数据类型，那么这种数据类型占用多少内存空间？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * p;</span><br><span class="line">p = &amp;a; <span class="comment">//指针指向数据a的地址</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl; <span class="comment">//* 解引用</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span> *) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span> *) &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：所有指针类型在32位操作系统下是4个字节</p></blockquote><h2 id="空指针和野指针">空指针和野指针</h2><p><strong>空指针</strong>：指针变量指向内存中编号为0的空间</p><p><strong>用途：</strong>初始化指针变量</p><p><strong>注意：</strong>空指针指向的内存是不可以访问的</p><p><strong>示例1：空指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量p指向内存地址编号为0的空间</span></span><br><span class="line"><span class="type">int</span> * p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问空指针报错 </span></span><br><span class="line"><span class="comment">//内存编号0 ~255为系统占用内存，不允许用户访问</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p><strong>野指针</strong>：指针变量指向非法的内存空间</p><p><strong>示例2：野指针</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指针变量p指向内存地址编号为0x1100的空间</span></span><br><span class="line"><span class="type">int</span> * p = (<span class="type">int</span> *)<span class="number">0x1100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//访问野指针报错 </span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：空指针和野指针都不是我们申请的空间，因此不要访问。</p></blockquote><h2 id="const修饰指针">const修饰指针</h2><p>const修饰指针有三种情况</p><ol type="1"><li>const修饰指针 --- 常量指针</li><li>const修饰常量 --- 指针常量</li><li>const即修饰指针，又修饰常量</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰的是指针，指针指向可以改，指针指向的值不可以更改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * p1 = &amp;a; </span><br><span class="line">p1 = &amp;b; <span class="comment">//正确</span></span><br><span class="line"><span class="comment">//*p1 = 100;  报错</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//const修饰的是常量，指针指向不可以改，指针指向的值可以更改</span></span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p2 = &amp;a;</span><br><span class="line"><span class="comment">//p2 = &amp;b; //错误</span></span><br><span class="line">*p2 = <span class="number">100</span>; <span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//const既修饰指针又修饰常量</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> * <span class="type">const</span> p3 = &amp;a;</span><br><span class="line"><span class="comment">//p3 = &amp;b; //错误</span></span><br><span class="line"><span class="comment">//*p3 = 100; //错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>技巧：看const右侧紧跟着的是指针还是常量,是指针就是常量指针，是常量就是指针常量</p></blockquote><h2 id="指针和数组">指针和数组</h2><p><strong>作用：</strong>利用指针访问数组中元素</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> * p = arr;  <span class="comment">//指向数组的指针</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第一个元素： &quot;</span> &lt;&lt; arr[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;指针访问第一个元素： &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//利用指针遍历数组</span></span><br><span class="line">cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">p++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h2 id="指针和函数">指针和函数</h2><p><strong>作用：</strong>利用指针作函数参数，可以修改实参的值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = a;</span><br><span class="line">a = b; </span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span> * p1, <span class="type">int</span> *p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> temp = *p1;</span><br><span class="line">*p1 = *p2;</span><br><span class="line">*p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">swap1</span>(a, b); <span class="comment">// 值传递不会改变实参</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">swap2</span>(&amp;a, &amp;b); <span class="comment">//地址传递会改变实参</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：如果不想修改实参，就用值传递，如果想修改实参，就用地址传递</p></blockquote><h2 id="指针数组函数">指针、数组、函数</h2><p><strong>案例描述：</strong>封装一个函数，利用冒泡排序，实现对整型数组的升序排序</p><p>例如数组：int arr[10] = { 4,3,6,9,1,2,10,8,7,5 };</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> * arr, <span class="type">int</span> len)</span>  <span class="comment">//int * arr 也可以写为int arr[]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArray</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">4</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">10</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">bubbleSort</span>(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printArray</span>(arr, len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：当数组名传入到函数作为参数时，被退化为指向首元素的指针</p></blockquote><h1 id="结构体">结构体</h1><h2 id="结构体基本概念">结构体基本概念</h2><p>结构体属于用户==自定义的数据类型==，允许用户存储不同的数据类型</p><h2 id="结构体定义和使用"><ahref="https://www.bilibili.com/video/BV1et411b73Z/?p=64&amp;share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">结构体定义和使用</a></h2><p><strong>语法：</strong><code>struct 结构体名 &#123; 结构体成员列表 &#125;；</code></p><p>通过结构体创建变量的方式有三种：</p><ul><li>struct 结构体名 变量名</li><li>struct 结构体名 变量名 = { 成员1值 ， 成员2值...}</li><li>定义结构体时顺便创建变量</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;stu3; <span class="comment">//结构体变量创建方式3 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体变量创建方式1</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu1; <span class="comment">//struct 关键字可以省略</span></span><br><span class="line"></span><br><span class="line">stu1.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">stu1.age = <span class="number">18</span>;</span><br><span class="line">stu1.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu1.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu1.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu1.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体变量创建方式2</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu2 = &#123; <span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu2.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu2.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu2.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">stu3.name = <span class="string">&quot;王五&quot;</span>;</span><br><span class="line">stu3.age = <span class="number">18</span>;</span><br><span class="line">stu3.score = <span class="number">80</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu3.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu3.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu3.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结1：定义结构体时的关键字是struct，不可省略</p></blockquote><blockquote><p>总结2：创建结构体变量时，关键字struct可以省略</p></blockquote><blockquote><p>总结3：结构体变量利用操作符 ''.'' 访问成员</p></blockquote><h2 id="结构体数组">结构体数组</h2><p><strong>作用：</strong>将自定义的结构体放入到数组中方便维护</p><p><strong>语法：</strong><code>struct  结构体名 数组名[元素个数] = &#123;  &#123;&#125; , &#123;&#125; , ... &#123;&#125; &#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结构体数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> arr[<span class="number">3</span>]=</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">80</span> &#125;,</span><br><span class="line">&#123;<span class="string">&quot;李四&quot;</span>,<span class="number">19</span>,<span class="number">60</span> &#125;,</span><br><span class="line">&#123;<span class="string">&quot;王五&quot;</span>,<span class="number">20</span>,<span class="number">70</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; arr[i].age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; arr[i].score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h2 id="结构体指针">结构体指针</h2><p><strong>作用：</strong>通过指针访问结构体中的成员</p><ul><li>利用操作符 <code>-&gt;</code>可以通过结构体指针访问结构体属性</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>, &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> * p = &amp;stu;</span><br><span class="line"></span><br><span class="line">p-&gt;score = <span class="number">80</span>; <span class="comment">//指针通过 -&gt; 操作符可以访问成员</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; p-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; p-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：结构体指针可以通过 -&gt; 操作符 来访问结构体中的成员</p></blockquote><h2 id="结构体嵌套结构体">结构体嵌套结构体</h2><p><strong>作用：</strong> 结构体中的成员可以是另一个结构体</p><p><strong>例如：</strong>每个老师辅导一个学员，一个老师的结构体中，记录一个学生的结构体</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//成员列表</span></span><br><span class="line"><span class="type">int</span> id; <span class="comment">//职工编号</span></span><br><span class="line">string name;  <span class="comment">//教师姓名</span></span><br><span class="line"><span class="type">int</span> age;   <span class="comment">//教师年龄</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> stu; <span class="comment">//子结构体 学生</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">teacher</span> t1;</span><br><span class="line">t1.id = <span class="number">10000</span>;</span><br><span class="line">t1.name = <span class="string">&quot;老王&quot;</span>;</span><br><span class="line">t1.age = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">t1.stu.name = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">t1.stu.age = <span class="number">18</span>;</span><br><span class="line">t1.stu.score = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;教师 职工编号： &quot;</span> &lt;&lt; t1.id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t1.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; t1.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;辅导学员 姓名： &quot;</span> &lt;&lt; t1.stu.name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; t1.stu.age &lt;&lt; <span class="string">&quot; 考试分数： &quot;</span> &lt;&lt; t1.stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><p><strong>总结：</strong>在结构体中可以定义另一个结构体作为成员，用来解决实际问题</p><h2 id="结构体做函数参数">结构体做函数参数</h2><p><strong>作用：</strong>将结构体作为参数向函数中传递</p><p>传递方式有两种：</p><ul><li>值传递</li><li>地址传递</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(student stu )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu.age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent2</span><span class="params">(student *stu)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stu-&gt;age = <span class="number">28</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子函数中 姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu-&gt;age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span>&#125;;</span><br><span class="line"><span class="comment">//值传递</span></span><br><span class="line"><span class="built_in">printStudent</span>(stu);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//地址传递</span></span><br><span class="line"><span class="built_in">printStudent2</span>(&amp;stu);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主函数中 姓名：&quot;</span> &lt;&lt; stu.name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; stu.age  &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu.score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><blockquote><p>总结：如果不想修改主函数中的数据，用值传递，反之用地址传递</p></blockquote><h2 id="结构体中-const使用场景">结构体中 const使用场景</h2><p><strong>作用：</strong>用const来防止误操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生结构体定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//成员列表</span></span><br><span class="line">string name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="type">int</span> age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="type">int</span> score;    <span class="comment">//分数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//const使用场景</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStudent</span><span class="params">(<span class="type">const</span> student *stu)</span> <span class="comment">//加const防止函数体中的误操作</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//stu-&gt;age = 100; //操作失败，因为加了const修饰</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; stu-&gt;name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; stu-&gt;age &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; stu-&gt;score &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">student stu = &#123; <span class="string">&quot;张三&quot;</span>,<span class="number">18</span>,<span class="number">100</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printStudent</span>(&amp;stu);</span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h2 id="结构体案例">结构体案例</h2><h3 id="案例1">案例1</h3><p><strong>案例描述：</strong></p><p>学校正在做毕设项目，每名老师带领5个学生，总共有3名老师，需求如下</p><p>设计学生和老师的结构体，其中在老师的结构体中，有老师姓名和一个存放5名学生的数组作为成员</p><p>学生的成员有姓名、考试分数，创建数组存放3名老师，通过函数给每个老师及所带的学生赋值</p><p>最终打印出老师数据以及老师所带的学生数据。</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Teacher</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line">Student sArray[<span class="number">5</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">allocateSpace</span><span class="params">(Teacher tArray[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string tName = <span class="string">&quot;教师&quot;</span>;</span><br><span class="line">string sName = <span class="string">&quot;学生&quot;</span>;</span><br><span class="line">string nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">tArray[i].name = tName + nameSeed[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">tArray[i].sArray[j].name = sName + nameSeed[j];</span><br><span class="line">tArray[i].sArray[j].score = <span class="built_in">rand</span>() % <span class="number">61</span> + <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printTeachers</span><span class="params">(Teacher tArray[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; tArray[i].name &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\t姓名：&quot;</span> &lt;&lt; tArray[i].sArray[j].name &lt;&lt; <span class="string">&quot; 分数：&quot;</span> &lt;&lt; tArray[i].sArray[j].score &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span> <span class="type">int</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>)); <span class="comment">//随机数种子 头文件 #include &lt;ctime&gt;</span></span><br><span class="line"></span><br><span class="line">Teacher tArray[<span class="number">3</span>]; <span class="comment">//老师数组</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(tArray) / <span class="built_in">sizeof</span>(Teacher);</span><br><span class="line"></span><br><span class="line"><span class="built_in">allocateSpace</span>(tArray, len); <span class="comment">//创建数据</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printTeachers</span>(tArray, len); <span class="comment">//打印数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p><h3 id="案例2">案例2</h3><p><strong>案例描述：</strong></p><p>设计一个英雄的结构体，包括成员姓名，年龄，性别;创建结构体数组，数组中存放5名英雄。</p><p>通过冒泡排序的算法，将数组中的英雄按照年龄进行升序排序，最终打印排序后的结果。</p><p>五名英雄信息如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//英雄结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">string sex;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(hero arr[] , <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j].age &gt; arr[j + <span class="number">1</span>].age)</span><br><span class="line">&#123;</span><br><span class="line">hero temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printHeros</span><span class="params">(hero arr[], <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; arr[i].name &lt;&lt; <span class="string">&quot; 性别： &quot;</span> &lt;&lt; arr[i].sex &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; arr[i].age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">hero</span> arr[<span class="number">5</span>] =</span><br><span class="line">&#123;</span><br><span class="line">&#123;<span class="string">&quot;刘备&quot;</span>,<span class="number">23</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;关羽&quot;</span>,<span class="number">22</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;张飞&quot;</span>,<span class="number">20</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;赵云&quot;</span>,<span class="number">21</span>,<span class="string">&quot;男&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="string">&quot;貂蝉&quot;</span>,<span class="number">19</span>,<span class="string">&quot;女&quot;</span>&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(hero); <span class="comment">//获取数组元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">bubbleSort</span>(arr, len); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printHeros</span>(arr, len); <span class="comment">//打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//system(&quot;pause&quot;);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><ahref="https://tool.lu/coderunner/embed/eCP.html">点击测试代码</a></p>]]></content>
    
    
    <summary type="html">🍖本文是黑马程序员教程-C++基础入门篇</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++" scheme="https://www.adunas.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Pandoc</title>
    <link href="https://www.adunas.top/posts/20240304b.html"/>
    <id>https://www.adunas.top/posts/20240304b.html</id>
    <published>2024-03-04T02:09:14.000Z</published>
    <updated>2024-03-04T02:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程导航"><a href="./20240221b.html#Pandoc">编程导航</a></h1><p>  Pandoc 是一个开源的文本转换工具。</p>]]></content>
    
    
    <summary type="html">🥯本文为 Pandoc 的使用教程</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Pandoc" scheme="https://www.adunas.top/tags/Pandoc/"/>
    
  </entry>
  
  <entry>
    <title>离骚（节选）</title>
    <link href="https://www.adunas.top/posts/20240304a.html"/>
    <id>https://www.adunas.top/posts/20240304a.html</id>
    <published>2024-03-04T00:55:25.000Z</published>
    <updated>2024-03-04T00:55:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读导航"><ahref="./20240224b.html#离骚（节选）">阅读导航</a></h1><div class='poem'><div class='poem-title'>离骚（节选）</div><div class='poem-author'>屈原</div><p>长太息以掩涕兮，哀民生之多艰。余虽好修姱以鞿羁兮，謇朝谇而夕替。</p><p>既替余以蕙纕兮，又申之以揽茝。亦余心之所善兮，虽九死其犹未悔。</p><p>怨灵修之浩荡兮，终不察夫民心。众女嫉余之蛾眉兮，谣诼谓余以善淫。</p><p>固时俗之工巧兮，偭规矩而改错。背绳墨以追曲兮，竞周容以为度。</p><p>忳郁邑余侘傺兮，吾独穷困乎此时也。宁溘死以流亡兮，余不忍为此态也。</p><p>鸷鸟之不群兮，自前世而固然。何方圜之能周兮，夫孰异道而相安？</p><p>屈心而抑志兮，忍尤而攘诟。伏清白以死直兮，固前圣之所厚。</p><p>悔相道之不察兮，延伫乎吾将反。回朕车以复路兮，及行迷之未远。</p><p>步余马于兰皋兮，驰椒丘且焉止息。进不入以离尤兮，退将复修吾初服。</p><p>制芰荷以为衣兮，集芙蓉以为裳。不吾知其亦已兮，苟余情其信芳。</p><p>高余冠之岌岌兮，长余佩之陆离。芳与泽其杂糅兮，唯昭质其犹未亏。</p><p>忽反顾以游目兮，将往观乎四荒。佩缤纷其繁饰兮，芳菲菲其弥章。</p><p>民生各有所乐兮，余独好修以为常。虽体解吾犹未变兮，岂余心之可惩。</p></div><p>情感过头：</p><div class="audio"><audio controls preload><source src='https://picture.adunas.top/Audio/Read/LiSaoAdunasA.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><p>朗读勘误：背绳墨以追曲兮，其中 “曲” 为二声，和直相对。</p><p>情感不足，改正读音错误，补全最后一句：</p><div class="audio"><audio controls preload><source src='https://picture.adunas.top/Audio/Read/LiSaoAdunasB.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div>]]></content>
    
    
    <summary type="html">🥨本文为高中所学离骚（节选）的内容</summary>
    
    
    
    <category term="阅读" scheme="https://www.adunas.top/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="阅读方法" scheme="https://www.adunas.top/tags/%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Latex</title>
    <link href="https://www.adunas.top/posts/20240225c.html"/>
    <id>https://www.adunas.top/posts/20240225c.html</id>
    <published>2024-02-25T03:38:02.000Z</published>
    <updated>2024-03-04T02:09:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编程导航"><a href="./20240221b.html#Latex">编程导航</a></h1><p>  易用难精。<ahref="https://youtu.be/HPSK7q13-40?si=-mt3QWOA63NQ4pvm">How to Convert aWord Document to Markdown for Free using Pandoc</a></p><h3 id="希腊字母">希腊字母</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">α A <span class="keyword">\alpha</span> A <span class="keyword">\\</span></span><br><span class="line">β B <span class="keyword">\beta</span> B <span class="keyword">\\</span></span><br><span class="line">γ Γ <span class="keyword">\gamma</span> <span class="keyword">\Gamma</span> <span class="keyword">\\</span></span><br><span class="line">δ Δ <span class="keyword">\delta</span> <span class="keyword">\Delta</span> <span class="keyword">\\</span></span><br><span class="line">ϵ ε E <span class="keyword">\epsilon</span> <span class="keyword">\varepsilon</span> E <span class="keyword">\\</span></span><br><span class="line">ζ Z <span class="keyword">\zeta</span> Z <span class="keyword">\\</span></span><br><span class="line">η H <span class="keyword">\eta</span> H <span class="keyword">\\</span></span><br><span class="line">θ ϑ Θ <span class="keyword">\theta</span> <span class="keyword">\vartheta</span> <span class="keyword">\Theta</span> <span class="keyword">\\</span></span><br><span class="line">ι I <span class="keyword">\iota</span> I <span class="keyword">\\</span></span><br><span class="line">κ K <span class="keyword">\kappa</span> K <span class="keyword">\\</span></span><br><span class="line">λ Λ <span class="keyword">\lambda</span> <span class="keyword">\Lambda</span> <span class="keyword">\\</span></span><br><span class="line">μ M <span class="keyword">\mu</span> M <span class="keyword">\\</span></span><br><span class="line">ν V <span class="keyword">\nu</span> V <span class="keyword">\\</span></span><br><span class="line">ξ Ξ <span class="keyword">\xi</span> <span class="keyword">\Xi</span> <span class="keyword">\\</span></span><br><span class="line">ο O o O <span class="keyword">\\</span></span><br><span class="line">π Π <span class="keyword">\pi</span> <span class="keyword">\Pi</span> <span class="keyword">\\</span></span><br><span class="line">ρ ϱ P <span class="keyword">\rho</span> <span class="keyword">\varrho</span> P <span class="keyword">\\</span></span><br><span class="line">σ Σ <span class="keyword">\sigma</span> <span class="keyword">\Sigma</span> <span class="keyword">\\</span></span><br><span class="line">τ T <span class="keyword">\tau</span> T <span class="keyword">\\</span></span><br><span class="line">υ Υ <span class="keyword">\upsilon</span> <span class="keyword">\Upsilon</span> <span class="keyword">\\</span></span><br><span class="line">ϕ φ Φ <span class="keyword">\phi</span> <span class="keyword">\varphi</span> <span class="keyword">\Phi</span> <span class="keyword">\\</span></span><br><span class="line">χ X <span class="keyword">\chi</span> X <span class="keyword">\\</span></span><br><span class="line">ψ Ψ <span class="keyword">\psi</span> <span class="keyword">\Psi</span> <span class="keyword">\\</span></span><br><span class="line">ω Ω <span class="keyword">\omega</span> <span class="keyword">\Omega</span> <span class="keyword">\\</span></span><br></pre></td></tr></table></figure><h3 id="不等于">不等于</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\neq</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\neq\]</span></p><h3 id="大于等于">大于等于</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\geq</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\geq\]</span></p><h3 id="小于等于">小于等于</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\leq</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\leq\]</span></p><h3 id="点乘">点乘</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\cdot</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\cdot\]</span></p><h3 id="叉乘">叉乘</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\times</span></span><br></pre></td></tr></table></figure><p><span class="math display">\[\times\]</span></p><h3 id="分式">分式</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\frac</span>&#123;a&#125;&#123;b&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\frac{a}{b}\]</span></p><h3 id="加粗">加粗</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\mathbf</span>&#123;dT(P)&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\mathbf{dT(P)}\]</span></p><h3 id="单括号">单括号</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\left</span><span class="keyword">\&#123;</span></span><br><span class="line"><span class="keyword">\right</span>.</span><br></pre></td></tr></table></figure><p><span class="math display">\[\left\{\right.\]</span></p><p>一般情况下，括号是成对使用的，用一半的话需要手动取消。其中<code>\right.</code>就是手动取消的表达式。</p><h3 id="矢量">矢量</h3><p>  向右箭头，这个不标准。</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\overrightarrow</span>&#123;a&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\overrightarrow{a}\]</span></p><p>矢量，正确的表达：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\vec</span>&#123;a&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[\vec{a}\]</span></p><h3 id="对齐">对齐</h3><ol type="1"><li>左对齐</li><li>右对齐</li><li>等号处对齐 align，在 &amp; 处对齐</li></ol><h3 id="上下标">上下标</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\mathop</span>&#123;<span class="keyword">\sum</span>&#125;<span class="built_in">_</span>&#123;a=<span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125; <span class="keyword">\times</span> 10&#125;<span class="built_in">^</span>&#123;b=<span class="keyword">\frac</span>&#123;4&#125;&#123;5&#125;&#125;c <span class="keyword">\cdot</span> d</span><br></pre></td></tr></table></figure><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\mathop</span>&#123;<span class="keyword">\sum</span>&#125;<span class="keyword">\limits</span><span class="built_in">_</span>&#123;a=<span class="keyword">\frac</span>&#123;1&#125;&#123;2&#125; <span class="keyword">\times</span> 10&#125;<span class="built_in">^</span>&#123;b=<span class="keyword">\frac</span>&#123;4&#125;&#123;5&#125;&#125;c <span class="keyword">\cdot</span> d</span><br></pre></td></tr></table></figure><p><span class="math display">\[\mathop{\sum}_{a=\frac{1}{2} \times 10}^{b=\frac{4}{5}}c \cdot d\]</span></p><p><span class="math display">\[\mathop{\sum}\limits_{a=\frac{1}{2} \times 10}^{b=\frac{4}{5}}c \cdot d\]</span></p><h3 id="省略号">省略号</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Y=<span class="keyword">\&#123;</span>y<span class="built_in">_</span>1, y<span class="built_in">_</span>2, <span class="keyword">\ldots</span>, y<span class="built_in">_</span>n<span class="keyword">\&#125;</span>,</span><br><span class="line"><span class="keyword">\begin</span>&#123;bmatrix&#125;</span><br><span class="line">    x<span class="built_in">_</span>&#123;11&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;12&#125;  <span class="built_in">&amp;</span> <span class="keyword">\cdots</span>   <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;1m&#125;   <span class="keyword">\\</span></span><br><span class="line">    x<span class="built_in">_</span>&#123;21&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;22&#125;  <span class="built_in">&amp;</span> <span class="keyword">\cdots</span>   <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;2m&#125;  <span class="keyword">\\</span></span><br><span class="line">    <span class="keyword">\vdots</span> <span class="built_in">&amp;</span> <span class="keyword">\vdots</span>  <span class="built_in">&amp;</span> <span class="keyword">\ddots</span>   <span class="built_in">&amp;</span> <span class="keyword">\vdots</span>  <span class="keyword">\\</span></span><br><span class="line">    x<span class="built_in">_</span>&#123;n1&#125; <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;n2&#125;  <span class="built_in">&amp;</span> <span class="keyword">\cdots</span><span class="keyword">\ </span> <span class="built_in">&amp;</span> x<span class="built_in">_</span>&#123;nm&#125;  <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\end</span>&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure><p><span class="math display">\[Y=\{y_1, y_2, \ldots, y_n\},\begin{bmatrix}    x_{11} &amp; x_{12}  &amp; \cdots   &amp; x_{1m}   \\    x_{21} &amp; x_{22}  &amp; \cdots   &amp; x_{2m}  \\    \vdots &amp; \vdots  &amp; \ddots   &amp; \vdots  \\    x_{n1} &amp; x_{n2}  &amp; \cdots\  &amp; x_{nm}  \\\end{bmatrix}\]</span></p>]]></content>
    
    
    <summary type="html">🍙本文记录Latex语法</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Latex" scheme="https://www.adunas.top/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://www.adunas.top/posts/20240225a.html"/>
    <id>https://www.adunas.top/posts/20240225a.html</id>
    <published>2024-02-25T01:43:26.000Z</published>
    <updated>2024-03-12T06:31:42.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol type="1"><li>源文件链接：<ahref="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md">learn-regex</a></li><li>视频参考：<ahref="https://www.bilibili.com/video/BV1da4y1p7iZ/?share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">【10分钟快速掌握正则表达式】</a></li></ol></div><h1 id="编程导航"><ahref="./20240221b.html#正则表达式">编程导航</a></h1><h1 id="实战例子">实战例子</h1><p>  删除编号：<code>#\s[0-9](\s|\.([0-9](\s|\.[0-9]\s)))</code></p><pre>"#\s[0-9](\s|\.([0-9](\s|\.[0-9]\s)))" => <a href="#learn-regex"><strong># 1 </strong></a>基本匹配=> #<a href="#learn-regex"><strong># 2.1 </strong></a>点运算符 `.`=> ##<a href="#learn-regex"><strong># 2.2.1 </strong></a>否定字符集</pre><p>变式：<code>#\s[0-9].(\s|([0-9](\s|\.[0-9]\s)))</code>，不规范的编号格式示例。</p><pre>"#\s[0-9].(\s|([0-9](\s|\.[0-9]\s)))" => <a href="#learn-regex"><strong># 1. </strong></a>基本匹配=> #<a href="#learn-regex"><strong># 2.1 </strong></a>点运算符 `.`=> ##<a href="#learn-regex"><strong># 2.2.1 </strong></a>否定字符集</pre><h1 id="什么是正则表达式">什么是正则表达式？</h1><p><a href="https://gum.co/learn-regex"><imgsrc="https://img.shields.io/badge/-Download%20PDF%20-0a0a0a.svg?style=flat&amp;colorA=0a0a0a" /></a></p><blockquote><p>正则表达式是一组由字母和符号组成的特殊文本，它可以用来从文本中找出满足你想要的格式的句子。</p></blockquote><p>  一个正则表达式是一种从左到右匹配主体字符串的模式。 “Regularexpression” 这个词比较拗口，我们常使用缩写的术语“regex”或“regexp”。正则表达式可以从一个基础字符串中根据一定的匹配模式替换文本中的字符串、验证表单、提取字符串等等。</p><p>  想象你正在写一个应用，然后你想设定一个用户命名的规则，让用户名包含字符、数字、下划线和连字符，以及限制字符的个数，好让名字看起来没那么丑。我们使用以下正则表达式来验证一个用户名：</p><p><br/><br/></p><p align="center"><img src="https://picture.adunas.top/Article/20240225a/regexp-cn.png" alt="Regular expression"></p><p>以上的正则表达式可以接受<code>john_doe</code>、<code>jo-hn_doe</code>、<code>john12_as</code>。但不匹配<code>Jo</code>，因为它包含了大写的字母而且太短了。</p><h1 id="基本匹配">基本匹配</h1><p>  正则表达式其实就是在执行搜索时的格式，它由一些字母和数字组合而成。例如：一个正则表达式<code>the</code>，它表示一个规则：由字母<code>t</code>开始，接着是<code>h</code>，再接着是<code>e</code>。</p><pre>"the" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/dmRygT/1">在线练习</a></p><p>正则表达式<code>123</code>匹配字符串<code>123</code>。它逐个字符的与输入的正则表达式做比较。</p><p>正则表达式是大小写敏感的，所以<code>The</code>不会匹配<code>the</code>。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/1paXsy/1">在线练习</a></p><h1 id="元字符">元字符</h1><p>  正则表达式主要依赖于元字符。元字符不代表他们本身的字面意思，他们都有特殊的含义。一些元字符写在方括号中的时候有一些特殊的意思。以下是一些元字符的介绍：</p><table><colgroup><col style="width: 60%" /><col style="width: 40%" /></colgroup><thead><tr class="header"><th style="text-align: center;">元字符</th><th>描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr class="even"><td style="text-align: center;">[ ]</td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr class="odd"><td style="text-align: center;">[^ ]</td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr class="even"><td style="text-align: center;">*</td><td>匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr class="odd"><td style="text-align: center;">+</td><td>匹配&gt;=1个重复的+号前的字符。</td></tr><tr class="even"><td style="text-align: center;">?</td><td>标记?之前的字符为可选.</td></tr><tr class="odd"><td style="text-align: center;">{n,m}</td><td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td></tr><tr class="even"><td style="text-align: center;">(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr class="odd"><td style="text-align: center;">|</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr class="even"><td style="text-align: center;">\</td><td>转义字符,用于匹配一些保留的字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ |</code></td></tr><tr class="odd"><td style="text-align: center;">^</td><td>从开始行开始匹配.</td></tr><tr class="even"><td style="text-align: center;">$</td><td>从末端开始匹配.</td></tr></tbody></table><h1 id="点运算符-.">点运算符 <code>.</code></h1><p>  <code>.</code>是元字符中最简单的例子。<code>.</code>匹配任意单个字符，但不匹配换行符。例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p><pre>".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/xc9GkU/1">在线练习</a></p><h1 id="字符集">字符集</h1><p>  字符集也叫做字符类。 方括号用来指定一个字符集。在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和<code>The</code>。</p><pre>"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/2ITLQ4/1">在线练习</a></p><p>方括号的句号就表示句号。 表达式 <code>ar[.]</code> 匹配<code>ar.</code>字符串</p><pre>"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a></pre><p><a href="https://regex101.com/r/wL3xtE/1">在线练习</a></p><h2 id="否定字符集">否定字符集</h2><p>  一般来说 <code>^</code>表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。例如，表达式<code>[^c]ar</code>匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p><pre>"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/nNNlq3/1">在线练习</a></p><h1 id="重复次数">重复次数</h1><p>  后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code>的，用来指定匹配子模式的次数。这些元字符在不同的情况下有着不同的意思。</p><h2 id="号"><code>*</code> 号</h2><p>  <code>*</code>号匹配在<code>*</code>之前的字符出现<code>大于等于0</code>次。 例如，表达式<code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code>匹配一个行中所有以小写字母开头的字符串。</p><pre>"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.</pre><p><a href="https://regex101.com/r/7m8me5/1">在线练习</a></p><p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。<code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><pre>"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the con<a href="#learn-regex"><strong>cat</strong></a>enation.</pre><p><a href="https://regex101.com/r/gGrwuz/1">在线练习</a></p><h2 id="号-1"><code>+</code> 号</h2><p>  <code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。例如表达式<code>c.+t</code>匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p><pre>"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.</pre><p><a href="https://regex101.com/r/Dzf9Aa/1">在线练习</a></p><h2 id="号-2"><code>?</code> 号</h2><p>  在正则表达式中元字符 <code>?</code>标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式<code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p><pre>"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><p><a href="https://regex101.com/r/cIg9zm/1">在线练习</a></p><pre>"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.</pre><p><a href="https://regex101.com/r/kPpO2x/1">在线练习</a></p><h1 id="号-3"><code>&#123;&#125;</code> 号</h1><p>  在正则表达式中 <code>&#123;&#125;</code>是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式<code>[0-9]&#123;2,3&#125;</code> 匹配最少 2 位最多 3 位 的数字。</p><pre>"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p><a href="https://regex101.com/r/juM86s/1">在线练习</a></p><p>我们可以省略第二个参数。 例如，<code>[0-9]&#123;2,&#125;</code> 匹配至少两位的数字。</p><pre>"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p><a href="https://regex101.com/r/Gdy4w5/1">在线练习</a></p><p>如果逗号也省略掉则表示重复固定的次数。 例如，<code>[0-9]&#123;3&#125;</code>匹配3位数字</p><pre>"[0-9]{3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to 10.0.</pre><p><a href="https://regex101.com/r/Sivu30/1">在线练习</a></p><h1 id="特征标群"><code>(...)</code> 特征标群</h1><p>  特征标群是一组写在 <code>(...)</code>中的子模式。<code>(...)</code>中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如,表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个<code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式<code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code>。再比如之前说的 <code>&#123;&#125;</code>是用来表示前面一个字符出现指定次数。但如果在 <code>&#123;&#125;</code>前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code>表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或<code>gar</code> 或 <code>par</code>.</p><pre>"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><p><a href="https://regex101.com/r/tUxrBG/1">在线练习</a></p><h1 id="或运算符"><code>|</code> 或运算符</h1><p>  或运算符就表示或，用作判断条件。</p><p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或<code>car</code>。</p><pre>"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/fBXyX0/1">在线练习</a></p><h1 id="转码特殊字符">转码特殊字符</h1><p>  反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定<code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code>这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线<code>\</code>。</p><p>例如 <code>.</code>是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code>则要写成 <code>\.</code> 以下这个例子<code>\.?</code>是选择性匹配<code>.</code></p><pre>"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/DOc5Nu/1">在线练习</a></p><h1 id="锚点">锚点</h1><p>  在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code>指定开头，<code>$</code> 指定结尾。</p><h2 id="号-4"><code>^</code> 号</h2><p>  <code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果<code>a</code>。但如果使用 <code>^b</code>将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以<code>b</code> 开头。</p><p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或<code>the</code> 开头的字符串。</p><pre>"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p><a href="https://regex101.com/r/5ljjgB/1">在线练习</a></p><pre>"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><p><a href="https://regex101.com/r/jXrKne/1">在线练习</a></p><h2 id="号-5"><code>$</code> 号</h2><p>  同理于 <code>^</code> 号，<code>$</code>号用来匹配字符是否是最后一个。</p><p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p><pre>"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a></pre><p><a href="https://regex101.com/r/y4Au4D/1">在线练习</a></p><pre>"(at\.)$" => The fat cat. sat. on the m<a href="#learn-regex"><strong>at.</strong></a></pre><p><a href="https://regex101.com/r/t0AkOd/1">在线练习</a></p><h1 id="简写字符集">简写字符集</h1><p>  正则表达式提供一些常用的字符集简写。如下:</p><table><thead><tr class="header"><th style="text-align: center;">简写</th><th>描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">.</td><td>除换行符外的所有字符</td></tr><tr class="even"><td style="text-align: center;"></td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr class="odd"><td style="text-align: center;"></td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr class="even"><td style="text-align: center;">匹配数字： <code>[0-9]</code></td><td></td></tr><tr class="odd"><td style="text-align: center;"></td><td>匹配非数字： <code>[^\d]</code></td></tr><tr class="even"><td style="text-align: center;"></td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr class="odd"><td style="text-align: center;"></td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr class="even"><td style="text-align: center;">匹配一个换页符</td><td></td></tr><tr class="odd"><td style="text-align: center;"></td><td>匹配一个换行符</td></tr><tr class="even"><td style="text-align: center;">匹配一个回车符</td><td></td></tr><tr class="odd"><td style="text-align: center;">匹配一个制表符</td><td></td></tr><tr class="even"><td style="text-align: center;">匹配一个垂直制表符</td><td></td></tr><tr class="odd"><td style="text-align: center;"></td><td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><h1 id="零宽度断言前后预查">零宽度断言（前后预查）</h1><p>  先行断言和后发断言（合称lookaround）都属于<strong>非捕获组</strong>（用于匹配模式，但不包括在匹配列表中）。当我们需要一个模式的前面或后面有另一个特定的模式时，就可以使用它们。</p><p>例如，我们希望从下面的输入字符串 <code>$4.44</code> 和<code>$10.88</code> 中获得所有以 <code>$</code>字符开头的数字，我们将使用以下的正则表达式<code>(?&lt;=\$)[0-9\.]*</code>。意思是：获取所有包含 <code>.</code>并且前面是 <code>$</code> 的数字。</p><p>零宽度断言如下：</p><table><thead><tr class="header"><th style="text-align: center;">符号</th><th>描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">?=</td><td>正先行断言-存在</td></tr><tr class="even"><td style="text-align: center;">?!</td><td>负先行断言-排除</td></tr><tr class="odd"><td style="text-align: center;">?&lt;=</td><td>正后发断言-存在</td></tr><tr class="even"><td style="text-align: center;">?&lt;!</td><td>负后发断言-排除</td></tr></tbody></table><h2 id="正先行断言"><code>?=...</code> 正先行断言</h2><p>  <code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着<code>?=...</code>定义的表达式。</p><p>返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用<code>()</code>。在括号内部使用一个问号和等号：<code>(?=...)</code>。</p><p>正先行断言的内容写在括号中的等号后面。 例如，表达式<code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和<code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code>，即 <code>The</code> 和 <code>the</code> 后面紧跟着<code>(空格)fat</code>。</p><pre>"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/IDDARt/1">在线练习</a></p><h2 id="负先行断言"><code>?!...</code> 负先行断言</h2><p>  负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为其后不跟随着断言中定义的格式。 <code>正先行断言</code> 定义和<code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成<code>!</code> 也就是 <code>(?!...)</code>。</p><p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和<code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p><pre>"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/V32Npg/1">在线练习</a></p><h2 id="正后发断言"><code>?&lt;= ...</code> 正后发断言</h2><p>  正后发断言 记作<code>(?&lt;=...)</code>用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配<code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或<code>the</code>。</p><pre>"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><p><a href="https://regex101.com/r/avH165/1">在线练习</a></p><h2 id="负后发断言"><code>?&lt;!...</code> 负后发断言</h2><p>  负后发断言 记作 <code>(?&lt;!...)</code>用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配<code>cat</code>，且其前不跟着 <code>The</code> 或<code>the</code>。</p><pre>"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.</pre><p><a href="https://regex101.com/r/8Efx5G/1">在线练习</a></p><h1 id="标志">标志</h1><p>  标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p><table><thead><tr class="header"><th style="text-align: center;">标志</th><th>描述</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">i</td><td>忽略大小写。</td></tr><tr class="even"><td style="text-align: center;">g</td><td>全局搜索。</td></tr><tr class="odd"><td style="text-align: center;">m</td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code>工作范围在每行的起始。</td></tr></tbody></table><h2 id="忽略大小写-case-insensitive">忽略大小写 (Case Insensitive)</h2><p>  修饰语 <code>i</code> 用于忽略大小写。 例如，表达式<code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的<code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和<code>The</code>，<code>g</code> 表示全局搜索。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><p><a href="https://regex101.com/r/dpQyf9/1">在线练习</a></p><pre>"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><p><a href="https://regex101.com/r/ahfiuh/1">在线练习</a></p><h2 id="全局搜索-global-search">全局搜索 (Global search)</h2><p>  修饰符 <code>g</code>常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+<code>at</code>，并返回全部结果。</p><pre>"/.(at)/" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.</pre><p><a href="https://regex101.com/r/jnk6gM/1">在线练习</a></p><pre>"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><p><a href="https://regex101.com/r/dO1nef/1">在线练习</a></p><h2 id="多行修饰符-multiline">多行修饰符 (Multiline)</h2><p>  多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p><p>像之前介绍的 <code>(^,$)</code>用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符<code>m</code>。</p><p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code>后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据<code>m</code> 修饰符，现在表达式匹配每行的结尾。</p><pre>"/.at(.)?$/" => The fat                cat sat                on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/hoGMkP/1">在线练习</a></p><pre>"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>                  cat <a href="#learn-regex"><strong>sat</strong></a>                  on the <a href="#learn-regex"><strong>mat.</strong></a></pre><p><a href="https://regex101.com/r/E88WE2/1">在线练习</a></p><h2 id="贪婪匹配与惰性匹配-greedy-vs-lazy-matching">贪婪匹配与惰性匹配(Greedy vs lazy matching)</h2><p>  正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用<code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><pre>"/(.*at)/" => <a href="#learn-regex"><strong>The fat cat sat on the mat</strong></a>. </pre><p><a href="https://regex101.com/r/AyAdgJ/1">在线练习</a></p><pre>"/(.*?at)/" => <a href="#learn-regex"><strong>The fat</strong></a> cat sat on the mat. </pre><p><a href="https://regex101.com/r/AyAdgJ/2">在线练习</a></p>]]></content>
    
    
    <summary type="html">🍤本文是正则表达式的教程</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="正则表达式" scheme="https://www.adunas.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>思考该不该吃完一颗难吃的苹果</title>
    <link href="https://www.adunas.top/posts/20240224c.html"/>
    <id>https://www.adunas.top/posts/20240224c.html</id>
    <published>2024-02-24T07:51:08.000Z</published>
    <updated>2024-02-24T07:51:08.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文学导航"><ahref="./20240224d.html#思考该不该吃完一颗难吃的苹果">文学导航</a></h1><p>  每次难吃的苹果我都咽下去了，但是这次我决定不吃了。（未完待续）</p>]]></content>
    
    
    <summary type="html">🍎每次难吃的苹果我都咽下去了，这次我决定不吃了</summary>
    
    
    
    <category term="文学" scheme="https://www.adunas.top/categories/%E6%96%87%E5%AD%A6/"/>
    
    
    <category term="思考" scheme="https://www.adunas.top/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>文学导航</title>
    <link href="https://www.adunas.top/posts/20240224d.html"/>
    <id>https://www.adunas.top/posts/20240224d.html</id>
    <published>2024-02-24T07:42:23.000Z</published>
    <updated>2024-02-24T07:42:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章导航总览"><ahref="./20240221a.html#文学">文章导航总览</a></h1><h1 id="原创">原创</h1><h2 id="思考该不该吃完一颗难吃的苹果"><ahref="./20240224c.html">思考该不该吃完一颗难吃的苹果</a></h2><!-- # 授权发表## [关于爱莉西亚局长的个人回忆](./20240222b.html) -->]]></content>
    
    
    <summary type="html">🍛本文是文学分类的导航</summary>
    
    
    
    <category term="文章导航" scheme="https://www.adunas.top/categories/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
    
    <category term="文章导航" scheme="https://www.adunas.top/tags/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>阅读导航</title>
    <link href="https://www.adunas.top/posts/20240224b.html"/>
    <id>https://www.adunas.top/posts/20240224b.html</id>
    <published>2024-02-23T17:17:02.000Z</published>
    <updated>2024-02-23T17:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章导航总览"><ahref="./20240221a.html#阅读">文章导航总览</a></h1><h1 id="论文">论文</h1><h2 id="论文阅读方法"><a href="./20240224a.html">论文阅读方法</a></h2><h2 id="一种基于目测的未知目标运动分析方位角方法"><ahref="./20240223a.html">一种基于目测的未知目标运动分析方位角方法</a></h2><h1 id="名著">名著</h1><h2 id="离骚节选"><a href="./20240304a.html">离骚（节选）</a></h2>]]></content>
    
    
    <summary type="html">🍜本文是阅读分类的导航</summary>
    
    
    
    <category term="文章导航" scheme="https://www.adunas.top/categories/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
    
    <category term="文章导航" scheme="https://www.adunas.top/tags/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读方法</title>
    <link href="https://www.adunas.top/posts/20240224a.html"/>
    <id>https://www.adunas.top/posts/20240224a.html</id>
    <published>2024-02-23T17:17:02.000Z</published>
    <updated>2024-02-23T17:17:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阅读导航"><ahref="./20240224b.html#论文阅读方法">阅读导航</a></h1><h1 id="资源下载">资源下载</h1><h2 id="arxiv">arXiv</h2><ol type="1"><li>官网：<a href="https://arxiv.org/">arXiv</a>。</li><li>视频介绍：<ahref="https://www.bilibili.com/video/BV1pT4y1m7AF/?share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">【推倒论文付费墙，救人新冠疫情里，这是“反向知网”arXiv的30年】</a>。</li></ol><p>  arXiv是免费的、可供下载的论文库。是一个论文预印版网站。预印本（Preprint）是指科研工作者的研究成果还未在正式出版物上发表，而出于和同行交流目的自愿先在学术会议上或通过互联网发布的科研论文、科技报告等文章。而另一方面，arXiv有独特的作用：为了防止自己的idea 在论文被收录前被别人剽窃，可以将预稿上传到 arXiv作为预收录，因此这就是个可以证明论文原创性（上传时间戳）的文档收录网站。</p>]]></content>
    
    
    <summary type="html">🎗本文记录学习论文的资源和方法</summary>
    
    
    
    <category term="阅读" scheme="https://www.adunas.top/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="阅读方法" scheme="https://www.adunas.top/tags/%E9%98%85%E8%AF%BB%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读：一种基于目测的未知目标运动分析方位角方法</title>
    <link href="https://www.adunas.top/posts/20240223a.html"/>
    <id>https://www.adunas.top/posts/20240223a.html</id>
    <published>2024-02-23T14:30:12.000Z</published>
    <updated>2024-02-23T14:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note blue no-icon flat"><ol type="1"><li>b站视频：<ahref="https://www.bilibili.com/video/BV1EC411z7Lz/?share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">【【IJRR最新成果】利用被忽视的视觉信息大幅提升目标定位可观性】</a></li><li>论文资源：<a href="https://arxiv.org/abs/2401.17117">A Bearing-AngleApproach for Unknown Target Motion Analysis Based on VisualMeasurements</a></li></ol></div><h1 id="阅读导航"><ahref="./20240224b.html#一种基于目测的未知目标运动分析方位角方法">阅读导航</a></h1><h1 id="abstract">Abstract</h1><p>  Vision-based estimation of the motion of a moving target is usuallyformulated as a <em>bearing-only</em> estimation problem where thevisual measurement is modeled as a bearing vector. Although thebearing-only approach has been studied for decades, a <em>fundamentallimitation</em> of this approach is that it requires extra lateralmotion of the observer to enhance the target's observability.Unfortunately, the extra lateral motion conflicts with the desiredmotion of the observer in many tasks. It is well-known that, once atarget has been detected in an image, a bounding box that surrounds thetarget can be obtained. Surprisingly, this common visual measurementespecially its size information has not been well explored up to now. Inthis paper, we propose a new <em>bearing-angle</em> approach to estimatethe motion of a target by modeling its image bounding box asbearing-angle measurements. Both theoretical analysis and experimentalresults show that this approach can significantly enhance theobservability <em>without</em> relying on additional lateral motion ofthe observer. The benefit of the bearing-angle approach comes with noadditional cost because a bounding box is a standard output of objectdetection algorithms. The approach simply exploits the information thathas not been fully exploited in the past. No additional sensing devicesor special detection algorithms are required.</p><details class="folding-tag" blue><summary> 注解 </summary>              <div class='content'>              <div id="分栏" class="tabs"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">音频</button></li><li class="tab"><button type="button" data-href="#分栏-2">概括</button></li></ul><div class="tab-contents"><div id="分栏-1" class="tab-item-content active"><div id="aplayer20240223a"></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div id="分栏-2" class="tab-item-content"><p>这些文字很多废话。总结就是：没有利用多余的传感器，而是用视觉新的信息：物体框作为新的观测值，提高了方位角的精度。同时不需要运动物体做额外的横向运动。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>              </div>            </details><h1 id="keywords">Keywords</h1><p>Bearing-only target motion estimation, Pseudo-linear Kalman filter,Observability enhancement</p><h1 id="introduction">Introduction</h1><p>  This paper studies the problem of estimating the motion of a movingtarget object using a moving monocular camera. The target's geometricinformation such as its physical size is <em>unknown</em> in advance.This problem is important in many fields . Our present work isparticularly motivated by the task of aerial target pursuit, where amicro aerial vehicle (MAV) uses its onboard camera to detect, localize,and then pursue another flying MAV. The task of aerial target pursuit,originally motivated by the interesting bird-catching-bird behaviors innature , potentially provides an effective approach to the defense ofmisused MAV.</p><figure id="fig_architecture_outdoor"></figure><img src="https://picture.adunas.top/Article/arXiv-2401.17117v1/fig_architecture_outdoor.png" /><figcaption><b>Figure 1.</b> An observer MAV observes a target MAV with a monocular camera. The bearing $g$ and angle $\theta$ can be obtained from the bounding box that surrounds the target in the image.</figcaption><p>  When a target has been detected in an image by a vision detectionalgorithm, we usually obtain a <em>bounding box</em> that surrounds thetarget's image (see Fig. <a href="#fig_architecture_outdoor">1</a>). Thebounding box carries two types of useful information that can be used toestimate the target's motion.</p><p>  The first type of useful information is the <em>center point</em>of the bounding box. The pixel coordinate of the center point can beused to calculate the spatial <em>bearing vector</em> pointing from thecamera to the target based on the pin-hole camera model <spanclass="citation" data-cites="Ma2012">[@Ma2012]</span>. Using the bearingvector to estimate the target's motion is referred to as<em>bearing-only</em> target motion estimation <span class="citation"data-cites="Fogel1988 He2019 Li2022">[@Fogel1988; @He2019;@Li2022]</span>. As a problem that has been studied for more than 40years, bearing-only target motion estimation was originally studied toestimate the motion of ships on the ocean surface <span class="citation"data-cites="hoelzer1978modified">[@hoelzer1978modified]</span>, andregained increasing research attention in recent years in vision-basedtarget estimation tasks <span class="citation"data-cites="Ponda2009 Anjaly2018 He2019">[@Ponda2009; @Anjaly2018;@He2019]</span>.</p><p>  Bearing-only target motion estimation requires an <em>observabilitycondition</em>: The observer must have higher-order motion than thetarget and, more importantly, the higher-order motion must containcomponents that are orthogonal to the target's bearing vector <spanclass="citation" data-cites="Fogel1988">[@Fogel1988]</span>. Motivatedby this observability condition, enormous works have studied how anobserver should move to enhance the observability <span class="citation"data-cites="Hammel1989 Sabet2016 Anjaly2018 He2019">[@Hammel1989;@Sabet2016; @Anjaly2018; @He2019]</span>. For instance, in our recentwork <span class="citation" data-cites="Li2022">[@Li2022]</span>, weproposed a helical guidance law so that a MAV moves along a helicalcurve to optimize the observability in the 3D space.</p><p>  A <em>limitation</em> of the observability condition of the classicbearing-only approach is that the observer must move in the lateraldirections that are orthogonal to the bearing vector of the target. Suchadditional lateral motion is usually unfavorable because it may conflictwith the desired motion of the observer in many tasks. For example, inan aerial target pursuit task, the pursuer is desired to approach thetarget as fast as possible and then keep stationary relative to thetarget. Then, the additional lateral motion would conflict with thedesired motion. It is, therefore, important to study other ways that canenhance the observability while avoiding unfavorable lateral motion.</p><p>  The second type of useful information of a bounding box is its<em>size</em> (either width or height). The size of a bounding box isjointly determined by several factors such as the target's distance, thetarget's physical size, and the orientation of the camera. The target'sphysical size is usually unknown in many tasks, especially in thoseantagonistic ones such as aerial pursuit of misused MAVs. As a result,the size of the bounding box cannot directly infer the target'sdistance. Nevertheless, it carries valuable information for localizingthe target.</p><p>  Surprisingly, the size information of the bounding box has not beenwell explored so far. The work that is closely relevant to ours is thestate-of-the-art one in <span class="citation"data-cites="Griffin2021">[@Griffin2021]</span>, where the size of abounding box is used to localize unknown target objects. Although theapproach in <span class="citation"data-cites="Griffin2021">[@Griffin2021]</span> is inspiring, it relieson two assumptions: The target objects are stationary and the camera canonly translate without rotating. It is still an open problem how toestimate a target's motion when the two assumptions are not valid.Moreover, the theoretical role of the size of a bounding box in targetmotion estimation has not been fully understood so far. Although thework in <span class="citation" data-cites="Vrba2020">[@Vrba2020]</span>also utilizes the size of the bounding box to estimate the target'sposition, it is assumed that the target's physical size is known inadvance.</p><p>  Estimating the motion of moving objects is also a fundamentalproblem in dynamic SLAM. For example, the works in <spanclass="citation" data-cites="Yang2019 Qiu2019">[@Yang2019;@Qiu2019]</span> firstly estimate the camera's pose and secondlyestimate the target object's pose subject to a scale factor, and finallyestimate the scale factor from multi-view measurements. To estimate thetarget object's pose subject to a scale factor, <span class="citation"data-cites="Yang2019">[@Yang2019]</span> and <span class="citation"data-cites="Qiu2019">[@Qiu2019]</span> rely on detecting, respectively,a 3D bounding box and sufficient feature points inside the 2D boundingbox. Different from <span class="citation"data-cites="Yang2019 Qiu2019">[@Yang2019; @Qiu2019]</span>, our proposedapproach merely utilizes a 2D image bounding box without furtherextracting feature points or a 3D bounding box inside the 2D boundingbox. As a result, one benefit is that this approach is morecomputationally efficient. Moreover, this approach can handle thechallenging small-target case where the target object is far and henceits image is small. In this case, it would be unreliable to extractsufficient stable features or conduct 3D detection.</p><p>  The aforementioned approaches in <span class="citation"data-cites="Griffin2021 Yang2019 Qiu2019">[@Griffin2021; @Yang2019;@Qiu2019]</span> are all based on multiple views. It is also possible toestimate the target's depth from a single view/image <spanclass="citation" data-cites="Tekin2018 Vrba2020">[@Tekin2018;@Vrba2020]</span>. The single-view approach however requires priorinformation of the objects. Moreover, it would be unable to successfullylocalize target objects with different sizes but similar appearances. Inthis paper, we focus on the multi-view case.</p><p>  In this paper, we propose a novel <em>bearing-angle</em> targetmotion estimation approach that models a bounding box as bearing-anglemeasurements. This approach can enhance the observability by fullyexploiting the information in a bounding box rather than relying on theadditional lateral motion of the observer. The benefit of the proposedbearing-angle approach comes with no additional cost since the boundingbox is a standard output of object detection algorithms. The approachsimply exploits the angle information that has not been fully exploitedin the past. No additional sensing devices or special detectionalgorithms are required.</p><p>  The technical novelties of this approach are threefold.</p><p>1) The proposed approach does not directly use the size of a boundingbox because the size is variant to the orientation of the camera. Thatis, even if the target's relative position is unchanged, the size of thebounding box still varies when the camera rotates. Motivated by thisproblem, we convert the size of the bounding box to an angle subtendedby the target (see Fig. <a href="#fig_architecture_outdoor"data-reference-type="ref"data-reference="fig_architecture_outdoor">1</a>). The merit of using theangle measurement is that it is <em>invariant</em> to the camera'sorientation change (see Fig. <a href="#fig_cam_rotate"data-reference-type="ref" data-reference="fig_cam_rotate">2</a>) andhence can greatly facilitate the estimator design. In this way, theassumption in <span class="citation"data-cites="Griffin2021">[@Griffin2021]</span> that the camera can onlytranslate but not rotate can be avoided.</p><p>2) Although the bearing-angle approach incorporates an additionalangle measurement, it is nontrivial to see how to properly use thismeasurement because the angle does not directly infer the target'sdistance given that the target's size is unknown. We notice that theangle is a joint nonlinear function of the target's physical size andrelative distance. Hence, the state vector, which only consists of thetarget's position and velocity in the conventional bearing-onlyapproach, is augmented by the unknown target's physical size. Since thebearing and angle measurements are all nonlinear functions of thetarget's state, we establish a pseudo-linear Kalman filter to properlyutilize the measurements to enhance estimation stability. Bothsimulation and real-world experiments verify the effectiveness of theproposed estimator.</p><p>3) Although an additional angle measurement is used, an additionalunknown, the target's physical size, is also introduced into theestimator. It is, therefore, nontrivial to see how the additional anglemeasurement can help improve the observability. Motivated by thisproblem, we prove the necessary and sufficient observability conditionfor bearing-angle target motion estimation. In particular, we show thatthe target's motion can be recovered if and only if the observer has ahigher-order motion than the target. Different from the bearing-onlycase, the higher-order motion is <em>not</em> required to be in thelateral directions that are orthogonal to the bearing vector. This is animportant enhancement of the observability. As we show in variousexperiments, the bearing-angle approach can successfully recover thetarget's motion in many scenarios where the bearing-only approachfails.</p><h1 id="related-work">Related Work</h1><h2 id="algorithms-for-bearing-only-target-motion-estimation">Algorithmsfor bearing-only target motion estimation</h2><p>  Bearing-only target motion analysis aims to estimate the target'smotion states, such as position and velocity, using bearing measurementonly. It was originally motivated by ship localization and tracking inthe ocean <span class="citation"data-cites="hoelzer1978modified">[@hoelzer1978modified]</span>. With therapid development of small-scale mobile robots equipped with cameras,the bearing-only approach regained increasing attention in recent years<span class="citation"data-cites="Ponda2009 Anjaly2018 He2019">[@Ponda2009; @Anjaly2018;@He2019]</span>.</p><p>  Kalman filter-based estimators are widely used in the bearing-onlytarget motion. One challenge of applying the Kalman filter to thebearing-only estimation is the nonlinearity of the bearing measurement.The conventional extended Kalman filter (EKF) exhibits divergenceproblems when applied to bearing-only target motion estimation <spanclass="citation" data-cites="Aidala1979 Lin2002">[@Aidala1979;@Lin2002]</span>. Several methods have been proposed to solve thisproblem. They can be divided into two types. The first type is themodified polar EKF, which was first proposed in <span class="citation"data-cites="hoelzer1978modified">[@hoelzer1978modified]</span>. In thisapproach, three observable quantities are separated from theunobservable ones to prevent divergence. The work in <spanclass="citation" data-cites="Stallard1991">[@Stallard1991]</span>extends this approach to the case of spherical coordinates to tracktargets in 3D space. The second type is the pseudo-linear Kalman filter,which is first proposed in <span class="citation"data-cites="Lingren1978">[@Lingren1978]</span> to solve the instabilityproblem by transforming the nonlinear measurement equation into apseudo-linear one. However, this transformation makes the noise becomenon-Gaussian and highly correlated to the measurement matrix and thencauses estimation bias. Nevertheless, the work in <span class="citation"data-cites="Aidala1982">[@Aidala1982]</span> theoretically proves thatthe velocity estimation has no bias, and the position estimation biascan be removed by the observer's maneuvers.</p><p>  Recently, other estimation algorithms based on advanced but morecomplex filters have been proposed. The work in <span class="citation"data-cites="Farina1999">[@Farina1999]</span> uses the maximum likelihood(MLE) algorithm to estimate the target's motion using bearing-onlymeasurements. The comparison with the Cramer-Rao lower bound indicatesthat the MLE-based estimator is effective against measurement errors.The work in <span class="citation"data-cites="Dogancay2005">[@Dogancay2005]</span> proposes a constrainedtotal least-squares algorithm, which can improve the estimation accuracywhen the error of bearing measurement is large. Three differentalgorithms are used and compared in <span class="citation"data-cites="Lin2002">[@Lin2002]</span>. The results show that the EKF,the pseudo-linear filter, and the particle filter have similarperformances in most situations, while the EKF loses track when theinitial estimate error is large.</p><p>  Another type of approach, called bearing-only trajectorytriangulation <span class="citation"data-cites="Avidan2000">[@Avidan2000]</span>, estimates the target'sposition from the perspective of trajectory fitting. It reconstructs thetrajectory by intersecting parametric trajectory to a series of sightrays obtained from bearing measurement. Once the trajectory issuccessfully fitted, the target's position at each time instant can beestimated by the intersection of the bearing and the trajectory. Thetrajectory fitting relies on the assumption of the trajectory's shape.However, in many applications, the target's trajectory is complex andunknown in advance. Many consecutive studies aim to relax thisassumption in various ways based on hypersurfaces <span class="citation"data-cites="Kaminski2004">[@Kaminski2004]</span>, parametric temporalpolynomials <span class="citation" data-cites="Yu2009">[@Yu2009]</span>,or compact basis vectors <span class="citation"data-cites="Park2015">[@Park2015]</span>.</p><h2id="observability-analysis-of-bearing-only-target-motion-estimation">Observabilityanalysis of bearing-only target motion estimation</h2><p>  Observability is a fundamental problem in bearing-only targetmotion estimation. Early works mainly focus on whether the system isobservable or not. For example, the work in <span class="citation"data-cites="Lingren1978">[@Lingren1978]</span> uses the rank ofobservation matrix to determine the observability. The work in <spanclass="citation" data-cites="Fogel1988">[@Fogel1988]</span> extends theobservability criterion in <span class="citation"data-cites="Nardone1981">[@Nardone1981]</span> to the Nth-order targetdynamics and inspires us for the observability analysis in Section <ahref="#Observability%20Analysis%20by%20Solving%20Linear%20Equations"data-reference-type="ref"data-reference="Observability Analysis by Solving Linear Equations">6</a>.All these conditions indicate that the observer must have extrahigh-order motion in the lateral direction. The observability conditioncan be significantly relaxed in our approach.</p><p>  Unlike the works on determining whether the system is observable ornot, some studies focus on quantifying the observability degree. Thework in <span class="citation"data-cites="Hammel1989">[@Hammel1989]</span> first introduces the Fisherinformation matrix (FIM) into the observability analysis. The works in<span class="citation" data-cites="Sabet2016">[@Sabet2016]</span> and<span class="citation" data-cites="Anjaly2018">[@Anjaly2018]</span> useFIM-based objective functions to maximize observability. We also use theFIM in our former work <span class="citation"data-cites="Li2022">[@Li2022]</span> to optimize the 3D helical guidancelaw for better observability. Another method called the geometric methoduses the geometric relationship between the target and the observer intwo consecutive time instants to derive the measure of observability<span class="citation" data-cites="He2019 Woffinden2009">[@He2019;@Woffinden2009]</span>, and the results are consistent with thosederived using FIM. Compared to the bearing-only approach, theobservability degree of our bearing-angle method is sufficient toestimate the target's motion in many common scenarios such as trackingand guidance (see experiment results in Figs. <a href="#fig_matlab_3"data-reference-type="ref"data-reference="fig_matlab_3">[fig_matlab_3]</a> and <ahref="#fig_outdoor_1" data-reference-type="ref"data-reference="fig_outdoor_1">[fig_outdoor_1]</a>).</p><h1 id="problem-formulation">Problem Formulation</h1><figure id="fig_cam_rotate"></figure><img src="https://picture.adunas.top/Article/arXiv-2401.17117v1/fig_cam_rotate.png" /><figcaption><b>Figure 2.</b> The size of the bounding box varies when the camera rotates. By contrast, the angle subtended by the target object is invariant to the camera's orientation change.</figcaption><p>  Consider a target object moving in the 3D space. Its position andvelocity at time <span class="math inline">\(t_k\)</span> are denoted as<span class="math inline">\(p_T(t_k) \in\mathbb{R}^3\)</span> and <spanclass="math inline">\(v_T(t_k) \in\mathbb{R}^3\)</span>, respectively.Suppose there is an observer carrying a monocular camera to observe thetarget. The position of the observer is denoted as <spanclass="math inline">\(p_o(t_k) \in\mathbb{R}^3\)</span>. Here, we assumethat the observer/camera's pose including its position and orientationcan be obtained in other ways. For example, it can be measured directlyby RTK GPS <span class="citation" data-cites="Li2022">[@Li2022]</span>or estimated by visual inertial odometry <span class="citation"data-cites="Qiu2019">[@Qiu2019]</span>. In the rest of the paper, thedependence of a variable on <span class="math inline">\(t_k\)</span> isdropped when the context is clear.</p><p>  If the target object can be detected by a vision algorithm, we canobtain a bounding box surrounding the target object in the image. Twotypes of information carried by the bounding box can be used to estimatethe motion of the target.</p><p>  First, the center point of the bounding box can be used tocalculate the <em>bearing</em> vector of the target. In particular,denote <span class="math inline">\(g \in \mathbb{R}^3\)</span> as theunit bearing vector pointing from <spanclass="math inline">\(p_o\)</span> to <spanclass="math inline">\(p_T\)</span>. Suppose <spanclass="math inline">\(p_\text{cam}\in\mathbb{R}^{3\times3}\)</span> isthe intrinsic parameter matrix of the camera (<span class="citation"data-cites="Ma2012">@Ma2012</span> Section <ahref="#bearing-angle-target-motion-estimator">4</a>), and <spanclass="math inline">\({R}_\text{c}^\text{w} \in\mathbb{R}^{3\times3}\)</span> is the rotation from the camera frame to the worldframe.</p><p>Then, the bearing vector <span class="math inline">\(g\)</span> canbe calculated as</p><p><span class="math display">\[\begin{aligned}g =\dfrac{{R}_\text{c}^\text{w}p_\text{cam}^{-1}{q}_{\rm pix}}{\|{R}_\text{c}^\text{w}p_\text{cam}^{-1}{q}_{\rm pix}\|},\end{aligned}\]</span></p><p>where <span class="math inline">\({q}_{\rm pix} =[x_{\rm pix} ,y_{\rm pix} , 1]^\mathrm{T} \in \mathbb{R}^3\)</span>. Here, <spanclass="math inline">\((x_{\rm pix} ,y_{\rm pix})\)</span> is the pixelcoordinate of the center point of the bounding box.</p><p>  Second, the size of the bounding box can be used to calculate the<em>angle</em> subtended by the target in the camera's field of view.The reason that we convert the bounding box's size to the angle is thatthe angle is invariant to the camera's orientation change (see Fig. <ahref="#fig_cam_rotate" data-reference-type="ref"data-reference="fig_cam_rotate">2</a>). In particular, let <spanclass="math inline">\(s_{\rm pix}\)</span> denote the size of thebounding box. It can be either the width or the height. Let <spanclass="math inline">\(\theta \in (0,\pi/2)\)</span> be the angle.According to the pin-hole camera model (<span class="citation"data-cites="Ma2012">@Ma2012</span> Section <ahref="#bearing-angle-target-motion-estimator">4</a>) and the law ofcosine (see Fig. <a href="#fig_cam_rotate" data-reference-type="ref"data-reference="fig_cam_rotate">2</a>), the angle can be calculatedas</p><p><span class="math display">\[\begin{aligned}\theta = \arccos\left(\dfrac{l_\mathrm{left}^2 + l_\mathrm{right}^2 -s_\mathrm{pix}^2}{2l_\mathrm{left}l_\mathrm{right}}\right),\end{aligned}\]</span></p><p>where <spanclass="math inline">\(l_\mathrm{left}=\sqrt{(f/\alpha)^2+(\deltax-s_\mathrm{pix}/2)^2+\delta y^2}\in\mathbb{R}\)</span> and <spanclass="math inline">\(l_\mathrm{right}=\sqrt{(f/\alpha)^2+(\deltax+s_\mathrm{pix}/2)^2+\delta y^2}\in\mathbb{R}\)</span> are thedistances in pixel from the camera center to the middle points of theleft and right sides of the bounding box, respectively (Fig. <ahref="#fig_architecture_outdoor" data-reference-type="ref"data-reference="fig_architecture_outdoor">1</a>). Moreover, <spanclass="math inline">\(f\)</span> and <spanclass="math inline">\(\alpha\)</span> denote the camera's focal lengthand single pixel size, respectively. <spanclass="math inline">\(i_{\text{width}}\)</span> and <spanclass="math inline">\(i_{\text{height}}\)</span> represent the width andthe height of the whole image in pixels, respectively. <spanclass="math inline">\(\deltax=\|x_\text{pix}-i_\text{width}/2\|\in\mathbb{R}\)</span> and <spanclass="math inline">\(\delta y =\|y_\text{pix}-i_\text{height}/2\|\in\mathbb{R}\)</span> are thedistances between the center of the bounding box and the center of theimage.</p><figure id="fig_architecture_algorithm"></figure><img src="https://picture.adunas.top/Article/arXiv-2401.17117v1/fig_architecture_algorithm.png" /><figcaption><b>Figure 3.</b> The architecture of the proposed approach. All the simulation and real-world experiments in this paper follow this architecture.</figcaption><p>Our goal is to estimate the target's position and velocity, <spanclass="math inline">\(p_T\)</span> and <spanclass="math inline">\(v_T\)</span>, based on the noisy measurements ofthe bearing vector <span class="math inline">\(g\)</span> and the angle<span class="math inline">\(\theta\)</span> together with the observer'sown position <span class="math inline">\(p_o\)</span>. To achieve thisgoal, we propose a new bearing-angle target motion estimator (Fig. <ahref="#fig_architecture_algorithm">3</a>). The estimator is introducedin detail in Section <ahref="#bearing-angle-target-motion-estimator">4</a>. The observabilityof this estimator is analyzed based on Kalman's observability criterionin Section <ahref="#Observability%20Analysis%20by%20Kalman&#39;s%20Criterion"data-reference-type="ref"data-reference="Observability Analysis by Kalman&#39;s Criterion">5</a>.We further prove a necessary and sufficient observability condition ofthe observer in Section <ahref="#Observability%20Analysis%20by%20Solving%20Linear%20Equations"data-reference-type="ref"data-reference="Observability Analysis by Solving Linear Equations">6</a>.Numerical simulation results are given in Section <ahref="#Numerical%20Simulation%20Results" data-reference-type="ref"data-reference="Numerical Simulation Results">7</a>. More realisticAirSim simulation results are given in Section <ahref="#AirSim%20Simulation%20Results" data-reference-type="ref"data-reference="AirSim Simulation Results">8</a>. Finally, real-worldexperiments are given in Section <ahref="#Real-World%20Experimental%20Results" data-reference-type="ref"data-reference="Real-World Experimental Results">9</a>.</p><p><a id="bearing-angle-target-motion-estimator"></a></p><h1 id="bearing-angle-target-motion-estimator">Bearing-Angle TargetMotion Estimator</h1><p>This section designs a bearing-angle target motion estimator based onthe framework of pseudo-linear Kalman filtering. The key here is toestablish appropriate measurement and state transition equations.</p><h2 id="states-transition-equation">States transition equation</h2><p>  The state vector of the target is designed as</p><p><span class="math display">\[\begin{aligned}{x}=\left[  \begin{array}{c}    p_T \\    v_T \\    \ell \\  \end{array}\right]\in \mathbb{R}^7,\end{aligned}\]</span> where <span class="math inline">\(p_T\)</span>and <span class="math inline">\(v_T\)</span> are target's globalposition and velocity, respectively. Here, <spanclass="math inline">\(\ell&gt;0\)</span> is a scalar that represents thephysical size of the target object in the dimension that is orthogonalto the bearing vector (Fig. <a href="#fig_cam_rotate"data-reference-type="ref" data-reference="fig_cam_rotate">2</a>). Inthis paper, <span class="math inline">\(\ell\)</span> is assumed to beconstant or varying slowly, which means that the physical size of thetarget object should be approximately invariant from different viewingangles. Here, <span class="math inline">\(\ell\)</span> corresponds to<span class="math inline">\(\theta\)</span>, which further correspondsto either the width or height of the bounding box. Whether <spanclass="math inline">\(\ell\)</span> should correspond to the width orheight depends on in which dimension the physical size of the targetobject is invariant when viewed from different angles. More explanationis given in Section <ahref="#Dynamic%20modeling%20of%20target&#39;s%20physical%20size"data-reference-type="ref"data-reference="Dynamic modeling of target&#39;s physical size">4.2</a>.</p><p>Different from the bearing-only case where the state merely consistsof the position and velocity, the state here is augmented by thetarget's physical size. This is due to the fact that the anglemeasurement is a function of the target's physical size, which should beestimated as well. One may wonder whether the state vector can alsoincorporate the target's acceleration. To estimate high-order motion(e.g., acceleration) of the target, the observer must have higher-ordermotion (e.g., nonzero jerk) according to the observability conditionpresented in Section <ahref="#Observability%20Analysis%20by%20Solving%20Linear%20Equations"data-reference-type="ref"data-reference="Observability Analysis by Solving Linear Equations">6</a>.Otherwise, the estimation would diverge. Therefore, it is preferred toexclude the acceleration and merely estimate the position andvelocity.</p><p>If no information of the target's motion is available, it is commonto model the target's motion as a discrete-time noise-driven doubleintegrator: <span class="math display">\[\begin{aligned}\label{eq_state_transition}    {x}(t_{k+1})={F}{x}(t_k) +{q}(t_k) ,\end{aligned}\]</span> where <spanclass="math display">\[\begin{aligned}\label{eq_matrix_A}{F}=\begin{bmatrix}{I}_{3\times3} &amp; \delta t{I}_{3\times3} &amp; {0}_{3\times1}  \\{0}_{3\times3} &amp; {I}_{3\times3}  &amp; {0}_{3\times1}   \\{0}_{1\times 3} &amp; {0}_{1\times 3} &amp; 1\end{bmatrix}\in\mathbb{R}^{7\times 7},\end{aligned}\]</span> with <span class="math inline">\(\deltat\)</span> as the sampling time, and <spanclass="math inline">\({I}\)</span> and <spanclass="math inline">\({0}\)</span> as the identity and zero matrices,respectively. Here, <span class="math inline">\({q}\in\mathbb{R}^7\)</span> is a zero-mean process noise satisfying <spanclass="math inline">\({q} \sim \mathcal{N}(0,{\Sigma}_q)\)</span>, wherethe covariance matrix is <span class="math display">\[\begin{aligned}{\Sigma}_q=\text{diag}(0, 0, 0, \sigma_v^2, \sigma_v^2, \sigma_v^2,\sigma_\ell^2)\in\mathbb{R}^{7\times7}.\end{aligned}\]</span> Here, <spanclass="math inline">\(\sigma_v\in\mathbb{R}\)</span> and <spanclass="math inline">\(\sigma_\ell\in\mathbb{R}\)</span> are the standarddeviations of the target's velocity and size, respectively. When thetarget's shape is irregular, <span class="math inline">\(\ell\)</span>may vary when viewed from different angles. By letting <spanclass="math inline">\(\sigma_\ell\ne0\)</span>, we can handle the casewhere <span class="math inline">\(\ell\)</span> varies slowly. Thedynamic modeling of <span class="math inline">\(\ell\)</span> isdiscussed in the following subsection.</p><h2 id="dynamic-modeling-of-targets-physical-size">Dynamic modeling oftarget's physical size</h2><p>  Since the target's physical size <spanclass="math inline">\(\ell\)</span> is a state variable to be estimated,it is important to discuss its dynamic model. In fact, the dynamic modelof <span class="math inline">\(\ell\)</span> in <ahref="#eq_state_transition" data-reference-type="eqref"data-reference="eq_state_transition">[eq_state_transition]</a> assumesthat <span class="math inline">\(\ell\)</span> varies slowly. We nextjustify this modeling and provide more discussion.</p><p>First of all, <span class="math inline">\(\ell\)</span> correspondsto the physical size of the target object in the dimension that isorthogonal to the bearing vector. Its dynamics can be categorized intothree cases.</p><p><em>1) <span class="math inline">\(\ell\)</span> is invariant.</em>In theory, when <span class="math inline">\(\ell\)</span> is invariant,a change of <span class="math inline">\(\theta\)</span> implies a changeof <span class="math inline">\(r\)</span>. As a result, the measurementof <span class="math inline">\(\theta\)</span> can help improve thesystem's observability, as proven in Section <ahref="#Observability%20Analysis%20by%20Solving%20Linear%20Equations"data-reference-type="ref"data-reference="Observability Analysis by Solving Linear Equations">6</a>.An ideal case where <span class="math inline">\(\ell\)</span> isinvariant is that the target object is a sphere or cylinder so that<span class="math inline">\(\ell\)</span> corresponds to its diameter<span class="citation" data-cites="Vrba2020">[@Vrba2020]</span>. Inpractice, the target object does not have to be the ideal case. Forexample, consider an autonomous driving scenario where a focal vehicleuses a camera to localize its surrounding vehicles in the 2D plane.Although the physical size of a surrounding vehicle changes greatly whenviewed from behind or side, the height of the vehicle is<em>invariant</em> from different side-view angles. In this case, <spanclass="math inline">\(\ell\)</span> corresponds to the height of thevehicle, and we need to use the height of the image bounding box tocalculate <span class="math inline">\(\theta\)</span>.</p><p><em>2) <span class="math inline">\(\ell\)</span> varies slowly.</em>If there does not exist any dimension in which the physical size of thetarget remains invariant, <span class="math inline">\(\ell\)</span> mayvary slowly when the target is viewed from different angles. Forexample, in the tasks of aerial target pursuit, if the target is aquadcopter or hexacopter, then <span class="math inline">\(\ell\)</span>is approximately equal to the wheelbase but may vary slightly whenviewed from different angles since the MAV is not a perfect cylinder. Inthis case, <span class="math inline">\(\ell\)</span> corresponds to thewheelbase of the MAV, and we need to use the width of the image boundingbox to calculate <span class="math inline">\(\theta\)</span>.</p><p>If <span class="math inline">\(\ell\)</span> varies slowly, it canstill be treated as invariant within short time intervals. As long asthe observability condition (Section <ahref="#Observability%20Analysis%20by%20Solving%20Linear%20Equations"data-reference-type="ref"data-reference="Observability Analysis by Solving Linear Equations">6</a>)is satisfied, the motion of the target as well as <spanclass="math inline">\(\ell\)</span> can be successfully estimated. Thisfact is supported by the experimental results in Section <ahref="#Scenario%202:%20Circular%20motion%20and%20varying%20$\ell$"data-reference-type="ref"data-reference="Scenario 2: Circular motion and varying $\ell$">8.4</a>.It is however worth nothing that the performance of the proposedbearing-angle approach would degenerate to the conventional bearing-onlyone because the additional information brought by <spanclass="math inline">\(\theta\)</span> is used to estimate thetime-varying <span class="math inline">\(\ell\)</span> rather thanhelping improve the system's observability.</p><p><em>3) <span class="math inline">\(\ell\)</span> varies rapidly.</em>If <span class="math inline">\(\ell\)</span> varies rapidly due tocertain reasons, it would be difficult to distinguish whether the changeof <span class="math inline">\(\theta\)</span> is caused by the changeof <span class="math inline">\(\ell\)</span> or the change of <spanclass="math inline">\(r\)</span>. For example, when a MAV is used totrack a ground vehicle, <span class="math inline">\(\ell\)</span> in anydimension may vary rapidly when the relative motion between the MAV andthe ground vehicle is highly dynamic. In such scenarios, the additionalinformation brought by <span class="math inline">\(\theta\)</span> is nolonger sufficient to estimate the rapidly varying <spanclass="math inline">\(\ell\)</span> in this case. Additional visualinformation such as a 3D bounding box that indicates the target's 3Dattitude is required. This is an important topic for future research butout of the scope of the present paper.</p><h2 id="nonlinear-measurement-equations">Nonlinear measurementequations</h2><p>The bearing vector <span class="math inline">\(g\)</span> and thesubtended angle <span class="math inline">\(\theta\)</span> are bothnonlinear functions of the target's position. In particular, <spanclass="math display">\[\label{eq_information}\begin{align}    g &amp;=\dfrac{p_T -p_o }{r },    \label{eq_bearing_measure} \\    \theta &amp;=2\arctan\left(\dfrac{\ell}{2r }\right)\approx\dfrac{\ell}{r },    \label{eq_theta_measure}\end{align}\]</span> where <span class="math display">\[r =\|p_T -p_o\|\]</span> is the distance between the target and the observer. It isnotable that there is an approximation in <a href="#eq_theta_measure"data-reference-type="eqref"data-reference="eq_theta_measure">[eq_theta_measure]</a>. Thisapproximation is accurate. Specifically, when <spanclass="math inline">\(r&gt;3\ell\)</span>, which is common in practice,it can be verified that the approximation error is less than <spanclass="math inline">\(0.08\%\)</span>. The approximation error furtherdecreases as <span class="math inline">\(r\)</span> increases.</p><p>In practice, measurements always contain noises. First, denote <spanclass="math inline">\(\hat{g} \in\mathbb{R}^3\)</span> as thenoise-corrupted bearing measurement. Then, we have <spanclass="math display">\[\begin{aligned}\label{eq_noised_g_mear}\hat{g}  = {R}\left({\eta} , \epsilon \right) g ,\end{aligned}\]</span> where <span class="math inline">\({R}\left({\eta}, \epsilon \right) \in \mathbb{R}^{3\times 3}\)</span> is a rotationmatrix that perturbs <span class="math inline">\(g\)</span>. Here, <spanclass="math inline">\({\eta} \in\mathbb{R}^3\)</span> is a unit vectorrepresenting a random rotation axis, and <spanclass="math inline">\(\epsilon \in \mathbb{R}\)</span> is a randomrotation angle. This rotation matrix would rotate the vector <spanclass="math inline">\(g\)</span> by an angle <spanclass="math inline">\(\epsilon\)</span> around the axis <spanclass="math inline">\({\eta}\)</span>. The productive noise in <ahref="#eq_noised_g_mear" data-reference-type="eqref"data-reference="eq_noised_g_mear">[eq_noised_g_mear]</a> can betransformed into an additive one: <spanclass="math display">\[\begin{aligned}\label{eq_noised_g_mear_add}    \hat{g}  = g  + {\mu} ,\end{aligned}\]</span> where <span class="math inline">\({\mu}=({R}\left({\eta} , \epsilon \right) - {I}_{3\times3})g\in\mathbb{R}^3\)</span> is the measurement noise of the bearing vector.The covariance of <span class="math inline">\(\mu\)</span> is derived inour previous work <span class="citation"data-cites="Li2022">[@Li2022]</span>. Since the covariance is complexand involves unknown true values, we can approximately treat it as aGaussian noise: <span class="math inline">\(\mu\sim\mathcal{N}(0,\sigma_\mu^2 I_{3\times 3})\)</span> <span class="citation"data-cites="Li2022">[@Li2022]</span>.</p><p>Substituting <a href="#eq_bearing_measure"data-reference-type="eqref"data-reference="eq_bearing_measure">[eq_bearing_measure]</a> into <ahref="#eq_noised_g_mear_add" data-reference-type="eqref"data-reference="eq_noised_g_mear_add">[eq_noised_g_mear_add]</a> givesthe <em>nonlinear bearing measurement equation:</em> <spanclass="math display">\[\begin{aligned}\label{eq_bearing_measure_noise}    \hat{g} &amp;=\dfrac{p_T -p_o }{r } + {\mu} .\end{aligned}\]</span></p><p>Second, denote <span class="math inline">\(\hat{\theta}\in\mathbb{R}\)</span> as the noise-corrupted measurement of thesubtended angle. Then, we have <spanclass="math display">\[\begin{aligned}\label{eq_noise_theta}    \hat{\theta} =\theta  + w ,\end{aligned}\]</span> where <span class="math inline">\(w \sim\mathcal{N}(0, \sigma^2_w)\)</span> is the measurement noise.Substituting <a href="#eq_theta_measure" data-reference-type="eqref"data-reference="eq_theta_measure">[eq_theta_measure]</a> into <ahref="#eq_noise_theta" data-reference-type="eqref"data-reference="eq_noise_theta">[eq_noise_theta]</a> yields the<em>nonlinear angle measurement equation:</em> <spanclass="math display">\[\begin{aligned}\label{eq_theta_measure_noise}    \hat{\theta} &amp;=\dfrac{\ell}{r } + w.\end{aligned}\]</span></p><h2 id="pseudo-linear-measurement-equations">Pseudo-linear measurementequations</h2><p>The measurement equations <a href="#eq_bearing_measure_noise"data-reference-type="eqref"data-reference="eq_bearing_measure_noise">[eq_bearing_measure_noise]</a>and <a href="#eq_theta_measure_noise" data-reference-type="eqref"data-reference="eq_theta_measure_noise">[eq_theta_measure_noise]</a> arenonlinear in the target's state. In the following, we convert the twoequations to be pseudo-linear and then apply pseudo-linear Kalmanfiltering to achieve better estimation stability <span class="citation"data-cites="Lin2002">[@Lin2002]</span>.</p><p>First, to convert the 3D bearing measurement to pseudo-linear, weintroduce a useful orthogonal projection matrix: <spanclass="math display">\[\begin{aligned}    p_{\hat{g} }\doteq{I}_{3\times 3}-\hat{g} \hat{g}^\mathrm{T}  \in\mathbb{R}^{3\times 3}.\end{aligned}\]</span> This matrix plays an important role in theanalysis of bearing-related estimation and control problems <spanclass="citation" data-cites="Zhao2019">[@Zhao2019]</span>. It has animportant property: <span class="math display">\[p_{\hat{g} }\hat{g}={0}_{3\times 1}.\]</span> As a result, multiplying <spanclass="math inline">\(rp_{\hat{g} }\)</span> on both side of <ahref="#eq_bearing_measure_noise" data-reference-type="eqref"data-reference="eq_bearing_measure_noise">[eq_bearing_measure_noise]</a>yields <span class="math display">\[\begin{aligned}{0}_{3\times 1}=p_{\hat{g} }(p_T -p_o) + rp_{\hat{g} }{\mu}\end{aligned}\]</span> and consequently <spanclass="math display">\[\begin{aligned}p_{\hat{g} }p_o =p_{\hat{g} }p_T  + rp_{\hat{g} }{\mu}.\end{aligned}\]</span> Rewriting this equation in terms of the target'sstate variables yields the <em>pseudo-linear bearing measurementequation:</em> <span class="math display">\[\begin{aligned}\label{eq_pseudo_linear_measurement_g_equation}p_{\hat{g} }p_o =\begin{bmatrix}p_{\hat{g} } &amp;{0}_{3\times4}\end{bmatrix}\left[  \begin{array}{c}    p_T \\    v_T \\    \ell \\  \end{array}\right]  +  rp_{\hat{g} }{\mu} .\end{aligned}\]</span> Here, <span class="math inline">\(p_{\hat{g}}p_o\)</span> on the left-hand side is the new measurement, which ispseudo-linear in the target's state variables. The reason that it iscalled "pseudo" is because the measurements also appear on theright-hand side of the equation, especially in the measurementmatrix.</p><p>Second, we convert the nonlinear angle measurement in <ahref="#eq_theta_measure_noise" data-reference-type="eqref"data-reference="eq_theta_measure_noise">[eq_theta_measure_noise]</a> tobe pseudo-linear. To that end, multiplying <span class="math inline">\(r{\hatg}\)</span> on both side of <a href="#eq_theta_measure_noise"data-reference-type="eqref"data-reference="eq_theta_measure_noise">[eq_theta_measure_noise]</a>yields <span class="math display">\[\begin{aligned}\label{eq_theta_pseudo_tem}\hat{\theta} r\hat{g}  = \ell\hat{g} +wr\hat{g} .\end{aligned}\]</span> It follows from <ahref="#eq_bearing_measure_noise" data-reference-type="eqref"data-reference="eq_bearing_measure_noise">[eq_bearing_measure_noise]</a>that <span class="math inline">\(r{\hatg}=p_T -p_o+r\mu\)</span>,substituting which into the left-hand side of <ahref="#eq_theta_pseudo_tem" data-reference-type="eqref"data-reference="eq_theta_pseudo_tem">[eq_theta_pseudo_tem]</a> gives<span class="math display">\[\begin{aligned}\hat{\theta} (p_T -p_o+r\mu)  = \ell\hat{g} +wr\hat{g}.\end{aligned}\]</span> Reorganizing the above equation gives <spanclass="math display">\[\begin{aligned}\hat{\theta} p_o  = &amp;\hat{\theta} p_T  - \ell\hat{g} +r(\hat{\theta}  {\mu}  - w \hat{g}).\end{aligned}\]</span> Rewriting this equation in terms of the target'sstate variables yields the <em>pseudo-linear angle measurementequation:</em> <span class="math display">\[\begin{aligned}\label{eq_pseudo_linear_measurement_theta_equation}\begin{aligned}\hat{\theta} p_o  =&amp;\begin{bmatrix}\hat{\theta} {I}_{3\times 3} &amp; {0}_{3\times 3}  &amp; -\hat{g}\end{bmatrix}\left[  \begin{array}{c}    p_T \\    v_T \\    \ell \\  \end{array}\right]+ r(\hat{\theta}  {\mu}  - w \hat{g} ),\end{aligned}\end{aligned}\]</span> where <span class="math inline">\(\hat{\theta}p_o\)</span> is the new measurement that is pseudo-linear in thetarget's state variables.</p><h2 id="bearing-angle-estimation-algorithm">Bearing-angle estimationalgorithm</h2><p>Combining <a href="#eq_pseudo_linear_measurement_g_equation"data-reference-type="eqref"data-reference="eq_pseudo_linear_measurement_g_equation">[eq_pseudo_linear_measurement_g_equation]</a>and <a href="#eq_pseudo_linear_measurement_theta_equation"data-reference-type="eqref"data-reference="eq_pseudo_linear_measurement_theta_equation">[eq_pseudo_linear_measurement_theta_equation]</a>gives the compact form of the measurement equation: <spanclass="math display">\[\begin{aligned}\label{eq_pseudo_linear_measurement_equations}{z} = {H} {x}  + {\nu} ,\end{aligned}\]</span> where <span class="math display">\[\begin{align}{z} &amp;=    \begin{bmatrix}    p_{\hatg} p_o   \\    \hat{\theta} p_o    \end{bmatrix}\in\mathbb{R}^6, \\{H}&amp; =    \begin{bmatrix}    p_{\hatg}  &amp; {0}_{3\times 3} &amp; {0}_{3\times 1} \\    \hat{\theta} {I}_{3\times 3} &amp; {0}_{3\times 3}  &amp; -\hat{g}    \end{bmatrix}\in\mathbb{R}^{6\times7},    \label{eq_matrix_H} \\{\nu}  &amp;=    \begin{bmatrix}    r p_{\hatg} {\mu}  \\    r (\hat{\theta}  {\mu}  - w \hat{g} )    \end{bmatrix}    \in\mathbb{R}^6.    \label{eq_final_measurement_noise}\end{align}\]</span> Here, <span class="math inline">\(\nu\)</span> canbe rewritten as a matrix form <spanclass="math display">\[\begin{aligned}    \nu=E    \begin{bmatrix}        \mu \\ w    \end{bmatrix},\end{aligned}\]</span> where <spanclass="math display">\[\begin{aligned}\label{eq_E_mat}    E=r    \begin{bmatrix}        P_{\hatg} &amp; 0_{3\times 1}\\        \hat{\theta}I_{3\times 3} &amp; -\hatg    \end{bmatrix}\in\mathbb{R}^{6\times 4}.\end{aligned}\]</span> As a result, <spanclass="math inline">\(\nu\)</span> can be approximately treated as alinear transformation of Gaussian noises. Its covariance matrix can becalculated as <span class="math display">\[\begin{aligned}%\label{eq_final_measurement_noise_covariance}{\Sigma}_  = E\begin{bmatrix}\sigma_\mu^2 I_{3\times 3} &amp; 0_{3\times1}\\0_{1\times 3} &amp; \sigma_w^2\end{bmatrix}E^\mathrm{T}\in\mathbb{R}^{6\times6}.\end{aligned}\]</span> Although the quantities in <spanclass="math inline">\(E\)</span> such as <spanclass="math inline">\(\hatg\)</span> and <spanclass="math inline">\(\hat{\theta}\)</span> contain measurement noises,it is a common practice to treat them as deterministic quantities.Otherwise, if, for example, <span class="math inline">\(\hatg\)</span>is split to <span class="math inline">\(\hatg=g+\mu\)</span> and weconsider the noise separately, the expression of <spanclass="math inline">\(\nu\)</span> would be a complex function of thetrue values and the noises. Since the true values are unknown, thecovariance cannot be calculated. Moreover, <spanclass="math inline">\(r\)</span> in <a href="#eq_E_mat"data-reference-type="eqref" data-reference="eq_E_mat">[eq_E_mat]</a> isthe true target range, which is unknown. We can use the estimated value<span class="math inline">\(\hat{r} =\|\hat{p}_T -p_o \|\)</span> toreplace it in implementation. Here, <spanclass="math inline">\(\hatp_T\in\mathbb{R}^3\)</span> is the estimatedvalue of the target's position. This technique has been used inbearing-only target estimation <span class="citation"data-cites="He2018 Li2022">[@He2018; @Li2022]</span>.</p><p>With the state transition equation <a href="#eq_state_transition"data-reference-type="eqref"data-reference="eq_state_transition">[eq_state_transition]</a> and themeasurement equation <a href="#eq_pseudo_linear_measurement_equations"data-reference-type="eqref"data-reference="eq_pseudo_linear_measurement_equations">[eq_pseudo_linear_measurement_equations]</a>,the bearing-angle estimator can be realized by the Kalman filter. For aquick reference, we list the steps below. The prediction steps are <spanclass="math display">\[\begin{aligned}\hat^{-}(t_k) &amp;={F}\hat(t_{k-1}), \\p^{-}(t_k) &amp;= {F}p(t_{k-1}){F}^\mathrm{T} + {\Sigma}_q,\end{aligned}\]</span> where <spanclass="math inline">\(\hat^{-}(t_k)\in\mathbb{R}^7\)</span>and <spanclass="math inline">\(p^{-}(t_k)\in\mathbb{R}^{7\times7}\)</span> arethe prior estimated state and covariance matrix, respectively. Thecorrection steps are <span class="math display">\[\begin{aligned}{K}(t_k) &amp;=p^{-}(t_k){H}^\mathrm{T}(t_k)\left[{H}(t_k)p^{-}(t_k){H}^\mathrm{T}(t_k)+{\Sigma}_\nu\right]^{\dagger},\\\hat(t_k) &amp;= \hat^{-}(t_k) +{K}(t_k)\left[{z}(t_k)-{H}(t_k)\hat^{-}(t_k)\right],\\p(t_k) &amp;=\left[{I}_{7\times 7} -{K}(t_k){H}(t_k) \right]p^{-}(t_k),\end{aligned}\]</span> where <spanclass="math inline">\({K}(t_k)\in\mathbb{R}^{7\times6}\)</span> is theKalman gain matrix, <spanclass="math inline">\(\hat(t_k)\)</span> and <spanclass="math inline">\(p(t_k)\)</span> are posterior estimated state andcovariance matrix, and symbol <spanclass="math inline">\(\dagger\)</span> denotes the pseudoinverse. Theusage of pseudoinverse in the Kalman filter is a common practice toprevent the situation that <spanclass="math inline">\({H}(t_k)p^{-}(t_k){H}^\mathrm{T}(t_k)+{\Sigma}_\nu\)</span>is rank deficient <span class="citation"data-cites="YOSHIKAWA1972 Kulikov2018">[@YOSHIKAWA1972;@Kulikov2018]</span>.</p><h1 id="observability-analysis-by-kalmans-criterion">ObservabilityAnalysis by Kalman's Criterion</h1><p>Although an additional angle measurement is adopted in thebearing-angle estimator, it is nontrivial to see whether this additionalmeasurement can improve the system's observability because an additionalunknown variable, the target's physical size, is also required toestimate. It is therefore necessary to study the observabilityconditions under which the target's motion can be successfullyestimated.</p><p>In this and the next sections, we present two methods to analyze theobservability conditions. The first method, as presented in thissection, relies on Kalman's observability criterion, which is to checkthe rank of the observability matrix of a linear system. The secondmethod, as presented in the next section, relies on solving a set oflinear equations. Both methods have been adopted in the literature toanalyze the observability of estimators <span class="citation"data-cites="Zhao2015 Fogel1988">[@Zhao2015; @Fogel1988]</span>. For thebearing-angle estimator, the first method considers the specificdynamics of the filter but is not able to handle the case when thetarget's motion has a higher order. The second method can handle thehigh-order motion of the target but does not consider the dynamics ofthe filter. We will show that the conclusions given by the two methodsare consistent. In both of the methods, we consider the case where <spanclass="math inline">\(\ell\)</span> is invariant.</p><h2 id="the-observability-matrix">The observability matrix</h2><p>Consider a time horizon of <span class="math inline">\(k\geq3\)</span> consecutive steps. The observability matrix of the system of<a href="#eq_matrix_H" data-reference-type="eqref"data-reference="eq_matrix_H">[eq_matrix_H]</a> and <ahref="#eq_matrix_A" data-reference-type="eqref"data-reference="eq_matrix_A">[eq_matrix_A]</a> can be calculated as<span class="math display">\[\begin{aligned}\label{eq_Qo}    {Q}=    \begin{bmatrix}    {H}(t_1) \\    {H}(t_2){F} \\    {H}(t_3){F}^2 \\    \cdots \\    {H}(t_k){F}^{k-1} \\    \end{bmatrix}\in\mathbb{R}^{6k\times7}.\end{aligned}\]</span> Substituting the expressions of <spanclass="math inline">\(F\)</span> and <spanclass="math inline">\(H\)</span> in <a href="#eq_matrix_A"data-reference-type="eqref"data-reference="eq_matrix_A">[eq_matrix_A]</a> and <ahref="#eq_matrix_H" data-reference-type="eqref"data-reference="eq_matrix_H">[eq_matrix_H]</a> into <a href="#eq_Qo"data-reference-type="eqref" data-reference="eq_Qo">[eq_Qo]</a> yields<span class="math display">\[\begin{aligned}{Q}=\left[\begin{array}{ccc}p_g(t_1) &amp; {0}_{3\times 3} &amp; {0}_{3\times 1} \\\theta(t_1){I}_{3\times 3} &amp; {0}_{3\times 3}  &amp; -g(t_1) \\\hdashlinep_g(t_2) &amp; \delta tp_g(t_2) &amp; {0}_{3\times 1} \\\theta(t_2){I}_{3\times 3} &amp; \delta t\theta(t_2){I}_{3\times3}  &amp; -g(t_2) \\\hdashline\vdots &amp; \vdots &amp; \vdots \\\hdashlinep_g(t_k) &amp; (k-1)\delta tp_g(t_k) &amp; {0}_{3\times 1} \\\theta(t_k){I}_{3\times 3} &amp; (k-1)\delta t\theta(t_k){I}_{3\times3}  &amp; -g(t_k)\\\end{array}\right].\end{aligned}\]</span> Note that the noises in the bearing and anglemeasurements are neglected when we analyze the fundamental observabilityproperty. After a series of elementary row transformations in <spanclass="math inline">\({Q}\)</span>, we can obtain <spanclass="math display">\[\begin{aligned}\label{eq_Qo_2}{Q}\rightarrow\begin{bmatrix}{I}_{3\times 3} &amp; {0}_{3\times 3} &amp; -g(t_1)/\theta(t_1) \\{0}_{3\times 3} &amp; {I}_{3\times 3} &amp; -\deltav(t_2)/\ell \\\vdots &amp; \vdots &amp; \vdots \\{0}_{3\times 3} &amp; {I}_{3\times 3} &amp; -\deltav(t_k)/\ell \\\hdashline{0}_{3k\times 3} &amp; {0}_{3k\times 3} &amp; {0}_{3k\times 1}\end{bmatrix},\end{aligned}\]</span> where <spanclass="math display">\[\begin{aligned}\deltav(t_k) \doteq v_T(t_k) - v_o(t_k)\end{aligned}\]</span> is the relative velocity.</p><p>In the following two subsections, we analyze the rank of theobservability matrix in two scenarios where the observer moves with zeroand nonzero acceleration, respectively. In the two scenarios, the targetis always assumed to move with a constant velocity: <spanclass="math display">\[\begin{aligned}v_T(t_k) = v_T^\text{const}.\end{aligned}\]</span></p><h2 id="case-1-the-observers-velocity-is-constant">Case 1: theobserver's velocity is constant</h2><p>Denoted <span class="math inline">\(v_o\in \mathbb{R}^3\)</span> asthe velocity of the observer. Consider the case where the observer has aconstant velocity <spanclass="math inline">\(v_o^\text{case1}(t_i)=v_o^\text{const}\)</span>for any <span class="math inline">\(i\in\{1,\dots,k\}\)</span>. Then,the relative velocity is also constant: <spanclass="math display">\[\begin{aligned}\label{eq_delta_vel_case1}\delta v^\text{case1}(t_i) = v_T^\text{const} - v_o^\text{const} =\deltav^\text{const}.\end{aligned}\]</span> Substituting <a href="#eq_delta_vel_case1"data-reference-type="eqref"data-reference="eq_delta_vel_case1">[eq_delta_vel_case1]</a> into <ahref="#eq_Qo_2" data-reference-type="eqref"data-reference="eq_Qo_2">[eq_Qo_2]</a> and conducting elementary rowtransformation yields <span class="math display">\[\begin{aligned}\label{eq_Qo_3}{Q}^\text{case1}\rightarrow\left[\begin{array}{cc:c}{I}_{3\times 3} &amp; {0}_{3\times 3} &amp; -g(t_1)/\theta(t_1) \\{0}_{3\times 3} &amp; {I}_{3\times 3} &amp; -\deltav^\text{const}/\ell\\\hdashline{0}_{6(k-1)\times 3} &amp; {0}_{6(k-1)\times 3} &amp; {0}_{6(k-1)\times1}\end{array}\right].\end{aligned}\]</span> Since the upper <spanclass="math inline">\(6\times7\)</span> block of <a href="#eq_Qo_3"data-reference-type="eqref" data-reference="eq_Qo_3">[eq_Qo_3]</a> hasfull row rank and the lower block is zero, the rank of <spanclass="math inline">\({Q}^\text{case1}\)</span> is <spanclass="math display">\[\begin{aligned}\text{rank}\left({Q}^\text{case1}\right) = 6.\end{aligned}\]</span> Since the number of states is seven and the rankis six, we know there is <em>one unobservable mode</em>. To identifythis unobservable mode, we calculate the unobservable subspace, which isthe null space of <span class="math inline">\({Q}\)</span>: <spanclass="math display">\[\begin{aligned}\label{eq_unobservable_subspace}\text{Null}\left({Q}^\text{case1}\right) = \text{span}\left\{\begin{bmatrix}g(t_1)/\theta(t_1)  \\\deltav^\text{const}/\ell \\1\end{bmatrix}\right\}.\end{aligned}\]</span> According to <a href="#eq_unobservable_subspace"data-reference-type="eqref"data-reference="eq_unobservable_subspace">[eq_unobservable_subspace]</a>,the unobservable mode is <span class="math display">\[\begin{aligned}x^T\left[\begin{array}{c}g(t_1)/\theta(t_1)  \\\deltav^\text{const}/\ell \\1\end{array}\right]=p_T^\mathrm{T}\dfrac{g(t_1)}{\theta(t_1)}+v_T^\mathrm{T}\dfrac{\deltav^\text{const}}{\ell} + \ell.\label{eq_unobservable_mode}\end{aligned}\]</span> Although there is only one unobservable mode,this mode given in <a href="#eq_unobservable_mode"data-reference-type="eqref"data-reference="eq_unobservable_mode">[eq_unobservable_mode]</a>involves all the states including the target's position, velocity, andphysical size. It suggests that the estimation of the three quantitiesis coupled. In conclusion, we know that, if the target moves with aconstant velocity, its states are unobservable when the observer moveswith a constant velocity.</p><h2 id="case-2-the-observers-velocity-is-time-varying">Case 2: theobserver's velocity is time-varying</h2><p>We now consider the case where the observer has nonzero accelerationso that its velocity is time-varying across the time horizon from <spanclass="math inline">\(t_1\)</span> to <spanclass="math inline">\(t_k\)</span>.</p><p>Denote <span class="math inline">\({a}_o(t_i)\in\mathbb{R}\)</span>as the observer's acceleration, which can be approximated as <spanclass="math display">\[\begin{aligned}\label{eq_acc}{a}_o(t_i) &amp;\approx\dfrac{v_o(t_i) - v_o(t_{i-1})}{\delta t} \nonumber\\&amp;=-\dfrac{\left[v_T^\text{const} - v_o(t_i)\right] -\left[v_T^\text{const} - v_o(t_{i-1})\right]}{\delta t} \nonumber\\&amp;=-\dfrac{\delta v(t_i) - \delta v(t_{i-1})}{\delta t}.\end{aligned}\]</span> Substituting <a href="#eq_acc"data-reference-type="eqref" data-reference="eq_acc">[eq_acc]</a> into <ahref="#eq_Qo_2" data-reference-type="eqref"data-reference="eq_Qo_2">[eq_Qo_2]</a> and performing elementary rowtransformation yields <span class="math display">\[\begin{aligned}\label{eq_Q_case2_final}{Q}^\text{case2}\rightarrow\left[\begin{array}{ccc}{I}_{3\times 3} &amp; {0}_{3\times 3} &amp; -g(t_1)/\theta(t_1) \\{0}_{3\times 3} &amp; {I}_{3\times 3} &amp; -\deltav(t_2)/\ell \\{0}_{3\times 3} &amp; {0}_{3\times 3} &amp; \delta t {a}_o(t_3)/\ell \\\hdashline\vdots &amp; \vdots &amp;\vdots \\{0}_{3\times 3} &amp; {0}_{3\times 3} &amp; \delta t {a}_o(t_k)/\ell \\{0}_{3k\times 3} &amp; {0}_{3k\times 3} &amp; {0}_{3k\times 1}\end{array}\right].\end{aligned}\]</span> The upper <spanclass="math inline">\(6\times7\)</span> block in <ahref="#eq_Q_case2_final" data-reference-type="eqref"data-reference="eq_Q_case2_final">[eq_Q_case2_final]</a> has full columnrank. Therefore, if <span class="math inline">\(a_o(t_i)\ne0\)</span>for any <span class="math inline">\(i\geq3\)</span>, then <spanclass="math display">\[\begin{aligned}\text{rank}\left({Q}^\text{case2}\right) = 7,\end{aligned}\]</span> Which is the same as the number of estimatedstates. Therefore, the target's state is observable when the observermoves with nonzero acceleration.</p><h2 id="summary-of-this-section">Summary of this section</h2><p>From the above analysis, we know that when the target has a constantvelocity, its states including its position, velocity, and physical sizeare observable if and only if the observer has non-zeroaccelerations.</p><p>The critical difference of this condition from the bearing-only caseis that the target's states are still observable <em>even if theobserver moves along the bearing vector</em> towards or backward thetarget. By contrast, for a bearing-only estimator, moving along thebearing vector is insufficient to recover the target's motion.Therefore, the additional lateral motion of the observer required in thebearing-only case is <em>not</em> required in the bearing-angle caseanymore, which provides better flexibility for designing the observer'smotion.</p><h1id="observability-analysis-by-solving-linear-equations">ObservabilityAnalysis by Solving Linear Equations</h1><p>This section extends the observability condition obtained in the lastsection to more general cases where the target's velocity does not haveto be constant.</p><h2 id="problem-formulation-1">Problem formulation</h2><p>The observability problem that we aim to solve is to determinewhether <span class="math inline">\(p_T(t)\)</span> can be recoveredfrom <span class="math inline">\(p_o(t)\)</span> and <spanclass="math inline">\(g(t),\theta(t)\)</span>.</p><p>Suppose the target's motion can be described by an <spanclass="math inline">\(n\)</span>th-order polynomial during a timeinterval: <span class="math display">\[\begin{aligned}\label{eq_target_nth_Order}    p_T(t)={b}_0+{b}_1t+\cdots+{b}_nt^n,\end{aligned}\]</span> where <span class="math inline">\({b}_0, {b}_1,\cdots, {b}_n\in\mathbb{R}^3\)</span> are unknown constant vectors. Ifwe can determine the values of <spanclass="math inline">\(\{b_i\}_{i=0}^n\)</span>, then we can determinethe target's motion and hence it is observable. Although polynomialscannot represent all trajectories, they can effectively approximate amajority of them according to the method of Taylor expansion. This isespecially true if we consider a short time horizon. This kind oftechnique has been adopted in the observability analysis of bearing-onlytarget motion estimation tasks <span class="citation"data-cites="Nardone1981 Lee2010">[@Nardone1981; @Lee2010]</span>.</p><p>Suppose the observer's motion is described by <spanclass="math display">\[\begin{aligned}    p_o(t)={c}_0+{c}_1t+\cdots+{c}_nt^n+{h}(t),\end{aligned}\]</span> where <span class="math inline">\({c}_0, {c}_1,\cdots, {c}_n\in\mathbb{R}^3\)</span> are constant parameters, and <spanclass="math display">\[\begin{aligned}\label{eq_definition_h}{h}(t) = {d}_1 t^{n+1}+{d}_2t^{n+2}+\cdots\end{aligned}\]</span> represents <em>higher-order</em> motion with<span class="math inline">\({d}_1, {d}_2,\cdots\in\mathbb{R}^3\)</span>. It can be verified that the derivativesof <span class="math inline">\({h}(t)\)</span> satisfy <spanclass="math inline">\({h}^{(i)}(0)={0}_{3\times 1}\)</span> for <spanclass="math inline">\(i=0,1,\cdots, n\)</span>. Let <spanclass="math inline">\({s}(t)\in\mathbb{R}^3\)</span> be the relativemotion between the target and the observer: <spanclass="math display">\[\begin{aligned}\label{eq_relative_motion}    {s}(t)&amp;\doteqp_T(t)-p_o(t)  \nonumber\\    &amp;\doteq{s}_0+{s}_1t+\cdots+{s}_nt^n+{h}(t),\end{aligned}\]</span> where <span class="math inline">\({s}_i = {d}_i -{c}_i\in\mathbb{R}^3\)</span> for <span class="math inline">\(i =0,1,\cdots, n\)</span>.</p><p>If we can determine <spanclass="math inline">\(\{s_i\}_{i=0}^n\)</span>, then <spanclass="math inline">\(s(t)\)</span> and hence <spanclass="math inline">\(p_T(t)\)</span> can be determined. Therefore, wenext study under what conditions <spanclass="math inline">\(\{s_i\}_{i=0}^n\)</span> can be uniquelydetermined. Since <spanclass="math inline">\(p_T(t)-p_o(t)=g(t)r(t)\)</span> according to <ahref="#eq_bearing_measure" data-reference-type="eqref"data-reference="eq_bearing_measure">[eq_bearing_measure]</a> and <spanclass="math inline">\(r(t)=\ell/\theta(t)\)</span> according to <ahref="#eq_theta_measure" data-reference-type="eqref"data-reference="eq_theta_measure">[eq_theta_measure]</a>, we have <spanclass="math display">\[s(t)=p_T(t)-p_o(t)=g(t)r(t)=\frac{g(t)}{\theta(t)}\ell.\]</span>Substituting the above equation into <a href="#eq_relative_motion"data-reference-type="eqref"data-reference="eq_relative_motion">[eq_relative_motion]</a> yields<span class="math display">\[\begin{aligned}\label{eq_st_tem}{s}_0+{s}_1t+\cdots+{s}_nt^n+{h}(t)=\frac{g(t)}{\theta(t)}\ell.\end{aligned}\]</span> Here, <span class="math inline">\({s}_0, \cdots,{s}_n, \ell\)</span> are unknowns to be determined and <spanclass="math inline">\(g(t),\theta(t),{h}(t)\)</span> are known.Equation <a href="#eq_st_tem" data-reference-type="eqref"data-reference="eq_st_tem">[eq_st_tem]</a> can be reorganized to alinear equation: <span class="math display">\[\begin{aligned}\label{eq_linear_equations}    {A}(t){X} = {h}(t),\end{aligned}\]</span> where <spanclass="math display">\[\begin{aligned}{X}&amp;=\begin{bmatrix}{s}_0^\mathrm{T}, {s}_1^\mathrm{T}, \cdots, {s}_n^\mathrm{T}, \ell\end{bmatrix}^\mathrm{T}\in\mathbb{R}^{3n+4},\end{aligned}\]</span> and <span class="math display">\[\begin{aligned}\label{eq_original_A}{A}(t)&amp;=\begin{bmatrix}{I}_{3\times3}, t{I}_{3\times3}, \cdots, t^n{I}_{3\times3}, \rho(t)\end{bmatrix}\in\mathbb{R}^{3\times(3n+4)},\end{aligned}\]</span> where <spanclass="math display">\[\begin{aligned}\label{eq_rho_denote}\rho(t)&amp;\doteq-\dfrac{g(t)}{\theta(t)}\in\mathbb{R}^3.\end{aligned}\]</span> Therefore, the problem that we aim to solvebecomes determining whether <span class="math inline">\(X\)</span> canbe uniquely solved from <a href="#eq_linear_equations"data-reference-type="eqref"data-reference="eq_linear_equations">[eq_linear_equations]</a>.</p><h2 id="necessary-and-sufficient-observability-condition">Necessary andsufficient observability condition</h2><p>We next present a necessary and sufficient condition under which thesolution <span class="math inline">\(X\)</span> of <ahref="#eq_linear_equations" data-reference-type="eqref"data-reference="eq_linear_equations">[eq_linear_equations]</a> isunique.</p><p><Theorem id="theorem_observability_confition "></Theorem><strong>Theorem 1.</strong> ((Necessary and sufficient observabilitycondition)). <em>The target's motion <spanclass="math inline">\(p_T(t)\)</span> can be uniquely determined by theobserver's motion <span class="math inline">\(p_o(t)\)</span>, thebearing <span class="math inline">\(g(t)\)</span>, and the angle <spanclass="math inline">\(\theta(t)\)</span> if and only if <spanclass="math display">\[\begin{aligned}{h}(t)\neq{0}_{3\times1},\end{aligned}\]</span> which means that the order of the observer'smotion must be greater than the target.</em></p><p>Since the row number of <span class="math inline">\({A}(t)\)</span>is less than its column number, <a href="#eq_linear_equations"data-reference-type="eqref"data-reference="eq_linear_equations">[eq_linear_equations]</a> is anunder-determined system whose solution cannot be uniquely determined.However, in the continuous time domain, we can use additional higherderivatives of this equation to uniquely determine <spanclass="math inline">\(X\)</span>.</p><p>In particular, taking the <spanclass="math inline">\(i\)</span>th-order derivative on both sides of <ahref="#eq_linear_equations" data-reference-type="eqref"data-reference="eq_linear_equations">[eq_linear_equations]</a> gives<span class="math inline">\(A^{(i)}(t)X=h^{(i)}(t)\)</span>. Considerany integer <span class="math inline">\(N\)</span> satisfying <spanclass="math inline">\(N\ge n+1\)</span>. Combining the equations with<span class="math inline">\(i\in\{0,1,\dots,N\}\)</span> gives <spanclass="math display">\[\begin{aligned}\label{eq_new_linear_equtions}    \bar(t){X} = \bar(t),\end{aligned}\]</span> where <spanclass="math display">\[\begin{aligned}\label{eq_new_A}    \bar(t) =\left[  \begin{array}{c}    {A}(t) \\    {A}^{&#39;}(t) \\    \vdots \\    {A}^{(N)}(t)  \end{array}\right],\qquad\bar(t)\left[  \begin{array}{c}    {h}(t)\\    {h}^{&#39;}(t)\\    \vdots\\    {h}^{(N)}(t)\\  \end{array}\right].\end{aligned}\]</span> Here, <spanclass="math inline">\(\bar(t)\in\mathbb{R}^{(3N+3)\times(3n+4)}\)</span> and <spanclass="math inline">\(\bar(t)\in\mathbb{R}^{3N+3}\)</span>.Since <span class="math inline">\(N\ge n+1\)</span>, <spanclass="math inline">\(\bar{A}(t)\)</span> is a tall matrix and <ahref="#eq_new_linear_equtions" data-reference-type="eqref"data-reference="eq_new_linear_equtions">[eq_new_linear_equtions]</a> isan over-determined system.</p><p>We next examine when <span class="math inline">\(\bar{A}(t)\)</span>has full column rank. Substituting <a href="#eq_original_A"data-reference-type="eqref"data-reference="eq_original_A">[eq_original_A]</a> into <spanclass="math inline">\(\bar{A}(t)\)</span> yields <spanclass="math display">\[\begin{aligned}\bar(t)=    \left[\begin{array}{cccc:c}    {I}_{3\times3}&amp; t{I}_{3\times3}&amp; \cdots&amp;t^n{I}_{3\times3}&amp; \rho(t) \\    {0}_{3\times3}&amp; {I}_{3\times3}&amp; \cdots&amp;nt^{n-1}{I}_{3\times3}&amp; \rho^{&#39;}(t) \\    \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\    {0}_{3\times3}&amp; {0}_{3\times3}&amp; \cdots&amp;n!{I}_{3\times3}&amp; \rho^{(n)}(t) \\    \hdashline    {0}_{3\times3}&amp; {0}_{3\times3}&amp; \cdots&amp;{0}_{3\times3}&amp; \rho^{(n+1)}(t) \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots  \\{0}_{3\times3}&amp; {0}_{3\times3}&amp; \cdots&amp; {0}_{3\times3}&amp;\rho^{(N)}(t) \\%\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots  \\    \end{array}\right].\end{aligned}\]</span> Since the top-left block of <spanclass="math inline">\(\bar{A}(t)\)</span> is a full-rank square matrix,<span class="math inline">\(\bar(t)\)</span> hasfull column rank if and only if there exists <spanclass="math inline">\(i\in\{n+1,\dots,N\}\)</span> such that <spanclass="math display">\[\begin{aligned}\label{eq_observability_criteria_2}    \rho^{(i)}(t)\neq {0}_{3\times1}.\end{aligned}\]</span> Since <spanclass="math inline">\(\rho(t)=-g(t)/\theta(t)\)</span> as shown in <ahref="#eq_rho_denote" data-reference-type="eqref"data-reference="eq_rho_denote">[eq_rho_denote]</a> and <spanclass="math inline">\(g(t)/\theta(t)=({s}_0+{s}_1t+\cdots+{s}_nt^n+{h}(t))/\ell\)</span>as shown in <a href="#eq_st_tem" data-reference-type="eqref"data-reference="eq_st_tem">[eq_st_tem]</a>, we can rewrite <ahref="#eq_observability_criteria_2" data-reference-type="eqref"data-reference="eq_observability_criteria_2">[eq_observability_criteria_2]</a>to <span class="math display">\[\begin{aligned}\label{eq_critia_2}-\dfrac{1}{\ell}({s}_0+{s}_1t+\cdots+{s}_nt^n+{h}(t))^{(i)}\neq{0}_{3\times1}.\end{aligned}\]</span> Since <span class="math inline">\(i\gen+1\)</span>, <a href="#eq_critia_2" data-reference-type="eqref"data-reference="eq_critia_2">[eq_critia_2]</a> is equivalent to <spanclass="math display">\[\begin{aligned}\label{eq_observability_criteria_final}{h}^{(i)} (t) \neq {0}_{3\times1}.\end{aligned}\]</span> According to the definition of <spanclass="math inline">\({h}(t)\)</span> in <a href="#eq_definition_h"data-reference-type="eqref"data-reference="eq_definition_h">[eq_definition_h]</a>, the condition in<a href="#eq_observability_criteria_final" data-reference-type="eqref"data-reference="eq_observability_criteria_final">[eq_observability_criteria_final]</a>is equivalent to <span class="math display">\[\begin{aligned}{h}(t)\neq {0}_{3\times1}.\end{aligned}\]</span> The proof is complete.</p><p>Some important remarks about Theorem <ahref="#theorem_observability_confition" data-reference-type="ref"data-reference="theorem_observability_confition">1</a> are givenbelow.</p><p>1) The necessary and sufficient condition suggested by Theorem <ahref="#theorem_observability_confition" data-reference-type="ref"data-reference="theorem_observability_confition">1</a> is that theobserver should have higher-order motion than the target. For example,when the target is stationary, the observer should move with a nonzerovelocity. When the target moves with a constant velocity, the observershould move with a nonzero acceleration.</p><p>2) The necessary and sufficient condition given by Theorem <ahref="#theorem_observability_confition" data-reference-type="ref"data-reference="theorem_observability_confition">1</a> has a <em>keydifference</em> from the bearing-only case that the higher-order motionin the bearing-angle case is <em>not</em> required to be orthogonal tothe bearing vector, making the bearing-angle approach more flexible thanthe bearing-only one. For example, the bearing-angle approach canestimate the target's motion even if the observer simply moves along thebearing vector.</p><p>3) In the special case where the target moves with a constantvelocity, the condition in Theorem <ahref="#theorem_observability_confition" data-reference-type="ref"data-reference="theorem_observability_confition">1</a> is consistentwith the one obtained in Section <ahref="#Observability%20Analysis%20by%20Kalman&#39;s%20Criterion"data-reference-type="ref"data-reference="Observability Analysis by Kalman&#39;s Criterion">5</a>.Although the condition in Theorem <ahref="#theorem_observability_confition" data-reference-type="ref"data-reference="theorem_observability_confition">1</a> allows moregeneral target motion, the analysis in Section <ahref="#Observability%20Analysis%20by%20Kalman&#39;s%20Criterion"data-reference-type="ref"data-reference="Observability Analysis by Kalman&#39;s Criterion">5</a>is still meaningful since it is directly related to the dynamic modelused in the pseudo-linear Kalman filter.</p><p>4) In practice, we would not estimate the target's motion by usingthe method of solving an equation like <a href="#eq_new_linear_equtions"data-reference-type="eqref"data-reference="eq_new_linear_equtions">[eq_new_linear_equtions]</a>.That is because such a method involves calculating high-orderderivatives, which are challenging to obtain accurately in practice. Therole of this equation is to provide a fundamental perspective on whetherthere is sufficient information to uniquely recover the target'smotion.</p><h2 id="number-of-observations-required">Number of observationsrequired</h2><div class="figure*"><p><span class="math display">\[\begin{aligned}\label{eq_A_22}\tilde{A}\rightarrow\left[\begin{array}{ccccc:c}{I} &amp; t_1{I} &amp; \cdots &amp; t_1^{n-1}{I} &amp; t_1^n{I} &amp;\rho(t_1) \\{0} &amp; {I} &amp; \cdots &amp; {\Delta(t_2^{n-1}, t_1^{n-1})}{I} &amp;{\Delta(t_2^n, t_1^n)}{}{I} &amp; {\Delta(\rho(t_2),\rho(t_1) )}{} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots &amp; \vdots\\{0} &amp; {0} &amp; \cdots &amp; (n-1)!{I} &amp; {\Delta^{n-1}(t_n^n,\cdots , t_1^n)}{} &amp; {\Delta^{n-1}(\rho(t_n),\cdots,\rho(t_1) )}{}\\{0} &amp; {0} &amp; \cdots &amp; {0} &amp; n!{I}&amp;  {\Delta^{n}(\rho(t_{n+1}),\cdots,\rho(t_1) )}{} \\\hdashline{0} &amp; {0} &amp; \cdots &amp; {0} &amp; {0} &amp;{\Delta^{n+1}(\rho(t_{n+2}),\cdots,\rho(t_1) )}{} \\\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp;\vdots  \\{0} &amp; {0} &amp; \cdots &amp; {0} &amp; {0} &amp;{\Delta^{N-1}(\rho(t_N),\cdots,\rho(t_1) )}{} \\\end{array}\right]\end{aligned}\]</span></p></div><p>It is of practical importance to study how many discrete observationsare required to recover the target's motion. Although Theorem <ahref="#theorem_observability_confition" data-reference-type="ref"data-reference="theorem_observability_confition">1</a> gives anobservability condition, it does not answer this question because it isbased on the continuous time domain. We next answer this question byexploring multiple discrete time steps.</p><p><Theorem id="theorem_observation_number"></Theorem> <strong>Theorem2.</strong> ((Number of discrete observations)). <em>If the observer'smotion satisfies the observability condition in Theorem <ahref="#theorem_observability_confition" data-reference-type="ref"data-reference="theorem_observability_confition">1</a>, it is necessaryand sufficient to use at least <span class="math inline">\(n+2\)</span>observations to recover the target's motion. Here, <spanclass="math inline">\(n\)</span> is the order of the target's polynomialmotion as shown in <a href="#eq_target_nth_Order"data-reference-type="eqref"data-reference="eq_target_nth_Order">[eq_target_nth_Order]</a>.</em></p><p>Consider <span class="math inline">\(t_1,\dots,t_N\)</span> timeinstances. Each time instance corresponds to an equation like <ahref="#eq_linear_equations" data-reference-type="eqref"data-reference="eq_linear_equations">[eq_linear_equations]</a>: <spanclass="math inline">\({A}(t_i){X} = {h}(t_i)\)</span> for <spanclass="math inline">\(i=1,\dots,N\)</span>. Combining these equationsgives <span class="math display">\[\begin{aligned}\label{eq_convergence_linear_eqs}\tilde{X}=\tilde,\end{aligned}\]</span> where <spanclass="math display">\[\begin{aligned}\label{eq_new_A_2}    \tilde =\left[  \begin{array}{c}    {A}(t_1) \\    \vdots \\    {A}(t_N)  \end{array}\right],\qquad\tilde\left[  \begin{array}{c}    {h}(t_1)\\    \vdots\\    {h}(t_N)\\  \end{array}\right].\end{aligned}\]</span> Here, <spanclass="math inline">\(\tilde\in\mathbb{R}^{(3N)\times (3n+4)}\)</span> and <spanclass="math inline">\(\tilde\in\mathbb{R}^{3N}\)</span>.</p><p>(<em>Necessity</em>) Since <spanclass="math inline">\(X\in\mathbb{R}^{3n+4}\)</span>, we need at least<span class="math inline">\(N\ge n+2\)</span> observations so that <spanclass="math inline">\(\tilde\)</span> is a tallmatrix and hence <a href="#eq_convergence_linear_eqs"data-reference-type="eqref"data-reference="eq_convergence_linear_eqs">[eq_convergence_linear_eqs]</a>is an over-determined system.</p><p>(<em>Sufficiency</em>) Suppose we have <spanclass="math inline">\(N\ge n+2\)</span> discrete observations.Substituting <a href="#eq_original_A" data-reference-type="eqref"data-reference="eq_original_A">[eq_original_A]</a> into <ahref="#eq_new_A_2" data-reference-type="eqref"data-reference="eq_new_A_2">[eq_new_A_2]</a> yields <spanclass="math display">\[\begin{aligned}\tilde{A} =\begin{bmatrix}{I}_{3\times 3} &amp; t_1{I}_{3\times 3} &amp; \cdots &amp;t_1^n{I}_{3\times 3} &amp; \rho(t_1) \\{I}_{3\times 3} &amp; t_2{I}_{3\times 3} &amp; \cdots &amp;t_2^n{I}_{3\times 3} &amp; \rho(t_2)  \\\vdots &amp; \vdots &amp;&amp; \vdots &amp; \vdots  \\{I}_{3\times 3} &amp; t_{n+1}{I}_{3\times 3} &amp; \cdots &amp;t_{n+1}^n{I}_{3\times 3} &amp; \rho(t_{n+1}) \\{I}_{3\times 3} &amp; t_{n+2}{I}_{3\times 3} &amp; \cdots &amp;t_{n+2}^n{I}_{3\times 3} &amp; \rho(t_{n+2})\\\vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \vdots\\{I}_{3\times 3} &amp; t_{N}{I}_{3\times 3} &amp; \cdots &amp;t_{N}^n{I}_{3\times 3} &amp; \rho(t_{N})\\\end{bmatrix}.\end{aligned}\]</span> Starting from the last line in <spanclass="math inline">\(\tilde{A}\)</span>, subtract the previous linefrom each subsequent line, and repeat this process. Finally, we canobtain <a href="#eq_A_22" data-reference-type="eqref"data-reference="eq_A_22">[eq_A_22]</a> (the equation is too long andlocated at the top of another page). Here, <spanclass="math inline">\(\Delta^n\)</span> represents the <spanclass="math inline">\(n\)</span>th-order time difference <spanclass="citation"data-cites="MilneThomson2000">[@MilneThomson2000]</span>. For example,<span class="math inline">\(\Delta (a_2, a_1)=(a_2-a_1)/\deltat\)</span>, <span class="math inline">\(\Delta^2 (a_3, a_2, a_1) =\Delta (\Delta(a_3, a_2), \Delta(a_2, a_1))=[(a_3-a_2)/\deltat-(a_2-a_1)/\delta t]/\delta t\)</span>. When <spanclass="math inline">\(\delta t\)</span> is sufficiently small, the timedifference is an approximation of the derivative. When the observabilitycondition in Theorem <a href="#theorem_observability_confition"data-reference-type="ref"data-reference="theorem_observability_confition">1</a> is satisfied,there exists <span class="math inline">\(i\ge n+1\)</span> such that<span class="math inline">\(\rho^{(i)}(t)\neq 0\)</span> as shown in <ahref="#eq_observability_criteria_2" data-reference-type="eqref"data-reference="eq_observability_criteria_2">[eq_observability_criteria_2]</a>.As a result, there exists <span class="math inline">\(i\ge n+1\)</span>such that <span class="math display">\[\begin{aligned}\Delta^{i}(\rho(t_{i+1}),\cdots,\rho(t_1))\neq {0}.\end{aligned}\]</span> The above implication is valid because <spanclass="math inline">\(\Delta^{i}\)</span> is an approximation of the<span class="math inline">\(i\)</span>th-order derivative when <spanclass="math inline">\(\delta t\)</span> is sufficiently small. Then,<span class="math inline">\(\tilde{A}\)</span> in <a href="#eq_A_22"data-reference-type="eqref" data-reference="eq_A_22">[eq_A_22]</a> hasfull column rank and hence <a href="#eq_convergence_linear_eqs"data-reference-type="eqref"data-reference="eq_convergence_linear_eqs">[eq_convergence_linear_eqs]</a>has a unique solution.</p><p>Theorem <a href="#theorem_observation_number"data-reference-type="ref"data-reference="theorem_observation_number">2</a> suggests that when thetarget is stationary and hence <span class="math inline">\(n=0\)</span>,at least two discrete observations are sufficient to localize thetarget. This is true even if the two observations are acquired when theobserver moves along the bearing vector. When the target moves with aconstant velocity and hence <span class="math inline">\(n=1\)</span>, atleast three discrete observations are sufficient to localize the target,which is consistent with the results in Section <ahref="#Observability%20Analysis%20by%20Kalman&#39;s%20Criterion"data-reference-type="ref"data-reference="Observability Analysis by Kalman&#39;s Criterion">5</a>.</p><h1 id="numerical-simulation-results">Numerical Simulation Results</h1><figure id="sec_matlab_simulation">  <figure id="fig_matlab_1"></figure>  <img src="https://picture.adunas.top/Article/arXiv-2401.17117v1/fig_matlab_1.png" />  <figcaption><b>(a)</b> Scenario 1: Circular motion around the target. Both the bearing-only and bearing-angle approaches work well, but the bearing-angle one converges faster.</figcaption>  <figure id="fig_matlab_2"></figure>  <img src="https://picture.adunas.top/Article/arXiv-2401.17117v1/fig_matlab_2.png" />  <figcaption><b>(b)</b> Scenario 2: Straight motion towards and backwards the target. The bearing-only approach fails, but the bearing-angle approach works effectively.</figcaption>  <figure id="fig_matlab_3"></figure>  <img src="https://picture.adunas.top/Article/arXiv-2401.17117v1/fig_matlab_3.png" />  <figcaption><b>(c)</b> Scenario 3: Approaching the target by a guidance law. The bearing-only approach works unstably, but the bearing-angle approach works effectively.</figcaption><figcaption><b>Figure 4.</b> Numerical simulation results based on 100 Monte Carlo runs in three scenarios.</figcaption></figure><figure id="fig_matlab_varying_ell">  <figure id="fig_cam_rotate"></figure>  <img src="https://picture.adunas.top/Article/arXiv-2401.17117v1/fig_matlab_4.png" />  <figcaption><b>(a)</b> The observer moves around the square-shaped target. The target spins rapidly at $2\pi$~rad/s.</figcaption>  <figure id="fig_matlab_pi_8"></figure>  <img src="https://picture.adunas.top/Article/arXiv-2401.17117v1/fig_matlab_pi_8.png" />  <figcaption><b>(c)</b>The observer moves along the bearing vector. The target's spinning speed is $\pi/8$~rad/s.</figcaption><figcaption><b>Figure 5.</b> Numerical simulation results for time-varying $\ell$.</figcaption></figure><p>This section presents a set of numerical simulation results todemonstrate the effectiveness of the proposed bearing-angleapproach.</p><p>The values of the parameters in two estimators are selected as <spanclass="math inline">\(\sigma_v=10^{-3}\)</span>, <spanclass="math inline">\(\sigma_l=10^{-4}\)</span>, <spanclass="math inline">\(\sigma_\mu=0.01\)</span>, and <spanclass="math inline">\(\sigma_w=0.01\)</span>. The selection of thesevalues is inspired by the measurement noises obtained in the AirSimsimulation and real-world experiments as shown later. The initialcovariance matrix of the estimated states is set to <spanclass="math inline">\(P(t_0)=0.1I\)</span>. The target is a circle whosediameter is <span class="math inline">\(\ell=1\)</span>. The update rateof the system is <span class="math inline">\(50\)</span> Hz. Inaddition, we use the same parameter values across all the simulationexamples to verify the robustness of the algorithm. Better performancescan be achieved if the parameters are well-tuned for specific scenarios.We perform <span class="math inline">\(N_x=100\)</span> Monte Carlosimulations for each scenario.</p><p>We use the normalized-estimation error squared (NEES) <spanclass="citation"data-cites="bar1998estimation">[@bar1998estimation]</span> to analyzethe consistency of the estimation algorithms. In particular, the valueof the average NEES is</p><p><span class="math display">\[\begin{aligned}    \bar{\epsilon}_{\text{NEES}}=\dfrac{1}{N_x}\sum_{i=1}^{N_x}(x-\hat{x}_i)^\mathrm{T}P_i^{-1}(x-\hat{x}_i),    \label{eq_nees}\end{aligned}\]</span> where <spanclass="math inline">\(\hat{x}_i\)</span> is the estimated states in the<span class="math inline">\(i\)</span>th simulation, and <spanclass="math inline">\(P_i\)</span> is the covariance matrix obtainedfrom the estimator in the <span class="math inline">\(i\)</span>thsimulation.</p><p>Finally, image acquisition and visual detection are not considered inthese numerical simulation scenarios. They will be considered inSection <a href="#AirSim%20Simulation%20Results"data-reference-type="ref"data-reference="AirSim Simulation Results">8</a> and Section <ahref="#Real-World%20Experimental%20Results" data-reference-type="ref"data-reference="Real-World Experimental Results">9</a>.</p><h2 id="scenario-1-circular-motion-around-the-target">Scenario 1:Circular motion around the target</h2><p>In the first scenario, the target is stationary and located at <spanclass="math inline">\(p_T=[0, 10]^\mathrm{T}\)</span>. The observermoves on a circle centered at the target with the speed of <spanclass="math inline">\(3\)</span> m/s (see Fig. <a href="#fig_matlab_1"data-reference-type="ref"data-reference="fig_matlab_1">[fig_matlab_1]</a>). The radius of thecircle is <span class="math inline">\(5\)</span> m. The initialestimates are <span class="math inline">\(\hatp_o(t_0) = [0,13]^\mathrm{T}\)</span>, <span class="math inline">\(\hat{v_o}(t_0)=[0,0]^\mathrm{T}\)</span>, <spanclass="math inline">\(\hat{\ell}(t_0)=1.6\)</span>. During this process,the bearing vector varies while the angle subtended by the targetremains constant. The angle measurement varies slightly due to themeasurement noise. This scenario is favorable to the conventionalbearing-only approach because its observability condition that thetarget should be viewed from different angles is well satisfied <spanclass="citation" data-cites="Li2022">[@Li2022]</span>.</p><p>Fig. <a href="#fig_matlab_1" data-reference-type="ref"data-reference="fig_matlab_1">[fig_matlab_1]</a> shows the estimationresults by the two approaches of bearing-only and bearing-angle. As canbe seen, both algorithms perform well. The convergence of thebearing-angle approach is faster than the bearing-only one, as shown inthe middle and right subfigures of Fig. <a href="#fig_matlab_1"data-reference-type="ref"data-reference="fig_matlab_1">[fig_matlab_1]</a>, due to the additionalangle measurement. The bearing-angle approach can successfully estimatethe size of the target as shown in the right subfigure of Fig. <ahref="#fig_matlab_1" data-reference-type="ref"data-reference="fig_matlab_1">[fig_matlab_1]</a>.</p><h2id="scenario-2-straight-motion-towards-and-backwards-the-target-repeatedly">Scenario2: Straight motion towards and backwards the target repeatedly</h2><p>In the second scenario, the target is also stationary but theobserver moves along a straight line towards and backwards the targetrepeatedly (Fig. <a href="#fig_matlab_2" data-reference-type="ref"data-reference="fig_matlab_2">[fig_matlab_2]</a>). During this process,the bearing vector remains constant while the angle varies. Thisscenario is most challenging for the bearing-only approach because itsobservability condition is not fulfilled.</p><p>In this simulation scenario, the target is stationary and located at<span class="math inline">\(p_T(t_0)=[0, 10]^\mathrm{T}\)</span>. Theobserver moves along a straight line towards and backwards the targetwith a constant acceleration of <spanclass="math inline">\(-2\)</span> <spanclass="math inline">\(\text{m/s}^2\)</span>. The initial conditions are<span class="math inline">\(v_o(t_0)=[0, 4]^\mathrm{T}\)</span> and<span class="math inline">\(p_o (t_0)= [0,5]^\mathrm{T}\)</span>. Theinitial estimates are <span class="math inline">\(\hatp_o(t_0) = [0,8]^\mathrm{T}\)</span>, <span class="math inline">\(\hat{v_o}(t_0)=[0,0]^\mathrm{T}\)</span>, <spanclass="math inline">\(\hat{\ell}(t_0)=0.8\)</span>. In this scenario,the true bearing of the target relative to the observer remainsunchanged though the bearing measurement may vary slightly due to themeasurement noise.</p><p>Fig. <a href="#fig_matlab_2" data-reference-type="ref"data-reference="fig_matlab_2">[fig_matlab_2]</a> shows the estimationresults of the bearing-only and bearing-angle approaches. As can beseen, the bearing-only approach diverges since its observabilitycondition is not satisfied. By contrast, the proposed bearing-angleapproach converges, and is able to localize the target and estimate itssize, which demonstrates the strong observability of the bearing-angleapproach. One may notice that the estimated size and the NEES value getworse first before converging. This is because the noise level of theangle is set to be constant. Since the angle is small in the beginning,the noise-angle ratio is large, causing a relatively large NEESvalue.</p><div class="figure*"></div><div class="figure*"><figure><img src="fig_box_airsim" alt="image" /><figcaption aria-hidden="true">image</figcaption></figure></div><h2 id="scenario-3-approaching-the-target-by-a-guidance-law">Scenario 3:Approaching the target by a guidance law</h2><p>The third scenario is more complex than the first two. Here, thetarget moves with a constant velocity where the observer is controlledby a proportional navigation guidance (PNG) law to approach the target(Fig. <a href="#fig_matlab_3" data-reference-type="ref"data-reference="fig_matlab_3">[fig_matlab_3]</a>). During this process,both the bearing and angle vary. This scenario is also challenging forthe bearing-only approach because its observability is weak due to thefact that the lateral motion of the observer is small. Many researchershave studied how to add extra control commands to the PNG to enhance theobservability based on the bearing-only approach <span class="citation"data-cites="Song1996 Seo2015 Lee2015">[@Song1996; @Seo2015;@Lee2015]</span>.</p><p>In this simulation scenario, the target moves along a straight linewith a constant velocity <span class="math inline">\(v_T=[1/\sqrt{2},1/\sqrt{2}]^\mathrm{T}\)</span>. The observer's velocity magnitude isconstantly <span class="math inline">\(3\)</span> m/s while the velocitydirection is controlled by a PNG law. The navigation gain of the PNG lawis selected as one. The initial estimates of the target's states are thesame as Scenario 1. The simulation stops just before the observercollides with the target.</p><p>Fig. <a href="#fig_matlab_3" data-reference-type="ref"data-reference="fig_matlab_3">[fig_matlab_3]</a> shows the estimationresults by the bearing-only and bearing-angle approaches. As can beseen, the bearing-angle algorithm successfully converges before thecollision occurs, but the bearing-only algorithm fails to estimate thetarget's states due to its weak observability. This simulation exampledemonstrates that the bearing-angle algorithm can be used directly inthe guidance scenario without extra maneuvers required by thebearing-only approach <span class="citation"data-cites="Song1996 Seo2015 Lee2015">[@Song1996; @Seo2015;@Lee2015]</span>.</p><h2 id="simulation-results-for-time-varying-ell">Simulation results fortime-varying <span class="math inline">\(\ell\)</span></h2><p>Although <span class="math inline">\(\ell\)</span> is assumed to beinvariant, it is meaningful to challenge the proposed bearing-angleapproach by considering time-varying <spanclass="math inline">\(\ell\)</span>. We will see through simulationexamples that the bearing-angle approach is still effective when <spanclass="math inline">\(\ell\)</span> varies slowly. It becomes unstablewhen <span class="math inline">\(\ell\)</span> varies rapidly since theassumption of invariant <span class="math inline">\(\ell\)</span> isseverely invalid.</p><p>Suppose that the target object has a square shape. Then, <spanclass="math inline">\(\ell\)</span> varies when the object is observedfrom different viewing angles or the object spins. Fig. <ahref="#fig_matlab_4" data-reference-type="ref"data-reference="fig_matlab_4">[fig_matlab_4]</a> shows a scenario wherethe observer moves around the target, whose spinning speed is <spanclass="math inline">\(2\pi\)</span> rad/s. The red curve in the rightsubfigure represents the true value of <spanclass="math inline">\(\ell\)</span>, which varies rapidly. As can beseen, the bearing-angle algorithm works effectively though there is asmall estimation bias. Fig. <a href="#fig_matlab_pi_8"data-reference-type="ref"data-reference="fig_matlab_pi_8">[fig_matlab_pi_8]</a> shows a scenariowhere the observer moves along the bearing vector. The spinning speed ofthe target object is <span class="math inline">\(\pi/8\)</span> rad/s.As can be seen, the bearing-only approach diverges due to the lack ofobservability. The bearing-angle algorithm can still converge since<span class="math inline">\(\ell\)</span> varies slowly. When we furtherincrease the spinning speed of the target, the bearing-angle algorithmwill also diverge because the algorithm cannot distinguish whether thechange of <span class="math inline">\(\theta\)</span> is caused by thechange of <span class="math inline">\(\ell\)</span> or the change of<span class="math inline">\(r\)</span>.</p><h1 id="airsim-simulation-results">AirSim Simulation Results</h1><p>In this section, we show simulation results under a more realisticsetup. In particular, the simulation is based on AirSim, a simulatorthat can provide high-quality visual simulation <span class="citation"data-cites="Shah2017">[@Shah2017]</span>. Nonlinear MAV dynamics andcontrol are also considered.</p><div class="figure*"></div><h2 id="simulation-setup">Simulation setup</h2><div class="figure*"></div><p>Fig. <a href="#fig_architecture_airsim" data-reference-type="ref"data-reference="fig_architecture_airsim">[fig_architecture_airsim]</a>shows an AirSim simulation scenario. As can be seen, there are twoflying quadcopter MAVs. The observer MAV can capture images of thetarget MAV using its simulated onboard camera. A simple gimbal cameracontroller is implemented so that the target MAV is always locatedinside the field of view of the camera. The visual environment used inthe simulation is called Landscape Mountains, which includes realisticmountains, lakes, trees, and roads. Other environments can also be usedif needed.</p><p>The bearing and angle measurements are obtained from the boundingboxes generated by a Yolo-based detection algorithm. A tiny-YOLO v4network <span class="citation"data-cites="Bochkovskiy2020">[@Bochkovskiy2020]</span> is trained todetect the target MAV in the images. Although the visual detector can bereplaced by other state-of-the-art ones, the tiny-YOLO v4 network isalready sufficient to verify our proposed approach. The architecture ofthe entire simulation system is shown in Fig. <a href="#fig_box_airsim"data-reference-type="ref"data-reference="fig_box_airsim">[fig_box_airsim]</a>. The systemconsists of the modules of automatic image dataset collection,Yolo-based target detection, gimbal camera control, nonlinear quadcopterdynamics, and quadcopter flight control. The quadcopter dynamics andflight control used in the simulation are similar to <spanclass="citation" data-cites="Meier2011 Shah2017">[@Meier2011;@Shah2017]</span> and omitted here due to space limitation. Thequadcopter's physical size varies slightly when viewed from differentdirections, although it is assumed to be invariant. All of these factorsmake the Airsim simulation more realistic and challenging.</p><h2 id="automatic-dataset-collection">Automatic dataset collection</h2><p>To train the Yolo-based detector, we developed a module toautomatically collect an image dataset. This module has some advantages.First, it is efficient. More than ten thousand labeled images can becollected automatically in 24 hours. Second, it is flexible. It canacquire images with random target's positions, random target'sattitudes, random camera's view angles, and random background scenes.These images are beneficial to achieve a good generalization ability ofthe detector. Third, the image labels are of high quality. Since theground truth of the target's image is known in the simulation, thegenerated bounding box is tight. The collected dataset contains 17,000labeled images (see Fig. <a href="#fig_airsim_dataset"data-reference-type="ref"data-reference="fig_airsim_dataset">[fig_airsim_dataset]</a>). Theresolution of the images is <span class="math inline">\(1536\times864\)</span> pixels. The simulation system was deployed on a DellPrecision 7920 Tower Workstation with two NVIDIA Quadro GV100 graphiccards. Since the dataset is sufficient and high-quality, the detectioncan achieve the accuracy of mAP=99.5%.</p><h2 id="scenario-1-approaching-and-following-the-target">Scenario 1:Approaching and following the target</h2><p>We first consider the scenarios where the observer MAV approaches orfollows a target MAV. These scenarios widely exist in practicalapplications such as aerial target pursuit.</p><p>We show two simulation examples in Fig. <a href="#fig_airsim_1"data-reference-type="ref"data-reference="fig_airsim_1">[fig_airsim_1]</a> and Fig. <ahref="#fig_airsim_2" data-reference-type="ref"data-reference="fig_airsim_2">[fig_airsim_2]</a>, respectively. In bothexamples, the observer is controlled by a controller so that it canapproach the target and maintain a desired separation. In particular,the controller is <span class="math display">\[\begin{aligned}\label{eq_tracking_control}v_o^\text{cmd}(t)&amp;=v_T(t)+k^\text{track}\dfrac{r^2(t)-r_d^2}{r^2(t)}g(t),\end{aligned}\]</span> where <spanclass="math inline">\(v_o^\text{cmd}(t)\)</span> is the velocity commandof the observer MAV, <spanclass="math inline">\(k^\text{track}=3\)</span> is the control gain, and<span class="math inline">\(r_d=3\)</span> is the desired separation.The magnitude of the observer's velocity is bounded from above by <spanclass="math inline">\(3\)</span> m/s. It should be noted that <ahref="#eq_tracking_control" data-reference-type="eqref"data-reference="eq_tracking_control">[eq_tracking_control]</a> relies onthe true position and velocity of the target MAV in the simulation.Therefore, the data is collected first and then processed offline sothat we can compare the performances of the bearing-only andbearing-angle approaches.</p><p>In the first example, the target MAV hovers constantly at <spanclass="math inline">\(p_T(t_0)=[0, 10, 10]^\mathrm{T}\)</span>. Theobserver MAV moves along a straight line toward the target with adecreasing velocity command. Since the bearing of the target MAV remainsthe same, this example is challenging for the bearing-only approach. Asshown in Fig. <a href="#fig_airsim_1" data-reference-type="ref"data-reference="fig_airsim_1">[fig_airsim_1]</a>, the bearing-onlyapproach fails to converge while the bearing-angle approach cansuccessfully estimate the target's motion.</p><p>In the second example, the target MAV moves with a constant velocityof <span class="math inline">\(v_T=[1/\sqrt{2}, 1/\sqrt{2},0]^\mathrm{T}\)</span>. The trajectory of the observer MAV under thecontrol of <a href="#eq_tracking_control" data-reference-type="eqref"data-reference="eq_tracking_control">[eq_tracking_control]</a> is stillclose to (though not strictly) a straight line. As a result, theobservability is weak by the bearing-only approach. As shown in Fig. <ahref="#fig_airsim_2" data-reference-type="ref"data-reference="fig_airsim_2">[fig_airsim_2]</a>, the bearing-angleapproach successfully converges while the bearing-only one fails. It isnotable that <span class="math inline">\(\ell\)</span> is invariant inthe first example and varies slowly in the second example.</p><p>It is worth mentioning that the detection results used in theestimation algorithms are obtained from the Yolo-based estimator. Theground truth obtained from AirSim is only used to calculate the errorsof measurements, as shown in the right figures of Figs. <ahref="#fig_airsim_1" data-reference-type="ref"data-reference="fig_airsim_1">[fig_airsim_1]</a> and <ahref="#fig_airsim_2" data-reference-type="ref"data-reference="fig_airsim_2">[fig_airsim_2]</a>. It is not surprisingthat the measurement noises are not strictly Gaussian since the 2Dbounding box is generated by a deep learning vision algorithm. It isnoticed that the noises are inversely correlated to the observer-targetrange. This is reasonable because, when the target is close to thecamera and hence its image is large, the center point and the size ofthe bounding box usually vary for a few pixels.</p><p>The NEES values are also shown in Fig. <a href="#fig_airsim"data-reference-type="ref" data-reference="fig_airsim">[fig_airsim]</a>.As can be seen, the NEES value of the bearing-only approach diverges.The NEES value of the bearing-angle approach oscillates and convergesslowly. The reasons are analyzed as follows. Compared to theMatlab-based numerical simulation, the visual measurements here aregenerated by deep learning algorithms, and the measurement noises arenon-Gaussian. The non-Gaussian noises propagate into <spanclass="math inline">\(P\)</span> in <a href="#eq_nees"data-reference-type="eqref" data-reference="eq_nees">[eq_nees]</a> sincethe calculation of <span class="math inline">\(P\)</span> relies onnoisy measurements. The noises may also cause an estimation bias thatcan further aggravate the NEES error. Moreover, although the system isobservable in the two simulation examples, the observability isrelatively weak compared to the case where the observer movessurrounding the target. As a result, the matrix <spanclass="math inline">\(P\)</span> may not be able to perfectly describethe estimation accuracy. These elements may jointly cause theconvergence behavior of the NEES values shown in Fig. <ahref="#fig_airsim" data-reference-type="ref"data-reference="fig_airsim">[fig_airsim]</a>.</p><h2 id="scenario-2-circular-motion-and-varying-ell">Scenario 2: Circularmotion and varying <span class="math inline">\(\ell\)</span></h2><p>We next examine a case where <spanclass="math inline">\(\ell\)</span> is time-varying. In particular,suppose a target quadcopter MAV hovers constantly at <spanclass="math inline">\(p_T(t_0)=[0, 10, 10]^\mathrm{T}\)</span>. Theobserver MAV moves on a circle centered at the target (Fig. <ahref="#fig_airsim_6_1" data-reference-type="ref"data-reference="fig_airsim_6_1">[fig_airsim_6_1]</a>). Since the targetquadcopter MAV has a square shape from the top view, its size <spanclass="math inline">\(\ell\)</span> is time-varying when viewed fromside angles (see the red curves in the middle subfigure of Fig. <ahref="#fig_airsim_6_1" data-reference-type="ref"data-reference="fig_airsim_6_1">[fig_airsim_6_1]</a>).</p><p>We show two simulation examples in Fig. <a href="#fig_airsim_6_1"data-reference-type="ref"data-reference="fig_airsim_6_1">[fig_airsim_6_1]</a> and Fig. <ahref="#fig_airsim_6_2" data-reference-type="ref"data-reference="fig_airsim_6_2">[fig_airsim_6_2]</a>, respectively. Thetwo simulation examples share the same measurement data but differentvalues of <span class="math inline">\(\sigma_\ell\)</span>. Moreover,the other parameters are the same as those in Section <ahref="#Scenario%201:%20Approaching%20and%20following%20the%20target"data-reference-type="ref"data-reference="Scenario 1: Approaching and following the target">8.3</a>.</p><div class="figure*"></div><p>In the first simulation example, <spanclass="math inline">\(\sigma_\ell\)</span> is set to be a small value:<span class="math inline">\(\sigma_\ell=10^{-4}\)</span>. Itsinterpretation is that <span class="math inline">\(\ell\)</span> istreated as invariant during the process. In this case, the performanceof the bearing-angle approach is almost the same as the bearing-only oneas shown in Fig. <a href="#fig_airsim_6_1" data-reference-type="ref"data-reference="fig_airsim_6_1">[fig_airsim_6_1]</a>. Since <spanclass="math inline">\(\ell\)</span> is treated to be invariant, theestimated value <span class="math inline">\(\hat{\ell}\)</span>converges to a constant which is the mean value of the time-varying<span class="math inline">\(\ell\)</span>.</p><p>In the second simulation example, the value of <spanclass="math inline">\(\sigma_\ell\)</span> is larger than the firstexample: <span class="math inline">\(\sigma_\ell = 0.01\)</span>. Itsinterpretation is that <span class="math inline">\(\ell\)</span> isbelieved to be time-varying during the process. In this case, theperformance of the bearing-angle approach is still almost the same asthe bearing-only one. Moreover, since <spanclass="math inline">\(\sigma_\ell\)</span> is large, the bearing-angleapproach can successfully estimate the true time-varying value of <spanclass="math inline">\(\ell\)</span>.</p><p>In summary, in the case where <spanclass="math inline">\(\ell\)</span> varies slowly, the bearing-angleapproach would degenerate to the bearing-only one. The fundamentalreason is that the extra information embedded in the angle measurementis used to estimate the time-varying <spanclass="math inline">\(\ell\)</span> rather than improving theobservability of the target's motion.</p><div class="figure*"></div><h1 id="real-world-experimental-results">Real-World ExperimentalResults</h1><p>In this section, two sets of real-world experiments are presented tofurther verify the effectiveness of the approach. The first is based ona hand-held camera and a ground robot. The second is based on twoquadcopter MAVs. The second experimental scenario is motivated by aerialtarget pursuit tasks.</p><h2 id="experiment-1-hand-held-camera">Experiment 1: Hand-heldcamera</h2><p>The experimental setup is shown in Fig. <ahref="#fig_architecture_indoor" data-reference-type="ref"data-reference="fig_architecture_indoor">[fig_architecture_indoor]</a>.The observer is a hand-held camera (Hik Vision DS-E14S) connected to alaptop. The camera's intrinsic parameters are calibrated beforehand. Therobot built on Mecanum wheels can move in any direction on the groundunder velocity control. The ground truth of the states of the camera andthe robot are provided by a Vicon indoor motion capture system. The keyexperimental specifications are listed in Table <ahref="#table_indoor_hardware" data-reference-type="ref"data-reference="table_indoor_hardware">[table_indoor_hardware]</a>.</p><p>A dataset of 5,514 images was collected and used to train a tiny-YOLOv4 network to detect the target robot (see Fig. <ahref="#fig_car_dataset" data-reference-type="ref"data-reference="fig_car_dataset">[fig_car_dataset]</a>). The detectionprecision of the trained network is mAP=99.8%. In the experiment, thetarget robot is commanded to move with a constant velocity. In themeantime, a person holding the camera moves along some trajectories. Twodifferent cases are studied. In both of the cases, the target robotmoves with a constant velocity <span class="math inline">\(v_T=[-0.1,0.1 ,0]^\mathrm{T}\)</span>. The noises of the measurements arecalculated based on the ground truth provided by the Vicon system. Thenoises are shown in the right subfigures of Fig. <a href="#fig_indoor_9"data-reference-type="ref"data-reference="fig_indoor_9">[fig_indoor_9]</a> and Fig. <ahref="#fig_indoor_6" data-reference-type="ref"data-reference="fig_indoor_6">[fig_indoor_6]</a>.</p><p>In the first case, the camera is held about 1.5 meters above theground and moves around the target robot. In this case, the bearingvector varies sufficiently and hence the observability conditions forthe bearing-only and bearing-angle approaches are both well satisfied.As shown in Fig. <a href="#fig_indoor_9" data-reference-type="ref"data-reference="fig_indoor_9">[fig_indoor_9]</a>, both approachesperform well in this case while the bearing-angle approach performsslightly better than the bearing-only one.</p><p>In the second case, the camera moves along the trajectory of therobot by getting close or far from it periodically. In this case, theangle varies significantly, but the bearing does not. Without surprise,the bearing-only approach performs poorly in this case due to weakobservability (Fig. <a href="#fig_indoor_6" data-reference-type="ref"data-reference="fig_indoor_6">[fig_indoor_6]</a>). By contrast, thebearing-angle approach can perform stably due to its enhancedobservability.</p><div class="center"><div class="tabular"><p>l|lll &amp; Parameter &amp; Value &amp; Unit<br />*Camera &amp; Resolution &amp; 640<spanclass="math inline">\(\times\)</span> 480 &amp; pixel<br />  &amp; Max frequency &amp; 30 &amp;fps<br />*Robot &amp; Max speed &amp; 1&amp; m/s<br />  &amp; Diameter size &amp; 295 &amp; mm<br />*Vicon &amp; Localization accuracy &amp; 1 &amp; mm<br />  &amp; Max frequency &amp; 100 &amp; Hz<br /></p></div></div><h2 id="experiment-2-mav-following-mav">Experiment 2:MAV-following-MAV</h2><div class="center"><div class="tabular"><p>c|lll &amp; Parameter &amp; Value &amp; Unit<br />&amp; Diagonal size &amp; 895 &amp; mm<br /> &amp;Total mass &amp; 7.4 &amp; kg<br /> &amp;Max pitch/roll &amp; 30 &amp; degree<br /> &amp;Max flight time &amp; 30 &amp; minutes<br />&amp; Accuracy &amp; 1 &amp; cm<br /> &amp; Max frequency &amp; 10 &amp; Hz<br />&amp; Resolution &amp;1920<spanclass="math inline">\(\times\)</span><!-- -->1080 &amp; pixel<br /> &amp; Frequency &amp; 15 &amp; Hz<br />  &amp; Max angular rate &amp; 180 &amp; deg/s<br /></p></div></div><div class="figure*"></div><div class="figure*"><figure><img src="fig_outdoor_1" alt="image" /><figcaption aria-hidden="true">image</figcaption></figure></div><p>Two MAV platforms were developed based on DJI M300 quadcopters(Fig. <a href="#fig_M300" data-reference-type="ref"data-reference="fig_M300">[fig_M300]</a>). The MAV platforms areequipped with RTK GPS modules for accurate self-localization, an H20camera for visual detection, a Manifold 2G onboard computer for onboardflight control, and a Zigbee module for wireless communication. Some keyspecifications of the MAV platforms are listed in Table <ahref="#table_M300" data-reference-type="ref"data-reference="table_M300">[table_M300]</a>. The structure of thehardware perception and communication system is illustrated in Fig. <ahref="#fig_outdoor_hardware" data-reference-type="ref"data-reference="fig_outdoor_hardware">[fig_outdoor_hardware]</a>. Thetarget MAV is also equipped with an RTK GPS module, whose measurementsare used as the ground truth to calculate the noises of the visualmeasurements. The noises are shown in the right subfigure of Fig. <ahref="#fig_outdoor_1" data-reference-type="ref"data-reference="fig_outdoor_1">[fig_outdoor_1]</a>.</p><p>The experiment consists of two stages: data acquisition and offlinedata processing. In the data acquisition stage, the target MAV iscommanded to fly with a constant velocity, and the observer MAV isautomatically controlled to follow the target MAV to maintain a constantdistance from the target. More specifically, the procedure of the flightexperiment is as follows. Initially, the observer MAV is placed about 20meters behind the target MAV on the ground. Then, the two MAVs take offand fly to the same specified height automatically upon a takeoffcommand sent from the ground control station. After they have reachedthe desired height, all deployed algorithms are activated. Then, thetarget MAV moves with a constant velocity of <spanclass="math inline">\(v_T=[1/\sqrt{2}, 1/\sqrt{2},0]^\mathrm{T}\)</span>. The observer MAV approaches the target by thecontroller in <a href="#eq_tracking_control" data-reference-type="eqref"data-reference="eq_tracking_control">[eq_tracking_control]</a>. It takesthe observer MAV about eight seconds to reach the desired relativedistance. Then, the two MAVs fly with the same velocity and remainrelatively stationary for another 20 seconds. Finally, the groundstation sends a stop command and the two MAVs return and landautomatically.</p><p>During the flight, the gimbal camera of the observer MAV isautomatically controlled so that the target MAV is maintained in thefield of view. It is noted that the control of the gimbal camera and theobserver MAV is not based on the visual detection results. Instead, thecontrol is based on the measurements provided by the RKT GPS andinter-MAV wireless communication. In this way, we can analyze the imageand flight data offline and compare the performance of the twoapproaches of bearing-angle and bearing-only. The acquired images andflight data are saved on the onboard computer during the flight. Adataset of 5,341 images was collected (Fig. <a href="#fig_M300_dataset"data-reference-type="ref"data-reference="fig_M300_dataset">[fig_M300_dataset]</a>) and used totrain a tiny-YOLO v4 network. The detection precision of the trainednetwork reaches mAP=99.8%.</p><p>The experimental results are shown in Fig. <a href="#fig_outdoor_1"data-reference-type="ref"data-reference="fig_outdoor_1">[fig_outdoor_1]</a>. As can be seen, thebearing-angle approach performs well. By contrast, the bearing-onlyapproach only works well before the observer MAV reached the desiredposition relative to the target MAV. That is because the bearing variessignificantly during this process due to the fluctuation of theobserver's motion caused by the flight control. However, thebearing-only approach diverges quickly thereafter when the bearing stopsvarying significantly.</p><h1 id="conclusion">Conclusion</h1><p>Motivated by the limitation of the existing bearing-only approach,this paper proposed and analyzed a novel bearing-angle approach forvision-based target motion estimation. We showed that the observabilityby the bearing-angle approach is significantly enhanced compared to thebearing-only one. As a result, the requirement of the observer's extramotion for observability enhancement can be significantly relaxed. As weshowed in various experiments, the bearing-angle approach cansuccessfully estimate the target's motion in many scenarios where thebearing-only approach fails. The enhanced observability of thebearing-angle approach comes with no additional cost since almost allvision detection algorithms can generate bounding boxes. One assumptionadopted in the bearing-angle approach is that the target's physical sizeis invariant to different viewing angles. Although this assumption isapproximately valid in many tasks as demonstrated in this paper, it ismeaningful to study how to relax or remove this assumption in thefuture.</p><h1 id="declaration-of-conflicting-interests">Declaration of conflictinginterests</h1><p>The author(s) declared no potential conflicts of interest withrespect to the research, authorship, and/or publication of thisarticle.</p><h1 id="funding">Funding</h1><p>The author(s) disclosed receipt of the following financial supportfor the research, authorship, and/or publication of this artical: Thiswork was supported by the Hangzhou Key Technology Research andDevelopment Program (Grant 20212013B09), and the Research Center forIndustries of the Future at Westlake University (Grant WU2022C027).</p>]]></content>
    
    
    <summary type="html">🧵本文研究了使用移动单目相机估计移动目标物体运动的问题</summary>
    
    
    
    <category term="阅读" scheme="https://www.adunas.top/categories/%E9%98%85%E8%AF%BB/"/>
    
    
    <category term="视觉导航" scheme="https://www.adunas.top/tags/%E8%A7%86%E8%A7%89%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>日程表：2024年02月</title>
    <link href="https://www.adunas.top/posts/20240222a.html"/>
    <id>https://www.adunas.top/posts/20240222a.html</id>
    <published>2024-02-22T08:36:32.000Z</published>
    <updated>2024-02-22T08:36:41.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章导航总览"><ahref="./20240221a.html#2024年2月">文章导航总览</a></h1><h1 id="年2月23日">2024年2月23日</h1><div class='checkbox red checked'><input type="checkbox" checked="checked"/>            <p>运动1小时</p>            </div><ul class="task-list"><li><label><input type="checkbox" checked="" />羽毛球</label></li></ul><div class='checkbox red'><input type="checkbox" />            <p>写一篇阅读论文的博客</p>            </div><details class="folding-tag" blue><summary> 日程表 </summary>              <div class='content'>              <div class="timeline blue"><div class="timeline-item headline"><div class="timeline-item-title"><div class="item-circle"><p>时间轴</p></div></div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>17点46分</p></div></div><div class="timeline-item-content"><ol type="1"><li>吃晚饭</li></ol></div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>18点10分</p></div></div><div class="timeline-item-content"><ol type="1"><li>阅读论文</li></ol></div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>18点40分-20点40分</p></div></div><div class="timeline-item-content"><ol type="1"><li>羽毛球</li></ol></div></div><div class="timeline-item"><div class="timeline-item-title"><div class="item-circle"><p>21点56分</p></div></div><div class="timeline-item-content"><ol type="1"><li>阅读论文</li></ol></div></div></div>              </div>            </details>]]></content>
    
    
    <summary type="html">🥐本文记录 Adunas 2024年02月的日程安排和实施情况</summary>
    
    
    
    <category term="日程表" scheme="https://www.adunas.top/categories/%E6%97%A5%E7%A8%8B%E8%A1%A8/"/>
    
    
    <category term="日程表" scheme="https://www.adunas.top/tags/%E6%97%A5%E7%A8%8B%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建导航</title>
    <link href="https://www.adunas.top/posts/20240221c.html"/>
    <id>https://www.adunas.top/posts/20240221c.html</id>
    <published>2024-02-21T11:26:31.000Z</published>
    <updated>2024-02-21T11:26:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章导航总览"><ahref="./20240221a.html#博客搭建">文章导航总览</a></h1><h1 id="博客文章语法笔记导航">博客文章语法笔记导航</h1><h2 id="markdown基础语法"><ahref="./20231201a.html">Markdown基础语法</a></h2><h2 id="markdown内置html语法"><ahref="./20231206b.html">Markdown内置Html语法</a></h2><h2 id="butterfly外挂标签"><ahref="./20231205b.html">Butterfly外挂标签</a></h2><h1 id="博客搭建教程导航">博客搭建教程导航</h1><h2 id="基础教程"><a href="./20231205d.html">基础教程</a></h2><h2 id="bug汇总"><a href="./20231204c.html">bug汇总</a></h2><h2 id="未来可期"><a href="./20231205c.html">未来可期</a></h2><h2 id="音频教程"><a href="./20231207a.html">音频教程</a></h2><h2 id="文章个性化功能"><ahref="./20240201a.html">文章个性化功能</a></h2><h2 id="首页美化"><a href="./20240202a.html">首页美化</a></h2>]]></content>
    
    
    <summary type="html">🧈本文是博客搭建的导航</summary>
    
    
    
    <category term="文章导航" scheme="https://www.adunas.top/categories/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
    
    <category term="文章导航" scheme="https://www.adunas.top/tags/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>编程导航</title>
    <link href="https://www.adunas.top/posts/20240221b.html"/>
    <id>https://www.adunas.top/posts/20240221b.html</id>
    <published>2024-02-21T10:48:39.000Z</published>
    <updated>2024-02-21T10:49:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章导航总览"><ahref="./20240221a.html#编程">文章导航总览</a></h1><h1 id="计算机原理">计算机原理</h1><h2 id="原码反码和补码"><ahref="./20240315a.html">原码反码和补码</a></h2><h1 id="c">C++</h1><h2 id="打印"><a href="./20240116a.html">打印</a></h2><h2 id="变量"><a href="./20240315b.html">变量</a></h2><h1 id="命令行">命令行</h1><h2 id="git"><a href="./20231206a.html">Git</a></h2><h1 id="java">Java</h1><h2 id="前端"><a href="./20231211a.html">前端</a></h2><h1 id="搜索">搜索</h1><h2 id="正则表达式"><a href="./20240225a.html">正则表达式</a></h2><h1 id="latex"><a href="./20240225c.html">Latex</a></h1><h1 id="pandoc"><a href="./20240304b.html">Pandoc</a></h1><h1 id="黑马程序员">黑马程序员</h1><h1 id="c基础入门"><a href="./20240312a.html">C++基础入门</a></h1><h1 id="力扣">力扣</h1><h2 id="c-1">C++</h2><h3 id="算法训练"><a href="./20240316c.html">算法训练</a></h3>]]></content>
    
    
    <summary type="html">🥞本文是编程分类的导航</summary>
    
    
    
    <category term="文章导航" scheme="https://www.adunas.top/categories/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
    
    <category term="文章导航" scheme="https://www.adunas.top/tags/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>文章导航</title>
    <link href="https://www.adunas.top/posts/20240221a.html"/>
    <id>https://www.adunas.top/posts/20240221a.html</id>
    <published>2024-02-21T10:41:36.000Z</published>
    <updated>2024-02-21T10:41:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数学"><a href="./20240210a.html">数学</a></h1><h1 id="英语">英语</h1><h2 id="单词"><a href="./20231208a.html">单词</a></h2><h1 id="阅读"><a href="./20240224b.html">阅读</a></h1><h1 id="文学"><a href="./20240224d.html">文学</a></h1><h1 id="编程"><a href="./20240221b.html">编程</a></h1><h1 id="博客搭建"><a href="./20240221c.html">博客搭建</a></h1><h1 id="日程表">日程表</h1><h2 id="年2月"><a href="./20240222a.html">2024年2月</a></h2><h1 id="运动健康">运动健康</h1><h2 id="日常基础篇"><a href="./20240131a.html">日常基础篇</a></h2><h2 id="状态调整篇"><a href="./20240203a.html">状态调整篇</a></h2><h1 id="操作系统">操作系统</h1><h1 id="ios">IOS</h1><h2 id="ipa"><a href="./20240115a.html">ipa</a></h2><h1 id="游戏">游戏</h1><h2 id="adunas的游戏账号昵称和id"><ahref="./20231201b.html">Adunas的游戏账号昵称和ID</a></h2>]]></content>
    
    
    <summary type="html">🥞本文是文章分类导航的最顶层</summary>
    
    
    
    <category term="文章导航" scheme="https://www.adunas.top/categories/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
    
    <category term="文章导航" scheme="https://www.adunas.top/tags/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>数学导航</title>
    <link href="https://www.adunas.top/posts/20240210a.html"/>
    <id>https://www.adunas.top/posts/20240210a.html</id>
    <published>2024-02-10T06:57:53.000Z</published>
    <updated>2024-02-21T10:43:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章导航总览"><ahref="./20240221a.html#数学">文章导航总览</a></h1><h1 id="矩阵">矩阵</h1><h2 id="迹"><a href="./20231210a.html">迹</a></h2><h2 id="协方差"><a href="./20231204a.html">协方差</a></h2><h1 id="滤波">滤波</h1><h2 id="卡尔曼滤波"><a href="./20231205a.html">卡尔曼滤波</a></h2><h1 id="绘图工具">绘图工具</h1><h2 id="动态数学软件"><a href="./20231210b.html">动态数学软件</a></h2><p>  动态数学软件GroGebra。</p>]]></content>
    
    
    <summary type="html">🥧本文是数学分类的导航</summary>
    
    
    
    <category term="文章导航" scheme="https://www.adunas.top/categories/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
    
    <category term="文章导航" scheme="https://www.adunas.top/tags/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>运动健康（二）：状态调整篇</title>
    <link href="https://www.adunas.top/posts/20240203a.html"/>
    <id>https://www.adunas.top/posts/20240203a.html</id>
    <published>2024-02-03T04:32:11.000Z</published>
    <updated>2024-02-03T04:32:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文章导航总览"><ahref="./20240221a.html#状态调整篇">文章导航总览</a></h1><blockquote><h1 id="运动健康的导航">运动健康的导航</h1><ol type="1"><li><a href="./20240131a.html">运动健康（一）：日常基础篇</a></li><li><ahref="./20240203a.html">运动健康（二）：状态调整篇</a>⇦当前位置🪂</li></ol></blockquote><div class="note info flat"></div><h1 id="独立自主">独立自主</h1><p>  学会自尊自爱，任何时候不能把自己的未来托付给别人。你最亲的父母不可以，最好的朋友不可以，最爱的女朋友不可以，最知心的老师也不可以。你唯一要值得托付的人只有自己，也只能是自己。自己是自己的父母，照顾自己衣食起居。自己是自己的孩子，纯真、理想、真心都在此。</p><h1 id="压力别人">压力别人</h1><p>  偶尔还是有这个坏习惯。压力别人典型是自卑的表现，想通过打压别人来体现自身的价值，这只是嫉妒，是很不健康的，特别是在两性关系上。生活已经很累啦，她要的是情绪价值，而不是又多一个压力的老师。多站在别人的角度去想想、去关心、去爱吧。学会<ahref="#赞美">赞美</a>别人。</p><h1 id="沉默与激情">沉默与激情</h1><p>  不求无功，但求无过。这句话说得真差！我来改改：不求无功，不怕犯错！这段时间免去了很多无用的社交、无用的焦虑。沉心静气地搞学习和研究，并不觉得孤独，反而觉得无比踏实、舒心。合适的社交，我会打破沉默，我要从激情地学习转变成热情地交流，真诚面对每一个人，和不同的人、合适的人交流才能让自己能够不让自己的思想和视野变得狭隘和偏颇。热情会被打击，但是那简直是挠痒痒，因为我们根本<ahref="#不生气不伤心">不生气不伤心</a>呀。</p><h1 id="不生气不伤心">不生气不伤心</h1><p>  你要始终明白自己在乎什么，什么是对你重要的。不论男女，最重要的是做好自己该做的事情。对于我，男生来说，最重要的是事业，事业做好了，她有可能跟你，事业做不好，她一定不会跟你。所以你想想，真的是别人让你心情不好了嘛？答案是否定的，而是自己把自己心情变得不好了。</p><p>  我跟老师聊过。我跟同学聊过。我跟家人聊过。我跟朋友聊过。我也跟自己聊过。如果我能跟她再聊一聊就更好了。开心地、努力地、自信地做手头上的事情，就是最棒了。有好身体、好工作、好心态就已经完胜啦。</p><h1 id="赞美">赞美</h1><p>  以前我很讨厌阿谀奉承，然而这种讨厌被无形地扩大了。扩大到不会由衷地欣赏赞美别人。而且阿谀奉承我现在根本不讨厌了，但我不会去阿谀奉承。如果我需要帮助，我会真诚地表达、寻求帮助。我的赞美也不会是阿谀奉承，而是要通过观察后，真的能发现这件事带给我们的美，以及那背后的故事~</p><p>  为什么我不讨厌阿谀奉承。因为我知道人的生活是艰难的，他只不过在艰难地在夹缝中生存着，他阿谀奉承几句，并不是出于恶意，而是可以保住自己的工作，保住自己的饭碗，有个更好的机会而已。说几句话能让大家都开心，这有什么不对吗？这样在工作中大家都很舒服，这是极其正确的。</p><p>  推荐用更好的 “阿谀奉承”的方法，那便是赞美。学会认可别人的工作，学会欣赏，学会赞美。比如她画了一个妆，男生可能看了并没有什么和之前感觉不一样，但是你不知道的是，她为了你化妆准备了多久。她平时一个人的时候可是懒得打扮呀，这时候，我觉得这个女生是真的很美，很可爱呀。我会仔细地看看她地眼睛、腮红，虽然我对化妆一窍不通，但是好像真的有些不一样，我一定会开心得看着她说：你今天真美！</p><p>所以你在和别人交流的时候，总有些东西你不太懂，但是对方极力讲的时候，一定是对他非常重要的东西吧！他一定为这件事付出了很多实实在在的努力，这个时候我会大方地赞美，因为我确实能被感染到，这个时候，我不认为是什么阿谀奉承。</p><blockquote><h1 id="运动健康的导航-1">运动健康的导航</h1><ol type="1"><li><a href="./20240131a.html">运动健康（一）：日常基础篇</a></li><li><ahref="./20240203a.html">运动健康（二）：状态调整篇</a>⇦当前位置🪂</li></ol></blockquote>]]></content>
    
    
    <summary type="html">🍫本文总结状态调整的方法</summary>
    
    
    
    <category term="运动健康" scheme="https://www.adunas.top/categories/%E8%BF%90%E5%8A%A8%E5%81%A5%E5%BA%B7/"/>
    
    
    <category term="健康" scheme="https://www.adunas.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
    <category term="心态" scheme="https://www.adunas.top/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建教程：首页美化</title>
    <link href="https://www.adunas.top/posts/20240202a.html"/>
    <id>https://www.adunas.top/posts/20240202a.html</id>
    <published>2024-02-02T15:36:47.000Z</published>
    <updated>2024-02-21T12:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="博客搭建教程导航"><ahref="./20240221c.html#首页美化">博客搭建教程导航</a></h1><h1 id="格言">格言</h1><p>  在[页脚配置文件]./themes/butterfly/layout/includes/footer.pug中，修改如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.t-t-l</span><br><span class="line">          p.ft-t.t-l-t 格言🧬</span><br><span class="line">          .bg-ad</span><br><span class="line">            div</span><br><span class="line">              | 再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</span><br><span class="line">            .btn-xz-box</span><br><span class="line">              a.btn-xz(href=&#x27;https://stellarium.org/&#x27;) 点击开启星辰之旅</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">🍟本文记录博客首页美化的方法</summary>
    
    
    
    <category term="博客" scheme="https://www.adunas.top/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="hexo" scheme="https://www.adunas.top/tags/hexo/"/>
    
    <category term="html" scheme="https://www.adunas.top/tags/html/"/>
    
  </entry>
  
</feed>
