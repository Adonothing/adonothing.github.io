<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Adunas🍀</title>
  
  
  <link href="https://www.adunas.top/atom.xml" rel="self"/>
  
  <link href="https://www.adunas.top/"/>
  <updated>2024-04-23T07:25:52.000Z</updated>
  <id>https://www.adunas.top/</id>
  
  <author>
    <name>阿杜那斯🍀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>工程实践：STM32F103Cx最小系统设计</title>
    <link href="https://www.adunas.top/posts/20240416b.html"/>
    <id>https://www.adunas.top/posts/20240416b.html</id>
    <published>2024-04-16T08:58:46.000Z</published>
    <updated>2024-04-23T07:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="./20240318zf.html#STM32F103Cx%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F">工程实践导航</a></h1><h1>说明</h1><p>  STM32F103Cx 最小系统的设计。文章内容主要包含：设计指南、器件选型、实际设计、制作测试、归纳总结等。</p><p>  STM32F103Cx 最小系统的设计原则是模块化，目的是方便验证、方便手动焊接、以及批量机器焊接、方便拆装更换，方便维修查找 PCB 的故障。相比于传统的最小系统设计，将传统的最小系统分化为两块板子，分别命名为最小系统核心板和最小系统底板，最小系统核心板，集成了最核心的部分，以及小型化、模块化，仅包含微控制器、晶振电路、控制器滤波电容电路、电源指示灯、全引脚板对板微型连接器；其中本来包含 LDO 电源电路，但是研究发现，对于不同的电源，LDO 的需求不同，无法找到通用合适的 LDO，尤其在电源容量紧张的场景，所以电源模块单独成模块设计，方便更换，但是最小系统核心板必须用独立的电源模块供电，即某电源模块给该核心板供电后，不能给其他模块使用。最小系统底板，也是必须配套的，和一般的底板有所不同，底板包含一些直插的器件和模块，主要是：核心板底座、USB接口、程序下载接口 JTGA、电源模块底座、2.54mm排插排母座、电源接线口等。最小系统底板提供对核心板核心功能的验证或使用：供电、下载程序、兼容洞洞板排针或排母等功能。即核心板和最小系统底板，以及电源模块构成市面上常见的最小系统。这样缺点当然是多了板对板连接器，尺寸和重量会些微增加，增加连接器等成本，但是用的都是手机电脑主板级别的连接器，尺寸和重量均很小。反而带了很多好处：1. 降低设计复杂度，小模块小模块的设计，比整板设计更容易。2. 缩短周期、提振信心。3. 方便焊接、维修。不用再重新做一整块板子，用哪个焊哪个，坏哪个修哪个。4. 降低成本，方便更换以及复用。5. 便于升级，可以重新设计某一个模块，以此增加它的性能。</p><h1>最小系统核心板</h1><h2 id="设计指南和器件选型">设计指南和器件选型</h2><p>  主要依据元器件的手册、网上资料和个人经验总结设计指南，依据设计指南，选择合适低价的元器件。</p><h3 id="板对板连接器">板对板连接器</h3><p>  电流要求：</p><ol><li>单片机最大电流为 150mA</li><li>led 最大电流为 20mA</li></ol><p>  所以连接器应该选择电流能力大于等于 0.3A的。</p><ol><li>板对板连接器 <a href="https://item.taobao.com/item.htm?id=675307456019&amp;scene=taobao_shop&amp;skuId=5028842742268&amp;spm=a1z10.1-c-s.w5003-25266276658.33.2cc66440jknhAW">SGD-05-M/F-020P-2X-G21</a> 单个引脚的最大电流为 0.5A。同时 3mm 的高度是最低的，价格最便宜的，只在淘宝卖，嘉立创无，不可用其他连接器替代，但是客服提供图纸和 3D 模型。2024年4月23日，单个的价格为 1 元。</li></ol><h3 id="双晶振">双晶振</h3><p>  STM32微控制器通常外接两个晶振，分别是低速晶振（32.768 kHz）和高速晶振（通常为8 MHz）。这两个晶振的作用如下：</p><ol><li>低速晶振（LSE）：提供外部低速时钟，通常用于实时时钟（RTC）电路的时钟源，以及为低功耗模式下的计时提供服务。如果设计中不需要RTC功能，可以选择不焊接此晶振。低速晶振的启动时间比高速晶振短，但在校准之后的时钟频率精度相对较差。</li><li>高速晶振（HSE）：提供外部高速时钟，用于生成更精确的系统时钟。这个时钟源对于需要高稳定度时钟的应用来说是非常重要的。高速晶振的频率通常为8 MHz，但可以根据产品需求选择其他频率，只需注意倍分频的设置。</li></ol><div class="note danger modern"><p>结论：两个晶振都要</p></div><p>  晶振选型可参考本博客文章<a href="./20240416a.html#%E6%97%A0%E6%BA%90%E6%99%B6%E6%8C%AF%E8%AF%A6%E8%A7%A3">无源晶振详解</a>。</p><h3 id="低速晶振选型">低速晶振选型</h3><p>  设计无源晶振，手册第54页要求如下：</p><ol><li>CG 和 CL 选用高质量陶瓷电容，容值在 5pF-15pF。</li><li>晶振的选择上，频率为负载电容要小于等于 7pF，不要选择 12.5pF。</li><li>电路板典型的杂散电容值为：2-7pF，我们用 4pF 计算。</li></ol><p>  晶振选型方案如下：</p><p>典型的，常见 MC-306、MC-405、MC-406 的这种 32.768 kHz 晶振不是不能选择，负载电容典型值为：12.5 pF，但是需要定制，常见为 6pF、7pF、9pF 和 12pF，所以要注意选择合适的负载电容值。尺寸还有更小的 MC-146、MC-146，以及更小的 FC-135、FC-145、FC-255。还有更小的 FC-12M，但是不是主流。</p><p>最终选择 <a href="https://item.taobao.com/item.htm?abbucket=12&amp;id=753850636251&amp;ns=1&amp;skuId=5371113711623&amp;spm=a21n57.1.item.326.1a3f523cwPiWmR">FC-135 32.768KHz ±20ppm 7pF</a>，因为在淘宝和嘉立创上常见，同时 AN2867 手册中也推荐了 FC-135。2024年4月23日价格为 0.5元，运费 2 元。</p><p>  电容计算得到典型值是 6pF，范围是 0 - 10 pF。选择精度高的：5%。预留一个电阻位，控制驱动电流，默认先焊接 0 Ω。</p><h3 id="高速晶振选型">高速晶振选型</h3><p>  8MHz，需要查看 AN2867 手册。具体设计还挺麻烦的，这里进行简化：</p><ol><li>Load capacitance 负载电容。（控制震荡频率）<ol><li>这个晶振是工作晶振，不需要低功耗，手册对负载电容的大小无限制，这样 CG 和 CL 相比之前的低速晶振设计，容值就大一点，拉升频率能力更弱（期望和实际负载电容偏差时，频率变化越小）。</li><li>手册要求电容 CG 和 CL 容值在 5pF-25pF之间。</li><li>取杂散电容为 4pF，则匹配晶振的负载电容范围是 6.5-16.5 pF。</li></ol></li><li>Oscillator transconductance 振荡器跨导。（控制震荡稳定）<ol><li>为了使振荡开始并达到稳定相位，振荡器必须提供足够的增益来补偿回路损耗并为振荡积累提供能量。</li><li>振荡回路临界晶体增益 $g_{mcrit}$。$g_{mcrit} = 4 \cdot ESR \cdot (2πF)^2 \cdot (C0 + CL)^2$。ESR 值查看手册。</li><li>最大临界晶体跨导 $g_m$ 由芯片 STM32 手册给出。</li><li>最后计算收益边际公式：$gain_{margin} = g_m / g_{mcrit}$，设计要求确保该值大于 5。</li><li>暂不继续深入。暂不考虑本点要求。</li></ol></li><li>Drive level and external resistor calculation 驱动电平和外部电阻的计算<ol><li>预留一个电阻位，控制驱动电流。焊接 0 Ω 电阻即可，具体计算暂不了解。</li></ol></li><li>Crystal pullabilty 晶体的波动性，也被称为晶体灵敏度<ol><li>暂不考虑。</li></ol></li><li>PCB design guidelines PCB设计指南<ol><li>离芯片近，具体是什么近呢？中间不要有其他元器件，即芯片-晶振电路-其他元器件。</li><li>电容对称</li><li>电容还是晶振更靠近芯片，无这种说法。</li><li>不能太多测试点</li><li>正面 GND 包裹晶振电路，并通过多过孔连接 PCB 背后的 GND。背后的 GND 要求完全覆盖晶振电路，且不连接总 GND，而是通过正面的包裹的 GND 线条一个端点连接总 GND。</li><li>强烈建议晶振电路 PCB 区域应用保形涂层。特别是石英下方，以防止可能导致启动问题的潮湿，灰尘，湿度和极端温度。</li><li>如果使用金属封装的晶体，请勿将其连接到振荡器地。</li><li>高速信号线离晶体管电路保留间距，如 30 mils。</li></ol></li><li>焊接<ol><li>谨慎焊接，焊接是一个敏感的过程，特别是对于低频晶体。</li><li>温度过高会损坏 ESR。</li></ol></li></ol><p>  晶振选型方案如下：</p><ol><li>扬兴科技 <a href="https://detail.tmall.com/item.htm?abbucket=12&amp;id=747734347715&amp;ns=1&amp;spm=a21n57.1.item.142.1a3f523cwPiWmR&amp;skuId=5157386133646">YSX321SL 3225 8M 12PF 10PPM</a>。价格最便宜，2024年4月23日单价0.5，无运费。</li><li>计算 CG 和 CL 容值电容为：16pF。</li></ol><h1>LED</h1><p>  LED 没有什么电气的特殊要求。</p><p>XL-1608</p><p>XL-1608UWC-04 白 100+：￥0.034238 / 个  1000+：￥0.027488 / 个  <a href="https://item.szlcsc.com/1051417.html">https://item.szlcsc.com/1051417.html</a> 5mA 2.6-3.0V 3.3V 60-140Ω 5V 400-400Ω</p><p>XL-1608SURC-04 红 100+：￥0.027676 1000+：￥0.022136 <a href="https://item.szlcsc.com/1051407.html">https://item.szlcsc.com/1051407.html</a> 20mA 2.0-2.4V 3.3V 65-133.3Ω 5V 130-150Ω</p><p>XL-1608UYC-04 黄 100+：￥0.041567 1000+：￥0.033641 <a href="https://item.szlcsc.com/1051412.html">https://item.szlcsc.com/1051412.html</a> 20mA 1.9-2.3V 3.3V 50-70Ω 5V 135-155Ω</p><p>XL-1608UBC-04 蓝 100+：￥0.02253 / 个 1000+：￥0.01803 / 个 <a href="https://item.szlcsc.com/1051416.html">https://item.szlcsc.com/1051416.html</a> 20mA 2.7-3.3V 3.3V 0-30Ω 5V 85-115Ω</p><p>XL-1608UGC-04 翠绿 100+：￥0.02646 / 个 1000+：￥0.020628 / 个 <a href="https://item.szlcsc.com/1051413.html">https://item.szlcsc.com/1051413.html</a> 20mA 2.7-3.3V 3.3V 0-30Ω 5V 85-115Ω</p><p>其中 1608 代表封装尺寸，最后 04 或者 06 代表高度。C 前面的字母代表颜色。</p><p>这都是限流电阻的理论值，电阻也是有最大功率的，在几十W到几百W之间，看不同型号。工作电流不用满额定功率，一个是太亮了，可以是几mA的电流，所以电阻计算的在几百Ω，常用默认选择最大1KΩ即可。另外考虑芯片IO最大电流驱动力：25mA，电压 4v，所以用芯片控制LED的，也要用电源为3.3V的，以免LED损坏短路时，损坏芯片。电阻选择大于200Ω。</p><h1>电源</h1><ol><li>单片机的最大工作电流为 150mA</li><li>电源电压范围为 2.4-3.6V，典型值为3.3V</li><li>普通接口输入电压范围为 0-5V，能充分兼容5V传感器。</li><li>LED 最大电流为20mA，按照20mA计算。</li></ol><p>所以按照负载 200mA电流计算，选择LDO：</p><ol><li>LDO 压降不能超过 1V。越小越好，越小效率越高。</li><li>LDO 最大电流不能低于 300mV</li><li>5V输入，3.3V输出的情况下，温升不能超过80℃。</li><li>满足以上前提下选择 LDO的型号和封装。</li></ol><p>50 ÷ ((5-3.3)*0.2)=147.0588235294118 ℃/W。常见最小封装为 SOT-23-5，一般参数在 200 ℃/W，不够。大一点常见的封装为 SOT-223-3，<a href="https://item.szlcsc.com/5967328.html">AMS1117-3.3</a>，满足要求，为 150 ℃/W。且价格便宜为 10+：￥0.243934 / 个 100+：￥0.205434 / 个。</p>]]></content>
    
    
    <summary type="html">🍱本文记录自己STM32F103Cx最小系统设计的过程</summary>
    
    
    
    <category term="工程实践" scheme="https://www.adunas.top/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="电子电路" scheme="https://www.adunas.top/tags/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/"/>
    
    <category term="单片机" scheme="https://www.adunas.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="最小系统" scheme="https://www.adunas.top/tags/%E6%9C%80%E5%B0%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="STM32" scheme="https://www.adunas.top/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>电子电路：基础元器件</title>
    <link href="https://www.adunas.top/posts/20240416a.html"/>
    <id>https://www.adunas.top/posts/20240416a.html</id>
    <published>2024-04-16T02:50:15.000Z</published>
    <updated>2024-04-16T02:50:15.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href="https://www.stmcu.com.cn/Product/pro_detail/PRODUCTSTM32/product">官网</a>。</li></ol></div><h1><a href="./20240412a.html#%E5%9F%BA%E7%A1%80%E5%85%83%E5%99%A8%E4%BB%B6">电子电路导航</a></h1><h1>LED</h1><p>  LED 在电路上是必须加限流电阻的。因为电源常见电压有 5V、3.3V。除了不同型号的 LED，不同颜色的 LED 的电压也存在差别，这要特别注意。</p><p>  LED 就是发光二极管，在电气特性和普通的二极管相同，即伏安特性是曲线不是线性的。计算限流电阻很简单，考虑 LED 的典型电流和电压，计算限流电阻的大小，然后选择一个相近的标称电阻即可。即使计算电阻为 0，也不能省略限流电阻焊盘，因为实际电路板可能会与理论不同，或者更换 LED 的颜色。</p><p>  所以手册上最重要的是看光电参数，在额定电流测试下的典型电压。</p><p>  如果是用芯片引脚控制LED灯，由于芯片引脚驱动能力弱，采用芯片端拉低通电，拉高断电，即 LED 接 电源正极而不是地。</p><p>  电源电压不能无限升高，一般就到 5V了。电压越高，限流电阻的功率越大，发热越大。</p><p>  限流电阻还需要考虑芯片引脚的电流承受能力。</p><p>  LED 额定最大电流一般为 20mA，但是一般不用这个电流，其中有个原因是，额定电流的亮度很高，指示灯的时候，亮度可以低一点，而带产品壳子，灯罩以后，亮度会降低，又需要拔高亮度减小电阻大小。而裸机一般考虑电阻图方便选在 1kΩ，因为经过计算一般在 100Ω以上。</p><p>  LED 非常容易虚焊，导致接触不良，不够亮。表面材质容易机械损坏，不耐高温，要注意！</p><p>LED 用一个就好了，接通电源指示灯用。</p><h1>晶振</h1><p>  总是要区分有源晶振和无源晶振，而事实上，目前为止，我还没有使用过有源晶振。不讲的话容易弄混，其实很简单。</p><h2 id="无源晶振">无源晶振</h2><p>  无源晶振有两个引脚，不分正负极，内部就石英晶体，用来起振，起振电路来自芯片内部，都要配合两个合适的电容，以及中间的磁珠或者电感。而另外一种有四个引脚，这种并是把外围所需要的电阻电容放进去了，还是无源的，其中两个引脚起固定作用，内部没有任何连接；这种晶振和一些有源晶振的封装有点像，购买时看仔细。</p><p>  要根据数据手册，判断多的两个引脚是悬空还是接地，一般是接地，抗干扰。还要注意四个引脚的晶振的引脚顺序，到底哪两个引脚是晶振脚，不同的晶振可能是不同的。</p><h2 id="有源晶振">有源晶振</h2><p>  有源晶振就更好理解了，只用和控制器的晶振输入引脚，这一个引脚连接。它就是里面再集成了起振电路，需要单独供电，所以叫有源晶振，内部剖开就像集成电路一样。</p><p>有源晶振的设计不同，它的频率稳定性就不同，往往好于无源晶振，成本高适合高精度时钟要求。而消费级的，无源晶振够用了。</p><h1>无源晶振详解</h1><h2 id="基本参数">基本参数</h2><p>本文参考：<a href="https://www.genuway.com/3287.html">关于不需要匹配外接电容的无源晶振电路说明</a>。</p><ol><li>负载电容 CL（Load Capacitance）：准确地来说是期望负载电容，当实际负载电容越靠近负载电容，频率越接近标称频率，频偏越小。参看：<a href="https://www.bilibili.com/video/BV18M4y1V7ek/?share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">【晶振的负载电容到底怎么选择？】</a>。</li><li>静态电容 $C_0$（Shunt Capacitance）：归为杂散电容，不可忽略，一般有不到1pF大小。</li><li>动态电容 $C_1$（Motional Capacitance）：很小，可以忽略，一般是 fF 级别。1 fF = 10e-3 pF。</li></ol><p>一般会在晶振的两个引脚上加入电容：</p><ol><li>CG是无源晶振振荡电路输入管脚到GND的总电容（包括外置的CG电容、微乎其微的晶振引脚两部分）；</li><li>CD是晶体振荡电路输出管脚到GND的总电容（包括外置的CD电容、微乎其微的晶振引脚两部分）；</li><li>CS是杂散电容，包括：无源晶振两个管脚之间的静态电容静态电容 $C_0$，IC芯片两个引脚的寄生电容，以及来自PCB的杂散电容。是其他电容的总和。</li></ol><p>为了让频偏很小，总电容要求如下：</p><p>$$<br>CL = \frac{CG \cdot CD}{CG + CD} + CS<br>$$</p><p>一般的，我们取 CG 和 CD 为两个想等的电容，所以上式化为：</p><p>$$<br>CL = \frac{C_{L0}}{2} + CS<br>$$</p><p>  一般微控制器的手册有相应要求，按照手册实行即可。但是因为寄生电路的不确定性，在PCB实际设计中最好还是为CG/CD预留位置。例如 STM32F103x 的电路设计：<a href="https://www.stmcu.com.cn/Designresource/detail/document/696086">数据手册</a>第53-56页、<a href="https://www.st.com/content/ccc/resource/technical/document/application_note/c6/eb/5e/11/e3/69/43/eb/CD00221665.pdf/files/CD00221665.pdf/jcr:content/translations/en.CD00221665.pdf">电路设计参考</a>。具体的设计过程可以查看我的博客<a href="./20240416b.html">STM32最小系统设计</a>。</p><p>  PCB走线、布局等的杂散电容，以及温漂等因素，导致了频偏，所以长时间 RTC 实时时钟会偏差。芯片的时钟基准就来自晶振。分频或者倍频后按照频率基准运算干活。</p><h1>LDO</h1><p>  线性稳压。原理：输出反馈电路给放大器，调节 PMOS 从而稳定电压。等效于滑动变阻器，压降产生的功率全部转化为热量。由于压差较小，功率较低，纹波较小，非常适合给功耗不高的芯片供电。</p><p>基础参数</p><ol><li>输入电压范围</li><li>输出电压</li><li>工作电流</li><li>纹波：电源的稳定性</li></ol><p>重要参数：</p><ol><li>结温，最大耐受温度一般为 125℃。质量差的只有85 ℃。</li><li>Junction-to-ambient thermal resistance 热阻参数，单位为 ℃/W。表示损耗功率转化为温升的系数。热阻参数与封装类型有极大关系，以及PCB布局有关，由手册给出的计算即可。若手册中无此参数，建议选择其他品牌和型号的 LDO。比如室温 25℃，输入电压5V，输出电压3.3V，电流为500mA，热阻为 90℃/W，则芯片温度将达到：25+90*((5-3.3)*0.5)=101.5℃，显然，即使没有超过额定电压和电流，温度可能会超过结温，损坏 LDO。</li><li>Dropout Voltage 压降。输入和输出的最小电压差，若想稳定输出电压值不变，输入电压必须大于 输出电压+压差。当输入电压小于这个值时，输出电压会随着输入电压的降低而降低。手册不会给所有的电流下的压降，一般的，电流越大，压差就越高；所以在实际比手册电流低的情况下，保证压差满足即可。<ol><li>值得注意的是，芯片的额定电压为 3.3V，但是其工作电压是相对宽泛的，如 2.4V到3.6V。此时就可以利用LDO特性，接一个3.3V或者5V的电源都能正常工作。这也是使用LDO 的一个重要目的之一。</li></ol></li></ol><p>焊接注意：</p><ol><li>远离其他热源。</li></ol><h1>板对板连接器</h1><ol><li>HRS广濑连接器 <a href="https://www.hirose.com/zh/product/series?category=Board-to-Board-Board-to-FPC_Mezzanine-Connection">https://www.hirose.com/zh/product/series?category=Board-to-Board-Board-to-FPC_Mezzanine-Connection</a></li><li>TXGA连接器 <a href="https://www.txga.com/m18series/FBB04009-M.html">https://www.txga.com/m18series/FBB04009-M.html</a></li><li>得捷电子 JST 连接器，没卖的？<a href="https://www.jst-mfg.com/">https://www.jst-mfg.com/</a></li><li>松下连接器 <a href="https://device.panasonic.cn/ac/c/dl/cad/index.jsp?series_cd=1293">https://device.panasonic.cn/ac/c/dl/cad/index.jsp?series_cd=1293</a><ol><li>买过 AXK5F80547YG</li></ol></li><li>中国星坤 <a href="https://www.helloxkb.com/Home/Goods/goodsList/id/21.html">https://www.helloxkb.com/Home/Goods/goodsList/id/21.html</a><ol><li>这家店和国外的店，如松下，广濑价格没有优势</li><li>2024年4月20日官网很多器件手册和资料、图片都空的</li></ol></li><li>Molex莫仕 <a href="https://www.molex.com/zh-cn/products/connectors/board-to-board-connectors">https://www.molex.com/zh-cn/products/connectors/board-to-board-connectors</a></li><li>YXT(益鑫通) <a href="http://www.yxt-pretech.com/%E5%AE%98%E7%BD%91%E4%B8%8A%E4%B8%8D%E7%BB%99%E5%9B%BE%E7%BA%B8%EF%BC%8C%E4%B8%8D%E4%BA%88%E8%80%83%E8%99%91%E3%80%82">http://www.yxt-pretech.com/官网上不给图纸，不予考虑。</a></li><li>其他<ol><li><a href="https://www.digikey.cn/">https://www.digikey.cn/</a></li></ol></li><li>淘宝这家，官网垃圾，但是客服给力啊，资料都给、价格便宜：深圳山谷道连接器。</li></ol><p>连接器很难具有完全替代性。因为引脚一样，但是固定孔可能不同。配对口可能不同。</p><p>常见类型</p><p>最少10pin（2x5）（没卖的）。0.8mm * 5mm（引脚*组装高度）</p><p>0.5mm* 2、0.5mm*3mm，QFP 封装芯片引脚的间距就是 0.5mm。</p><p>根据计算，这个单片机 48 个引脚，去除电源总计9个，和4个晶振引脚，总计35个，再额外加至少一对电源，所以 用 20 pin 用两个够用。</p><h2 id="20pin-05mm">20pin 05mm</h2><ol><li>深圳山谷道连接器<ol><li>定位孔 2 个</li><li>安装有方向</li><li>5.2 1.6 2  4.6 3.6</li></ol></li><li>松下<ol><li>无</li><li>安装有方向</li><li>公母推荐焊盘不同</li></ol></li></ol><p>本来还想兼容多种座子的，确实有工作量，且宽度有不同，工作量大，没必要。这次就用 山谷道。</p><p>连接器有个很容易出错的问题，就是镜像问题。一旦搞错，会出现板子的方向问题出错、线序出错等严重低级错误。特别是是否对称。设计准则是：</p><ol><li>原理图上公母引脚1to1，2to2···</li><li>这个好像是对称的，即旋转180°仍然能放进去，尊崇手册里的方向，即装配好是固定点重合</li><li>PCB板画好箭头方向，重合即可。</li><li>母座为顺序，改公座的封装引脚顺序。</li></ol><p>连接器接线准则：</p><ol><li>芯片引脚复用，即除了基本普通的IO口，还复用其他值，经常存在几个引脚成对复用。<ol><li>相邻的同符号脚可能存在同功能组（如 IIC），相邻边中间隔了电源也算相邻。如 PA3、PA4。</li><li>相邻的不同符号脚不存在同功能组，如PA8、PB0。</li><li>成对复用应优先保证等长。</li></ol></li><li>观察发现，芯片不用旋转45°，而是横竖中间拆分比较合适，而上下结构连接器，正好覆盖两个角，像个宝盖头一样。</li></ol>]]></content>
    
    
    <summary type="html">🍦本文记录基础元器件的笔记</summary>
    
    
    
    <category term="电子电路" scheme="https://www.adunas.top/categories/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/"/>
    
    
    <category term="电子元器件" scheme="https://www.adunas.top/tags/%E7%94%B5%E5%AD%90%E5%85%83%E5%99%A8%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>电子电路：STM32单片机</title>
    <link href="https://www.adunas.top/posts/20240412b.html"/>
    <id>https://www.adunas.top/posts/20240412b.html</id>
    <published>2024-04-12T09:22:34.000Z</published>
    <updated>2024-04-12T09:22:34.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href="https://www.stmcu.com.cn/Product/pro_detail/PRODUCTSTM32/product">官网</a>。</li></ol></div><h1><a href="./20240412a.html#STM32%E5%8D%95%E7%89%87%E6%9C%BA">电子电路导航</a></h1><h2 id="简述">简述</h2><p>  介绍 MCU 系列。<a href="https://www.stmcu.com.cn/upload/Selection_Guide.pdf">选型手册</a>翻到最后有型号名称说明。</p><table><thead><tr><th>家族</th><th>产品类别</th><th>特定功能</th><th>引脚数</th><th>闪存容量(Kbytes)</th><th>封装</th><th>温度范围</th></tr></thead><tbody><tr><td>示例↓</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>STM32</td><td>F</td><td>103</td><td>Z</td><td>E</td><td>T</td><td>6</td></tr><tr><td></td><td>基础型↓</td><td>基础型↓</td><td>48↓</td><td>512↓</td><td>QFP↓</td><td>-40-+85↓</td></tr><tr><td>32位MCU</td><td>F</td><td>103</td><td>C</td><td>E</td><td>T</td><td>6</td></tr><tr><td></td><td></td><td>高性能，带DSP和FPU↓</td><td>64↓</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td>407</td><td>R</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>100↓</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>V</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>144↓</td><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td><td>Z</td><td></td><td></td><td></td></tr></tbody></table><h1>STM32Fx系列对比</h1><p>  淘宝上最常见的是 F103 和 F407 系列。F103 属于基础款，F407 属于高性能版。特点是带 DSP 和 FPU，核心区别是 F407 性能更强，例如时钟频率更高；相应的功耗更大，价格更高。</p><h2 id="引脚数对比">引脚数对比</h2><p>  仅引脚数不同，接口数量不同。引脚数越多，接口数越多，体积更大。</p><h2 id="闪存容量">闪存容量</h2><p>  选大的，但是更贵。闪存是断电也能保存的，一般用来存放代码，要有冗余设计，闪存大小大于代码量。</p><h2 id="封装">封装</h2><p>  选QFP的，方便手动焊接。</p><h2 id="常见型号">常见型号</h2><p>  要在淘宝上容易买到的，统计价格最低的。然后综合价格和性能，选择最好的。注意：价格不能选择过低，那种明显低于正常价格的，以免买到坏芯片。</p><table><thead><tr><th>型号</th><th>封装</th><th>价格</th><th>链接</th></tr></thead><tbody><tr><td>STM32F103C8T6</td><td>LQFP144</td><td>13.8</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=679621192822&amp;ns=1&amp;skuId=5277793403624&amp;spm=a21n57.1.item.4.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F103C8T6</td><td>LQFP48</td><td>3.9</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=602908611297&amp;ns=1&amp;spm=a21n57.1.item.5.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F103C8T6</td><td>LQFP48</td><td>5.1</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=693137114620&amp;ns=1&amp;spm=a21n57.1.item.7.3fe3523cn00Bvn&amp;skuId=5090317034688">链接</a></td></tr><tr><td>STM32F107RBT6</td><td>LQFP48</td><td>8.3</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=704339690297&amp;ns=1&amp;skuId=5126881626317&amp;spm=a21n57.1.item.8.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F107RCT6</td><td>LQFP48</td><td>8.5</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=704339690297&amp;ns=1&amp;skuId=5126881626317&amp;spm=a21n57.1.item.8.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F107VBT6</td><td>LQFP48</td><td>8.2</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=704339690297&amp;ns=1&amp;skuId=5126881626317&amp;spm=a21n57.1.item.8.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F107VCT6</td><td>LQFP48</td><td>8.5</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=704339690297&amp;ns=1&amp;skuId=5126881626317&amp;spm=a21n57.1.item.8.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F107VCH6</td><td>LQFP48</td><td>30</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=704339690297&amp;ns=1&amp;skuId=5126881626317&amp;spm=a21n57.1.item.8.3fe3523cn00Bvn">链接</a></td></tr></tbody></table><table><thead><tr><th>型号</th><th>封装</th><th>价格</th><th>链接</th></tr></thead><tbody><tr><td>STM32F103ZET6</td><td>LQFP144</td><td>13.8</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=679621192822&amp;ns=1&amp;skuId=5277793403624&amp;spm=a21n57.1.item.4.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F103C8T6</td><td>LQFP48</td><td>3.9</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=602908611297&amp;ns=1&amp;spm=a21n57.1.item.5.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F103C8T6</td><td>LQFP48</td><td>5.1</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=693137114620&amp;ns=1&amp;spm=a21n57.1.item.7.3fe3523cn00Bvn&amp;skuId=5090317034688">链接</a></td></tr><tr><td>STM32F107RBT6</td><td>LQFP48</td><td>8.3</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=704339690297&amp;ns=1&amp;skuId=5126881626317&amp;spm=a21n57.1.item.8.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F107RCT6</td><td>LQFP48</td><td>8.5</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=704339690297&amp;ns=1&amp;skuId=5126881626317&amp;spm=a21n57.1.item.8.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F107VBT6</td><td>LQFP48</td><td>8.2</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=704339690297&amp;ns=1&amp;skuId=5126881626317&amp;spm=a21n57.1.item.8.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F107VCT6</td><td>LQFP48</td><td>8.5</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=704339690297&amp;ns=1&amp;skuId=5126881626317&amp;spm=a21n57.1.item.8.3fe3523cn00Bvn">链接</a></td></tr><tr><td>STM32F107VCH6</td><td>LQFP48</td><td>30</td><td><a href="https://item.taobao.com/item.htm?abbucket=13&amp;id=704339690297&amp;ns=1&amp;skuId=5126881626317&amp;spm=a21n57.1.item.8.3fe3523cn00Bvn">链接</a></td></tr></tbody></table><h1>引脚功能</h1><h2 id="VBAT">VBAT</h2><p>  VBAT 的全称是 Backup operating voltage，备用工作电压。VBAT引脚不断电才能保证当芯片的其余部分断电时，可以使用它来保持STM32的实时时钟、备份寄存器和备份SRAM的运行。</p><div class="note danger simple"><p>不使用 VBAT 相关功能时，必须接电源正极，电平拉高。</p></div><h2 id="配对关系">配对关系</h2><table><thead><tr><th>引脚</th><th>引脚名称</th><th>类型</th><th>通信1</th><th>通信2</th><th>通信3</th><th>模数转换</th><th>计时器1</th><th>计时器2</th><th>其他</th></tr></thead><tbody><tr><td>1</td><td>VBAT</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>2</td><td>RTC</td><td>I/O</td><td></td><td></td><td></td><td></td><td></td><td>不可作普通IO口</td><td></td></tr><tr><td>3</td><td>OSC32_IN</td><td>I/O</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>4</td><td>OSC32_OUT</td><td>I/O</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>5</td><td>OSC_IN</td><td>I</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>6</td><td>OSC_OUT</td><td>O</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>7</td><td>NRST</td><td>I/O</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>8</td><td>VSSA</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>9</td><td>VDDA</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>10</td><td>PA0</td><td>I/O</td><td>USART2_CTS</td><td></td><td></td><td>ADC12_IN0</td><td>TIM2_CH1_ETR</td><td></td><td>WKUP</td></tr><tr><td>11</td><td>PA1</td><td>I/O</td><td>USART2_RTS</td><td></td><td></td><td>ADC12_IN1</td><td>TIM2_CH2</td><td></td><td></td></tr><tr><td>12</td><td>PA2</td><td>I/O</td><td>USART2_TX</td><td></td><td></td><td>ADC12_IN2</td><td>TIM2_CH3</td><td></td><td></td></tr><tr><td>13</td><td>PA3</td><td>I/O</td><td>USART2_RX</td><td></td><td></td><td>ADC12_IN3</td><td>TIM2_CH4</td><td></td><td></td></tr><tr><td>14</td><td>PA4</td><td>I/O</td><td>USART2_CK</td><td>SPI1_NSS</td><td></td><td>ADC12_IN4</td><td></td><td></td><td></td></tr><tr><td>15</td><td>PA5</td><td>I/O</td><td></td><td>SPI1_SCK</td><td></td><td>ADC12_IN5</td><td></td><td></td><td></td></tr><tr><td>16</td><td>PA6</td><td>I/O</td><td></td><td>SPI1_MISO</td><td></td><td>ADC12_IN6</td><td>TIM3_CH1</td><td><em>TIM1_BKIN</em></td><td></td></tr><tr><td>17</td><td>PA7</td><td>I/O</td><td></td><td>SPI1_MOSI</td><td></td><td>ADC12_IN7</td><td>TIM3_CH2</td><td><em>TIM1_CH1N</em></td><td></td></tr><tr><td>18</td><td>PAB0</td><td>I/O</td><td></td><td></td><td></td><td>ADC12_IN8</td><td>TIM3_CH3</td><td><em>TIM1_CH2N</em></td><td></td></tr><tr><td>19</td><td>PAB1</td><td>I/O</td><td></td><td></td><td></td><td>ADC12_IN9</td><td>TIM3_CH4</td><td><em>TIM1_CH3N</em></td><td></td></tr><tr><td>20</td><td>PB2</td><td>I/O</td><td></td><td></td><td></td><td></td><td></td><td></td><td>BOOT1</td></tr><tr><td>21</td><td>PB10</td><td>I/O</td><td>USART3_TX</td><td></td><td>I2C2_SCL</td><td></td><td><em>TIM2_CH3</em></td><td></td><td></td></tr><tr><td>22</td><td>PB11</td><td>I/O</td><td>USART3_RX</td><td></td><td>I2C2_SDA</td><td></td><td><em>TIM2_CH4</em></td><td></td><td></td></tr><tr><td>23</td><td>VSS1</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>24</td><td>VDD1</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>25</td><td>PB12</td><td>I/O</td><td>USART3_CK</td><td>SPI2_NSS</td><td>I2C2_SMBAl</td><td></td><td>TIM1_BKIN</td><td></td><td></td></tr><tr><td>26</td><td>PB13</td><td>I/O</td><td>USART3_CTS</td><td>SPI2_SCK</td><td></td><td></td><td>TIM1_CH1N</td><td></td><td></td></tr><tr><td>27</td><td>PB14</td><td>I/O</td><td>USART3_RTS</td><td>SPI2_MISO</td><td></td><td></td><td>TIM1_CH2N</td><td></td><td></td></tr><tr><td>28</td><td>PB15</td><td>I/O</td><td></td><td>SPI2_MOSI</td><td></td><td></td><td>TIM1_CH3N</td><td></td><td></td></tr><tr><td>29</td><td>PA8</td><td>I/O</td><td>USART1_CK</td><td></td><td></td><td></td><td>TIM1_CH1</td><td></td><td>MCO</td></tr><tr><td>30</td><td>PA9</td><td>I/O</td><td>USART1_TX</td><td></td><td></td><td></td><td>TIM1_CH2</td><td></td><td></td></tr><tr><td>31</td><td>PA10</td><td>I/O</td><td>USART1_RX</td><td></td><td></td><td></td><td>TIM1_CH3</td><td></td><td></td></tr><tr><td>32</td><td>PA11</td><td>I/O</td><td>USART1_CTS</td><td>CANRX</td><td>USBDM</td><td></td><td>TIM1_CH4</td><td></td><td></td></tr><tr><td>33</td><td>PA12</td><td>I/O</td><td>USART1_RTS</td><td>CANTX</td><td>USBDP</td><td></td><td></td><td></td><td></td></tr><tr><td>34</td><td><em>PA13</em></td><td>I/O</td><td></td><td>SWDIO</td><td>JTMS</td><td></td><td></td><td></td><td></td></tr><tr><td>35</td><td>VSS2</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>36</td><td>VDD2</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>37</td><td><em>PA14</em></td><td>I/O</td><td></td><td>SWCLK</td><td>JTCK</td><td></td><td></td><td></td><td></td></tr><tr><td>38</td><td><em>PA15</em></td><td>I/O</td><td></td><td><em>SPI1_NSS</em></td><td>JTDI</td><td></td><td><em>TIM2_CH1_ETR</em></td><td></td><td></td></tr><tr><td>39</td><td><em>PB3</em></td><td>I/O</td><td></td><td><em>SPI1_SCK</em></td><td>JTDO</td><td></td><td><em>TIM2_CH2</em></td><td><em>TRACESWO</em></td><td></td></tr><tr><td>40</td><td><em>PB4</em></td><td>I/O</td><td></td><td><em>SPI1_MISO</em></td><td>JNTRST</td><td></td><td><em>TIM3_CH1</em></td><td></td><td></td></tr><tr><td>41</td><td>PB5</td><td>I/O</td><td></td><td><em>SPI1_MOSI</em></td><td>I2C1_SMBAl</td><td></td><td><em>TIM3_CH2</em></td><td></td><td></td></tr><tr><td>42</td><td>PB6</td><td>I/O</td><td><em>USART1_TX</em></td><td></td><td>I2C1_SCL</td><td></td><td>TIM4_CH1</td><td></td><td></td></tr><tr><td>43</td><td>PB7</td><td>I/O</td><td><em>USART1_RX</em></td><td></td><td>I2C1_SDA</td><td></td><td>TIM4_CH2</td><td></td><td></td></tr><tr><td>44</td><td>BOOT0</td><td>I</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>45</td><td>PB8</td><td>I/O</td><td></td><td><em>CANRX</em></td><td><em>I2C1_SCL</em></td><td></td><td>TIM4_CH3</td><td></td><td></td></tr><tr><td>46</td><td>PB9</td><td>I/O</td><td></td><td><em>CANTX</em></td><td><em>I2C1_SDA</em></td><td></td><td>TIM4_CH4</td><td></td><td></td></tr><tr><td>47</td><td>VSS3</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>48</td><td>VDD3</td><td>S</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>几个成一个功能快，看引脚名称就行，但是两个成对的，需要注意的要单独拿出来。</p><ol><li>引脚复用这个概念，你肯定很早就懂了，即一个引脚只能使用一个功能，比如可以当普通IO，也可以配置为串口等。但是还有一个概念是第一次懂，叫做引脚重映射，remap。就是同一个功能，比如说串口1，默认从1号引脚出来，但是1号引脚被占用了，但是可以重映射，手册里可以给20号引脚，但是这两个引脚不能同时使用串口1。上表中是为了区分引脚对，便于PCB走线，所以把默认和重映射的放在一起了，需要重映射的已经用斜体区别。</li><li>3、4、5 引脚虽然对应 PC13、PC14、PC15 三个引脚，但是电流能力很弱，舍弃普通 IO 功能。</li><li>5、6 引脚虽然对应 PD0、PD1，但是已经是晶振口，而且普通IO功能明显是其他引脚数量的重映射功能，所以不放在列表里。</li><li>引脚 10 WKUP 待机引脚，退出待机模式。</li><li>引脚 29 MCO，功能未知。</li><li>IIC 不需要等长，属于低速通信。</li><li>串口异步不需要等长，而同步是否等长，网上也没说法，但是属于低速通信，一般不需要严格刻意等长。</li></ol>]]></content>
    
    
    <summary type="html">🍦本文记录STM32单片机的选型</summary>
    
    
    
    <category term="电子电路" scheme="https://www.adunas.top/categories/%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF/"/>
    
    
    <category term="单片机" scheme="https://www.adunas.top/tags/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    <category term="微控制器" scheme="https://www.adunas.top/tags/%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>电子电路导航</title>
    <link href="https://www.adunas.top/posts/20240412a.html"/>
    <id>https://www.adunas.top/posts/20240412a.html</id>
    <published>2024-04-12T09:13:40.000Z</published>
    <updated>2024-04-12T09:13:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="./20240221a.html#%E7%94%B5%E5%AD%90%E7%94%B5%E8%B7%AF">文章导航总览</a></h1><h1>电子元器件</h1><h2 id="基础元器件"><a href="./20240416a">基础元器件</a></h2><h1>意法半导体</h1><h2 id="STM32单片机"><a href="./20240412b.html">STM32单片机</a></h2>]]></content>
    
    
    <summary type="html">🥧本文是电子电路分类的导航</summary>
    
    
    
    <category term="文章导航" scheme="https://www.adunas.top/categories/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
    
    <category term="文章导航" scheme="https://www.adunas.top/tags/%E6%96%87%E7%AB%A0%E5%AF%BC%E8%88%AA/"/>
    
  </entry>
  
  <entry>
    <title>日程表：2024年04月</title>
    <link href="https://www.adunas.top/posts/20240411a.html"/>
    <id>https://www.adunas.top/posts/20240411a.html</id>
    <published>2024-04-11T03:52:28.000Z</published>
    <updated>2024-04-11T03:52:28.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="./20240221a.html#2024%E5%B9%B44%E6%9C%88">文章导航总览</a></h1><h1>2024年4月11日</h1><div class='checkbox red checked'><input type="checkbox" checked="checked"/>            <p>运动1小时</p>            </div><ul><li>[ ] 四旋翼发板、元器件购买</li></ul><div class='checkbox red'><input type="checkbox" />            <p>写一篇阅读论文的博客</p>            </div><details class="folding-tag" blue><summary> 日程表 </summary>              <div class='content'>              <div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>11点54分-16点15分</p></div></div><div class='timeline-item-content'><ol><li>四旋翼资料查找</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>17点45分-19点03分</p></div></div><div class='timeline-item-content'><ol><li>四旋翼资料查找</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>20点48分-23点59分</p></div></div><div class='timeline-item-content'><ol><li>微信小程序</li></ol></div></div></div>              </div>            </details><h1>2024年4月12日</h1><div class='checkbox red checked'><input type="checkbox" checked="checked"/>            <p>运动1小时</p>            </div><ul><li>[ ] 四旋翼发板、元器件购买</li></ul><div class='checkbox red'><input type="checkbox" />            <p>写一篇阅读论文的博客</p>            </div><details class="folding-tag" blue><summary> 日程表 </summary>              <div class='content'>              <div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>00点00分-02点35分</p></div></div><div class='timeline-item-content'><ol><li>微信小程序</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>09点13分-12点15分</p></div></div><div class='timeline-item-content'><ol><li>微信小程序</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>13点46分-18点53分</p></div></div><div class='timeline-item-content'><ol><li>四旋翼</li></ol></div></div></div>              </div>            </details>]]></content>
    
    
    <summary type="html">🥐本文记录 Adunas 2024年04月的日程安排和实施情况</summary>
    
    
    
    <category term="日程表" scheme="https://www.adunas.top/categories/%E6%97%A5%E7%A8%8B%E8%A1%A8/"/>
    
    
    <category term="日程表" scheme="https://www.adunas.top/tags/%E6%97%A5%E7%A8%8B%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Doxygen</title>
    <link href="https://www.adunas.top/posts/20240403a.html"/>
    <id>https://www.adunas.top/posts/20240403a.html</id>
    <published>2024-04-03T00:51:35.000Z</published>
    <updated>2024-04-06T07:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="./20240221b.html#Doxygen">编程导航</a></h1><h1>学习目的</h1><p>  doxygen是非常重要的代码阅读工具。按照一定的规范书写注释，能够快速帮助我们阅读代码。</p><h1>语法</h1><p>  参考这个<a href="https://www.bilibili.com/video/BV1ZE411F7kW/?p=4&amp;share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">【AXin带你学Doxygen 生成文档超简单！】</a>视频学习基本语法。</p><p>  实体，是指函数、变量等对象。是我们要注释的对象。</p><p>  注释的格式有很多种。统一采用 C++ 的注释格式，比较熟悉方便。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 注释内容</span></span><br></pre></td></tr></table></figure><p>为了方便阅读，不省略参数标志。</p><h1>常用参数</h1><h2 id="brief">brief</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 简要的描述</span></span><br></pre></td></tr></table></figure><h2 id="details">details</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @details 详细的描述</span></span><br></pre></td></tr></table></figure><h2 id="see">see</h2><p>  当函数名和其他函数名一致时，点击生成的 doxygen 网页能够实现实现跳转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @see [函数名]</span></span><br></pre></td></tr></table></figure><h2 id="param">param</h2><p>  当参数名和其他参数名一致时，生成的 doxygen 网页会高亮。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 函数注释</span></span><br><span class="line"><span class="comment">/// @param [参数名] 参数简述</span></span><br></pre></td></tr></table></figure><h2 id="return">return</h2><p>  当变量名和其他变量名一致时，点击生成的 doxygen 网页能够实现实现跳转。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @return [变量名]</span></span><br></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>  不同级别的提示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @note 记录</span></span><br><span class="line"><span class="comment">/// @attention  注意</span></span><br><span class="line"><span class="comment">/// @warning 警告</span></span><br></pre></td></tr></table></figure><h2 id="在实体之后注释">在实体之后注释</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///&lt; 变量1注释</span></span><br><span class="line"><span class="comment">///&lt; 变量2注释</span></span><br></pre></td></tr></table></figure><h1>源文件和头文件</h1><p>  头文件存放了一些声明函数，起到接口作用。不同的源文件可能都会调用头文件里的函数，因此头文件具有一定的 “公共属性”。所以将简要的说明和必要的参数放在头文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 函数注释</span></span><br><span class="line"><span class="comment">/// @param [参数名] </span></span><br><span class="line"><span class="comment">/// @return [变量名]</span></span><br></pre></td></tr></table></figure><p>  源文件中的函数是具体算法的实现，有时我们会更改算法，提示和说明就会产生变动。所以将详细的说明和提示放在源文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @details 详细的描述</span></span><br><span class="line"><span class="comment">/// @see [函数名]</span></span><br><span class="line"><span class="comment">/// @note 注释 </span></span><br><span class="line"><span class="comment">/// @attention 注意 </span></span><br><span class="line"><span class="comment">/// @warning 警告 </span></span><br><span class="line"><span class="comment">///&lt; 变量1注释</span></span><br></pre></td></tr></table></figure><h1>生成方法</h1><p>  用图形化界面生成。</p><h2 id="工作目录">工作目录</h2><p>  存放项目配置文件。</p><h2 id="Wizard：向导">Wizard：向导</h2><p>  基础配置。包含源文件地址、是否递归（所有文件夹检索）、输出文件夹等。</p><h3 id="工程">工程</h3><p>  一定要选择递归，检索所有子文件。</p><h3 id="模式">模式</h3><ol><li>一定要选择所有实体，要不然网页可能不会显示文件。</li><li>选择对应的编程语言。</li></ol><h3 id="输出">输出</h3><p>  可以选择关闭 LaTex 文件输出。</p><h3 id="图表">图表</h3><p>  选择 GraphViz，打上所有勾，需要安装 GraphViz 软件，就能自动绘制函数和文件调用关系图。</p><h2 id="Expert：专家">Expert：专家</h2><p>  高级配置。包含 Html 设置。是完包含 Wizard 中的设置，并大于 Wizard。</p><h3 id="工程-2">工程</h3><p>  可以设置语言为中文。</p><h3 id="Source-Browser">Source Browser</h3><p>  源码设置。</p><ol><li>SOURCE_BROWSER：显示实体函数所在位置，这个要勾选。</li><li>INLINE_SOURCES；嵌入源码，不要勾选。太影响阅读了。</li></ol><h3 id="网页">网页</h3><p>  目录栏，横向换纵向：<code>DISABLE_INDEX</code> 和 <code>GRNERATE_TREEVIEW</code> 打勾。</p><h3 id="Dot语言">Dot语言</h3><p>  DOT语言是一种文本图形描述语言。我们用 GraphViz 软件。</p><p>DOT_PATH：dot.exe 文件的路径，在 GraphViz 软件安装的位置下的 bin 里。如果 GraphViz 已经添加了全局变量，这个就不用设置。</p><h2 id="Run：运行">Run：运行</h2><p>  运行和跳转网页。</p>]]></content>
    
    
    <summary type="html">🥯本文为 Doxygen 的教程和学习笔记</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Doxygen" scheme="https://www.adunas.top/tags/Doxygen/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://www.adunas.top/posts/20240330a.html"/>
    <id>https://www.adunas.top/posts/20240330a.html</id>
    <published>2024-03-30T03:58:23.000Z</published>
    <updated>2024-03-30T03:58:23.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="./20240221b.html#%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0">编程导航</a></h1><h1>字符编码</h1><ol><li>汉字字符：<code>[\u4e00-\u9fa5]</code></li></ol><h1>前后字符</h1><h2 id="必须为">必须为</h2><p>  没找到，但是可以直接匹配呀，然后再整体替换，例如 <code>a123b 123</code> 替换为 <code>ab 123</code> 。</p><h2 id="不能为">不能为</h2><ol><li>前面：<code>(?&lt;![A-Za-z0-9])n</code>。字母 n 前面不能为数字和字母。</li><li>后面：<code>n(?![A-Za-z0-9])</code>。字母 n 后面不能为数字和字母。</li></ol><h1>匹配字符不能为</h1><p>  匹配非汉字且非英文字母：<code>[^\u4e00-\u9fa5a-zA-Z]</code>。</p><h1>删除编号</h1><p>  删除编号：<code>#\s[0-9](\s|\.([0-9](\s|\.[0-9]\s)))</code></p><pre>"#\s[0-9](\s|\.([0-9](\s|\.[0-9]\s)))" => <a href="#learn-regex"><strong># 1 </strong></a>基本匹配=> #<a href="#learn-regex"><strong># 2.1 </strong></a>点运算符 `.`=> ##<a href="#learn-regex"><strong># 2.2.1 </strong></a>否定字符集</pre><p>变式：<code>#\s[0-9].(\s|([0-9](\s|\.[0-9]\s)))</code>，不规范的编号格式示例。</p><pre>"#\s[0-9].(\s|([0-9](\s|\.[0-9]\s)))" => <a href="#learn-regex"><strong># 1. </strong></a>基本匹配=> #<a href="#learn-regex"><strong># 2.1 </strong></a>点运算符 `.`=> ##<a href="#learn-regex"><strong># 2.2.1 </strong></a>否定字符集</pre><h1>匹配变量</h1><p>  在程序中，我们经常要批量修改变量，如变量 <code>n</code> 但是不想修改其他含有 n 字符的变量等其他符号元素，方法为：<code>\sn(?![a-z])</code></p><pre>"\sn(?![a-z])" => int<a href="#learn-regex"><strong> n</strong></a> = sizeof(nums); printf("Hello!\n"); if (n == 10){a = 0;}</pre><pre>"\(n(?![a-z])" => int n = sizeof(nums); printf("Hello!\n"); if <a href="#learn-regex"><strong>(n</strong></a> == 10){a = 0;}</pre>]]></content>
    
    
    <summary type="html">🍤本文是正则表达式的个人笔记</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="正则表达式" scheme="https://www.adunas.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C语言：进阶篇</title>
    <link href="https://www.adunas.top/posts/20240328a.html"/>
    <id>https://www.adunas.top/posts/20240328a.html</id>
    <published>2024-03-28T13:31:08.000Z</published>
    <updated>2024-04-01T03:06:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="./20240221b.html#%E8%BF%9B%E9%98%B6%E7%AF%87">编程导航</a></h1><h1>格式化字符串</h1><p>  将不同类型的变量放到一个字符串里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;    </span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(str, <span class="string">&quot;%d, %lf, %c&quot;</span>, a, b, c);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tool.lu/coderunner/embed/eFz.html">点击测试代码</a></p><h1>动态内存分配</h1><p>  malloc 函数是动态内存分配函数，使用数组和指针的时候可以用到。目的是，初始化数组时会占用一定的内存，而为了保证数组能兼容多种情况，初始化的长度往往很大，容易造成浪费，这时就可以利用动态内存分配函数，用多少给多少。但是分配的内存的数组用完了以后要及时清理，否则会堆积。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 引入标准库stdlib.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">// 或者引入库 malloc.h</span></span><br><span class="line"><span class="comment">// #include &lt;malloc.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配动态内存</span></span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span>* p = <span class="literal">NULL</span>,* q = <span class="literal">NULL</span>;</span><br><span class="line">    p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*p) * n);</span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="comment">//int* p = malloc(sizeof(*p) * n);</span></span><br><span class="line">    <span class="comment">//signed int* q = NULL;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//地址备份</span></span><br><span class="line">        q = p;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">signed</span> <span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i = i + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *p = -i;</span><br><span class="line">            p = p + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打印输出</span></span><br><span class="line">        p = q;</span><br><span class="line">        p = p + <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;指针指向的值为：%d\n&quot;</span>, *p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清理动态内存</span></span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc error!\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清理</span></span><br><span class="line">    p = <span class="literal">NULL</span>; q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tool.lu/coderunner/embed/eFz.html">点击测试代码</a></p><p>在清理动态内存的时候，就会把这一段内存里的所有数据初始化，指针地址不变。清理动态内存需要让指针指向最开始定义时的地址，所以对地址进行了备份。</p><p>增加了判断函数，判断是否成功分配内存空间，使程序更加严谨。</p>]]></content>
    
    
    <summary type="html">🍪本文为 C 语言进阶的教程和学习笔记</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C" scheme="https://www.adunas.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>计算机原理</title>
    <link href="https://www.adunas.top/posts/20240325a.html"/>
    <id>https://www.adunas.top/posts/20240325a.html</id>
    <published>2024-03-25T03:05:02.000Z</published>
    <updated>2024-03-25T03:05:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="./20240221b.html#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86">编程导航</a></h1><h1>栈</h1><p>  程序运行时会产生一些中间变量，尤其是调用函数时，往往会调用多个函数，在此期间就会产生临时存储的参数，而 cpu 的内存是远远不够的，这个时候需要调用一个速度快且容量大的存储空间，此时运行内存就非常合适。栈就是存放货物仓库的意思。根据函数参数存储的需求，要求存储的数据是先进先出，后进后出的。这就很好理解了。</p>]]></content>
    
    
    <summary type="html">🥯本文为 计算机原理 的教程和学习笔记</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="计算机原理" scheme="https://www.adunas.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C语言：基础篇</title>
    <link href="https://www.adunas.top/posts/20240324a.html"/>
    <id>https://www.adunas.top/posts/20240324a.html</id>
    <published>2024-03-24T04:26:20.000Z</published>
    <updated>2024-04-01T03:06:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1><a href="./20240221b.html#%E5%9F%BA%E7%A1%80%E7%AF%87">编程导航</a></h1><h2 id="标准输入输出">标准输入输出</h2><p>  “stdio” 的全称是 “standard input/output”，表示标准输入输出，例如 “printf” 打印函数就需要该头文件，这是最基本的头文件，必须要调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br></pre></td></tr></table></figure><h1>return和exit</h1><p>  exit 是强制结束运行的程序，清理进程。return 是返回函数，返回设定的参数，如果是在主函数里使用，返回值将给 exit。</p><h1>打印</h1><p>  打印不同的类型的值，符号是不同的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//有符号整型</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> a = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//无符号整型</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有符号整型：%d，无符号整型：%u\n&quot;</span>, a, b);</span><br><span class="line">    <span class="comment">//浮点型</span></span><br><span class="line">    <span class="type">double</span> c = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">//字符型</span></span><br><span class="line">    <span class="type">char</span> d = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;浮点型：%lf，字符型：%c\n&quot;</span>, c, d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tool.lu/coderunner/embed/eFz.html">点击测试代码</a></p><h2 id="不要使用该方法">不要使用该方法</h2><p>  一行一行地打印，不要每次只打印几个字符。这样会拖慢整个运行效率，占用资源，并可能出现故障。禁止使用以下方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组下标为：[&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i = i + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d, &quot;</span>, a + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;]\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的方法是转化为字符串，然后打印：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">100</span>] = <span class="string">&quot;数组下标为：[&quot;</span>;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">20</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i = i + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n - <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(temp, <span class="string">&quot;%d&quot;</span>, a + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">sprintf</span>(temp, <span class="string">&quot;%d, &quot;</span>, a + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">strcat</span>(str, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">strcat</span>(str, <span class="string">&quot;]&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tool.lu/coderunner/embed/eFz.html">点击测试代码</a></p><h1>字符和字符串</h1><p>  字符变量是由 ASCII 码对应的二进制数存在内存里的。ASCII 码可以表示基础的符号、数字和字母，占一个字节；汉字的编码占两个字节。字符串就是字符数组，字符串结尾含一个结束符。</p><h2 id="头文件">头文件</h2><p>  操作字符串使用的库函数为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是必须添加的。</p><h1>指针</h1><h2 id="易错点1">易错点1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> arry[] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span>* p;</span><br><span class="line">    p = arry;</span><br><span class="line">    <span class="comment">//打印第一个和第二个元素</span></span><br><span class="line">    <span class="comment">//错误写法</span></span><br><span class="line">    <span class="comment">// printf(&quot;数组下标为：%u %u\n&quot;, *ans, *ans + 1);</span></span><br><span class="line">    <span class="comment">//正确写法</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组下标为：%u %u\n&quot;</span>, *ans, *(ans + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tool.lu/coderunner/embed/eFz.html">点击测试代码</a></p><h2 id="易错点2">易错点2</h2><p>  初始化两个指针容易出现错误，导致第二个不是指针而是变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//错误写法</span></span><br><span class="line">    <span class="comment">// signed int* p = NULL, q = NULL;</span></span><br><span class="line">    <span class="comment">//正确写法</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span>* p = <span class="literal">NULL</span>,* q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tool.lu/coderunner/embed/eFz.html">点击测试代码</a></p><h2 id="数组和指针">数组和指针</h2><h3 id="等价关系">等价关系</h3><p>  变量和数组是等价的。但是还是有细微区别。</p><p>  考虑一种情况：</p><table><thead><tr><th>数学符号</th><th>代码变量</th><th>说明</th></tr></thead><tbody><tr><td>$A$</td><td>signed int A[] = { 1, 2, 3, 4, 5 }</td><td>给定矩阵</td></tr><tr><td>$N_A$</td><td>unsigned int N_A</td><td>元素个数（矩阵计算）</td></tr><tr><td>-</td><td>signed int* p = A</td><td>矩阵指针</td></tr><tr><td>$N_p$</td><td>unsigned int N_p</td><td>元素个数（指针计算）</td></tr></tbody></table><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> A[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//元素个数计算</span></span><br><span class="line">    <span class="comment">//矩阵法</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> N_A = <span class="keyword">sizeof</span>(A) / <span class="keyword">sizeof</span>(A[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//或者将 sizeof(A[0]) 写成 sizeof(signed int)，与数组元素变量定义保持一致即可</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;矩阵计算的元素个数为： %d\n&quot;</span>, N_A);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针法</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span>* p = A;</span><br><span class="line">    <span class="comment">//下面一行是错误的计算方法，因为用指针表示后，*p 指向数组当前元素，计算指针的长度就是当前元素的长度而不是数组的长度。</span></span><br><span class="line">    <span class="comment">//signed int N_p = sizeof(*p) / sizeof(signed int);</span></span><br><span class="line">    <span class="comment">//==========下面的方法也是错误的==========</span></span><br><span class="line">    <span class="comment">//对于指针指向的数组元素超出最后一个时，该地址内的值是随机的。只可能在像字符串数组中含结束符号的元素数组中使用。</span></span><br><span class="line">    <span class="comment">/*unsigned int N_p = 0;</span></span><br><span class="line"><span class="comment">    while (*p != NULL) &#123;</span></span><br><span class="line"><span class="comment">        p++;</span></span><br><span class="line"><span class="comment">        N_p = N_p + 1;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    printf(&quot;指针计算的元素个数为： %d\n&quot;, N_p);*/</span></span><br><span class="line">    <span class="comment">//========================================</span></span><br><span class="line">    <span class="comment">//总结：指针法是无效的，这里就充分地看出了数组和指针地区别</span></span><br><span class="line">    <span class="comment">//正确地做法是用数组计算元素个数，作为参数进行传递</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tool.lu/coderunner/embed/eFz.html">点击测试代码</a></p><h3 id="符号类型">符号类型</h3><p>  数组和指针本身都是无符号整型的。而定义数组时定义的类型是指定元素的类型。同理定义指针的类型是定义指针指向的地址内值的类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> C[<span class="number">2</span>] = &#123; <span class="number">-1</span>,<span class="number">2</span> &#125;;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>* p = C;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;数组显示第一个元素为： %d，指针显示第一个元素为： %d\n&quot;</span>, C[<span class="number">0</span>], *p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tool.lu/coderunner/embed/eFz.html">点击测试代码</a></p><p>上面定义的数组是有符号整型，指针是无符号整型，指针指向的内存地址内的值不发生改变，但是指针无符号是没有负数的，所有都会显示一个正数。</p><h1>数组函数</h1><p>  数组不能作为函数变量返回，但是可以返回数组的指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//声明</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* <span class="title function_">Array</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a, <span class="type">signed</span> <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//输出</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>* ans;</span><br><span class="line">    ans = Array(nums, n, target);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;矩阵计算的元素个数为： %d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span>* <span class="title function_">Array</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a, <span class="type">signed</span> <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//返回数组下标</span></span><br><span class="line">    <span class="type">signed</span> <span class="type">int</span> C[<span class="number">2</span>] = &#123; i,j &#125;;</span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://tool.lu/coderunner/embed/eFz.html">点击测试代码</a></p>]]></content>
    
    
    <summary type="html">🥯本文为 C 语言基础的教程和学习笔记</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C" scheme="https://www.adunas.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统教程：Kali</title>
    <link href="https://www.adunas.top/posts/20240319d.html"/>
    <id>https://www.adunas.top/posts/20240319d.html</id>
    <published>2024-03-18T16:21:04.000Z</published>
    <updated>2024-03-18T16:21:04.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href=""></a>。</li></ol></div><h1><a href="./20240317b.html#Kali">系统软件导航</a></h1>]]></content>
    
    
    <summary type="html">🍰本文记录操作系统 Kali 的使用技巧</summary>
    
    
    
    <category term="系统软件" scheme="https://www.adunas.top/categories/%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6/"/>
    
    
    <category term="软件教程" scheme="https://www.adunas.top/tags/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/"/>
    
    <category term="Kali" scheme="https://www.adunas.top/tags/Kali/"/>
    
  </entry>
  
  <entry>
    <title>工程实践：移动端应用程序</title>
    <link href="https://www.adunas.top/posts/20240319c.html"/>
    <id>https://www.adunas.top/posts/20240319c.html</id>
    <published>2024-03-18T16:14:03.000Z</published>
    <updated>2024-03-18T16:14:03.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href=""></a>。</li></ol></div><h1><a href="./20240318zf.html#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">工程实践导航</a></h1>]]></content>
    
    
    <summary type="html">🍱本文记录自己学习设计移动端应用程序的过程</summary>
    
    
    
    <category term="工程实践" scheme="https://www.adunas.top/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="应用程序" scheme="https://www.adunas.top/tags/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>工程实践：传感器物联网</title>
    <link href="https://www.adunas.top/posts/20240319b.html"/>
    <id>https://www.adunas.top/posts/20240319b.html</id>
    <published>2024-03-18T16:10:42.000Z</published>
    <updated>2024-03-18T16:10:42.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href=""></a>。</li></ol></div><h1><a href="./20240318zf.html#%E4%BC%A0%E6%84%9F%E5%99%A8%E7%89%A9%E8%81%94%E7%BD%91">工程实践导航</a></h1>]]></content>
    
    
    <summary type="html">🍱本文记录自己学习搭建传感器物联网的过程</summary>
    
    
    
    <category term="工程实践" scheme="https://www.adunas.top/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="传感器" scheme="https://www.adunas.top/tags/%E4%BC%A0%E6%84%9F%E5%99%A8/"/>
    
    <category term="物联网" scheme="https://www.adunas.top/tags/%E7%89%A9%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>工程实践：图像识别</title>
    <link href="https://www.adunas.top/posts/20240319a.html"/>
    <id>https://www.adunas.top/posts/20240319a.html</id>
    <published>2024-03-18T16:08:40.000Z</published>
    <updated>2024-03-18T16:08:40.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href=""></a>。</li></ol></div><h1><a href="./20240318zf.html#%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB">工程实践导航</a></h1>]]></content>
    
    
    <summary type="html">🍱本文记录自己学习图像识别的过程</summary>
    
    
    
    <category term="工程实践" scheme="https://www.adunas.top/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="自动化" scheme="https://www.adunas.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="图像识别" scheme="https://www.adunas.top/tags/%E5%9B%BE%E5%83%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>工程实践：GNSS接收机</title>
    <link href="https://www.adunas.top/posts/20240318zj.html"/>
    <id>https://www.adunas.top/posts/20240318zj.html</id>
    <published>2024-03-18T06:46:23.000Z</published>
    <updated>2024-03-18T06:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href=""></a>。</li></ol></div><h1><a href="./20240318zf.html#GNSS%E6%8E%A5%E6%94%B6%E6%9C%BA">工程实践导航</a></h1>]]></content>
    
    
    <summary type="html">🍱本文记录自己学习制作GNSS接收机的过程</summary>
    
    
    
    <category term="工程实践" scheme="https://www.adunas.top/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="导航" scheme="https://www.adunas.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="自动化" scheme="https://www.adunas.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="GNSS接收机" scheme="https://www.adunas.top/tags/GNSS%E6%8E%A5%E6%94%B6%E6%9C%BA/"/>
    
    <category term="人工智能" scheme="https://www.adunas.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>工程实践：云台机械臂</title>
    <link href="https://www.adunas.top/posts/20240318zl.html"/>
    <id>https://www.adunas.top/posts/20240318zl.html</id>
    <published>2024-03-18T06:46:23.000Z</published>
    <updated>2024-03-18T06:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href=""></a>。</li></ol></div><h1><a href="./20240318zf.html#%E4%BA%91%E5%8F%B0%E6%9C%BA%E6%A2%B0%E8%87%82">工程实践导航</a></h1>]]></content>
    
    
    <summary type="html">🍱本文记录自己玩儿云台机械臂的内容</summary>
    
    
    
    <category term="工程实践" scheme="https://www.adunas.top/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="自动化" scheme="https://www.adunas.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="云台机械臂" scheme="https://www.adunas.top/tags/%E4%BA%91%E5%8F%B0%E6%9C%BA%E6%A2%B0%E8%87%82/"/>
    
  </entry>
  
  <entry>
    <title>工程实践：PCB焊接技巧</title>
    <link href="https://www.adunas.top/posts/20240318zk.html"/>
    <id>https://www.adunas.top/posts/20240318zk.html</id>
    <published>2024-03-18T06:46:23.000Z</published>
    <updated>2024-03-18T06:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href=""></a>。</li></ol></div><h1><a href="./20240318zf.html#PCB%E7%84%8A%E6%8E%A5%E6%8A%80%E5%B7%A7">工程实践导航</a></h1>]]></content>
    
    
    <summary type="html">🍱本文总结自己的PCB焊接技巧</summary>
    
    
    
    <category term="工程实践" scheme="https://www.adunas.top/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="PCB焊接技巧" scheme="https://www.adunas.top/tags/PCB%E7%84%8A%E6%8E%A5%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>工程实践：平衡车</title>
    <link href="https://www.adunas.top/posts/20240318zm.html"/>
    <id>https://www.adunas.top/posts/20240318zm.html</id>
    <published>2024-03-18T06:46:23.000Z</published>
    <updated>2024-03-18T06:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href=""></a>。</li></ol></div><h1><a href="./20240318zf.html#%E5%B9%B3%E8%A1%A1%E8%BD%A6">工程实践导航</a></h1>]]></content>
    
    
    <summary type="html">🍱本文记录自己手动搭建平衡车的过程</summary>
    
    
    
    <category term="工程实践" scheme="https://www.adunas.top/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="自动化" scheme="https://www.adunas.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="平衡车" scheme="https://www.adunas.top/tags/%E5%B9%B3%E8%A1%A1%E8%BD%A6/"/>
    
  </entry>
  
  <entry>
    <title>工程实践：遥控手柄</title>
    <link href="https://www.adunas.top/posts/20240318zi.html"/>
    <id>https://www.adunas.top/posts/20240318zi.html</id>
    <published>2024-03-18T06:46:23.000Z</published>
    <updated>2024-03-18T06:46:23.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href=""></a>。</li></ol></div><h1><a href="./20240318zf.html#%E9%81%A5%E6%8E%A7%E6%89%8B%E6%9F%84">工程实践导航</a></h1>]]></content>
    
    
    <summary type="html">🍱本文记录自己手动制作遥控手柄的过程</summary>
    
    
    
    <category term="工程实践" scheme="https://www.adunas.top/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="导航" scheme="https://www.adunas.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="自动化" scheme="https://www.adunas.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="人工智能" scheme="https://www.adunas.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="遥控手柄" scheme="https://www.adunas.top/tags/%E9%81%A5%E6%8E%A7%E6%89%8B%E6%9F%84/"/>
    
  </entry>
  
  <entry>
    <title>工程实践：无人船</title>
    <link href="https://www.adunas.top/posts/20240318zh.html"/>
    <id>https://www.adunas.top/posts/20240318zh.html</id>
    <published>2024-03-18T06:35:35.000Z</published>
    <updated>2024-03-18T06:35:35.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><ol><li>链接：<a href=""></a>。</li></ol></div><h1><a href="./20240318zf.html#%E6%97%A0%E4%BA%BA%E8%88%B9">工程实践导航</a></h1>]]></content>
    
    
    <summary type="html">🍱本文记录自己手动搭建无人船的过程</summary>
    
    
    
    <category term="工程实践" scheme="https://www.adunas.top/categories/%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
    <category term="导航" scheme="https://www.adunas.top/tags/%E5%AF%BC%E8%88%AA/"/>
    
    <category term="自动化" scheme="https://www.adunas.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
    <category term="人工智能" scheme="https://www.adunas.top/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="无人船" scheme="https://www.adunas.top/tags/%E6%97%A0%E4%BA%BA%E8%88%B9/"/>
    
  </entry>
  
</feed>
