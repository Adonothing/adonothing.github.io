<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Adunas🍀の异世界</title>
  
  
  <link href="https://www.adunas.top/atom.xml" rel="self"/>
  
  <link href="https://www.adunas.top/"/>
  <updated>2023-12-10T20:20:03.000Z</updated>
  <id>https://www.adunas.top/</id>
  
  <author>
    <name>阿杜那斯🍀</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端</title>
    <link href="https://www.adunas.top/posts/20231211a.html"/>
    <id>https://www.adunas.top/posts/20231211a.html</id>
    <published>2023-12-10T20:20:03.000Z</published>
    <updated>2023-12-10T20:20:03.000Z</updated>
    
    
    <summary type="html">🥧本文讲解部分前端知识，用到哪、学到哪、讲到哪</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="前端" scheme="https://www.adunas.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="html" scheme="https://www.adunas.top/tags/html/"/>
    
    <category term="CSS" scheme="https://www.adunas.top/tags/CSS/"/>
    
    <category term="js" scheme="https://www.adunas.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>GroGebra</title>
    <link href="https://www.adunas.top/posts/20231210b.html"/>
    <id>https://www.adunas.top/posts/20231210b.html</id>
    <published>2023-12-09T21:47:20.000Z</published>
    <updated>2023-12-10T06:27:43.000Z</updated>
    
    
    <summary type="html">🥧本文介绍网页中使用GroGebra的方法。</summary>
    
    
    
    <category term="数学" scheme="https://www.adunas.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="https://www.adunas.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="GroGebra" scheme="https://www.adunas.top/tags/GroGebra/"/>
    
    <category term="绘图" scheme="https://www.adunas.top/tags/%E7%BB%98%E5%9B%BE/"/>
    
  </entry>
  
  <entry>
    <title>矩阵的迹</title>
    <link href="https://www.adunas.top/posts/20231210a.html"/>
    <id>https://www.adunas.top/posts/20231210a.html</id>
    <published>2023-12-09T17:39:25.000Z</published>
    <updated>2023-12-09T17:39:25.000Z</updated>
    
    
    <summary type="html">🥧本文给出矩阵的迹的概念</summary>
    
    
    
    <category term="数学" scheme="https://www.adunas.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="https://www.adunas.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="矩阵" scheme="https://www.adunas.top/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="迹" scheme="https://www.adunas.top/tags/%E8%BF%B9/"/>
    
  </entry>
  
  <entry>
    <title>单词</title>
    <link href="https://www.adunas.top/posts/20231208a.html"/>
    <id>https://www.adunas.top/posts/20231208a.html</id>
    <published>2023-12-07T18:02:48.000Z</published>
    <updated>2023-12-07T18:02:48.000Z</updated>
    
    
    <summary type="html">🥧本文记录自己常用的、不会的、不熟的单词</summary>
    
    
    
    <category term="英语" scheme="https://www.adunas.top/categories/%E8%8B%B1%E8%AF%AD/"/>
    
    
    <category term="英语" scheme="https://www.adunas.top/tags/%E8%8B%B1%E8%AF%AD/"/>
    
    <category term="单词" scheme="https://www.adunas.top/tags/%E5%8D%95%E8%AF%8D/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建教程（四）：Aplayer音频教程</title>
    <link href="https://www.adunas.top/posts/20231207a.html"/>
    <id>https://www.adunas.top/posts/20231207a.html</id>
    <published>2023-12-06T22:12:06.000Z</published>
    <updated>2023-12-06T22:12:06.000Z</updated>
    
    
    <summary type="html">🥝APlayer 是一个支持播放器的 Hexo 标签插件，本文介绍 Aplayer 的使用方法</summary>
    
    
    
    <category term="博客教程" scheme="https://www.adunas.top/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="Aplayer" scheme="https://www.adunas.top/tags/Aplayer/"/>
    
    <category term="音频" scheme="https://www.adunas.top/tags/%E9%9F%B3%E9%A2%91/"/>
    
    <category term="音乐" scheme="https://www.adunas.top/tags/%E9%9F%B3%E4%B9%90/"/>
    
    <category term="播放器" scheme="https://www.adunas.top/tags/%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>git基本命令</title>
    <link href="https://www.adunas.top/posts/20231206a.html"/>
    <id>https://www.adunas.top/posts/20231206a.html</id>
    <published>2023-12-06T08:26:49.000Z</published>
    <updated>2023-12-06T08:26:49.000Z</updated>
    
    
    <summary type="html">🍖本文汇总git基本命令，可作为文档进行查询</summary>
    
    
    
    <category term="编程" scheme="https://www.adunas.top/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="git" scheme="https://www.adunas.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建教程（一）：基本命令</title>
    <link href="https://www.adunas.top/posts/20231205d.html"/>
    <id>https://www.adunas.top/posts/20231205d.html</id>
    <published>2023-12-05T16:17:05.000Z</published>
    <updated>2023-12-05T16:17:05.000Z</updated>
    
    
    <summary type="html">🥝本文记录利用hexo操作博客的命令</summary>
    
    
    
    <category term="博客教程" scheme="https://www.adunas.top/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="bug" scheme="https://www.adunas.top/tags/bug/"/>
    
    <category term="hexo" scheme="https://www.adunas.top/tags/hexo/"/>
    
    <category term="pandoc" scheme="https://www.adunas.top/tags/pandoc/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建教程（三）：未来可期</title>
    <link href="https://www.adunas.top/posts/20231205c.html"/>
    <id>https://www.adunas.top/posts/20231205c.html</id>
    <published>2023-12-05T12:35:52.000Z</published>
    <updated>2023-12-06T22:02:40.000Z</updated>
    
    
    <summary type="html">🥝本文记录对网页搭建的构想，集思广益</summary>
    
    
    
    <category term="博客教程" scheme="https://www.adunas.top/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="VSCode" scheme="https://www.adunas.top/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>卡尔曼滤波</title>
    <link href="https://www.adunas.top/posts/20231205a.html"/>
    <id>https://www.adunas.top/posts/20231205a.html</id>
    <published>2023-12-04T17:04:28.000Z</published>
    <updated>2023-12-09T17:09:51.000Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>想厘清卡尔曼滤波，就必须要讲清一些最基本的 “文字游戏”。<code>观测值</code> 是测量得到的，物体实际属性为 <code>真实值</code> 或者叫 <code>实际值</code>。但是这个地方要注意的是，<code>观测值</code> 也是 “准确的”，我们把测量的误差单独拿出来一项作为 <code>噪音</code>。所以那些系数矩阵（物理理论关系）也是 “准确的”，所有的误差均归结于 <code>噪音</code>。如果说你认为模型不准确等等，那些因素就称为 <code>错误</code>；<code>错误</code> 往往会带来 <code>定值偏差</code>。一般情况下，不考虑 <code>错误</code>。所以，去除噪音的物理属性称为 <code>理想值</code>或者叫 <code>理论值</code>。因为我们经常谈到理想状态下，也就是没有噪音的理论值公式。而在导航领域是必须要合理考虑影响结果精度的一些关键 <code>噪音</code> 的。</p></div><h1>卡尔曼滤波</h1><h2 id="参考教程">参考教程</h2><ol><li><a href="https://www.bilibili.com/video/BV1Rh41117MT/?p=3&amp;share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">【从放弃到精通！卡尔曼滤波从理论到实践~】</a>：从该教程中提取公式并理解。这个讲得很好，但是公式不够严谨，还有小错误，而且完全跳过了重要的更新过程。</li><li><a href="https://www.bilibili.com/video/BV1iv4y1N7As/?share_source=copy_web&amp;vd_source=6b55cb6788b1952e04c06b095d772810">【【不要再看那些过时的卡尔曼滤波老教程了】2022巨献，卡尔曼滤波-目标追踪从理论到实战最新版全套教程！建议收藏】 </a>：只看了p1而且讲得很不好，但是帮助理解更细那块有点点小用吧。</li><li><a href="https://zhuanlan.zhihu.com/p/433560568">一文看懂卡尔曼滤波（附全网最详细公式推导） - 付聪的文章 - 知乎</a>：公式推导挺全面的，但是流畅度还是不如我自己的这篇。</li></ol><h2 id="P3-进阶（基本滤波知识储备）">P3 进阶（基本滤波知识储备）</h2><h3 id="状态空间表达式">状态空间表达式</h3><h4 id="状态方程">状态方程</h4><p>  <code>状态方程</code> 如下：</p><p><a id= "eq:状态方程"></a><br>$$<br>x_t = F \cdot x_{t-1} + B \cdot u_{t-1} + m_t<br>$$</p><p>解释：当前时刻的状态 $x_t$ 等于上一时刻的状态 $x_{t-1}$ 乘以系数 $F$，加上输入值 $u_t$ 乘以系数 $B$，最后加上 <code>过程噪声</code> $m_t$。</p><p>  $F$ 又称为 <code>状态转移矩阵</code>，因为 $F$ 的大小决定了状态变化的快慢。$B$ 又称为<code>控制矩阵</code>，因为 $B$ 的大小决定了输入对系统影响的程度。</p><p>  如何理解<code>过程噪声</code> $m_t$？状态方程的含义是我们对系统的数学建模，构建了一个数学表达式，但是实际的系统往往是复杂的，在随时间变化的时候，会受到各种各样因素的干扰，可以认为是一个总干扰，这种干扰是随机的，符合正太分布（高斯分布）。</p><h4 id="观测方程">观测方程</h4><p>  <code>观测方程</code> 如下：</p><p><a id= "eq:观测方程"></a><br>$$<br>z_t = H \cdot x_t + n_t<br>$$</p><p>$z_t$ 是观测量，$x_t$ 是状态量，$H$ 是状态量的系数，又称 <code>观测矩阵</code> 因为我们假定观测量和状态量之间的关系是线性的，可以由这个线性矩阵 $H$ 表示。$n_t$ 是 <code>观测噪声</code>。</p><p>  可以这样理解：测量值 $z_t$ 和状态量 $x_t$ 存在一种线性关系，但是测量总是有误差的，所以要加上观测噪声 $n_t$，观测噪声同样符合正太分布。</p><p>  我们可以用一个方框图表示这个系统：</p><style>  .container1 {      width: 100%; /* 设置容器的宽度为90% */      margin: 0 auto; /* 水平居中容器 */      position: relative; /* 设置容器的定位方式为相对定位 */      padding-top: 31%; /* 16大格 * 5大格，高宽比为：0.3125 */      height: 0; /* 设置容器的高度为0，使其自适应内容的高度 */  }    .container-iframe {      position: absolute; /* 设置iframe的定位方式为绝对定位 */      top: 0; /* 将iframe定位到容器的顶部 */      left: 0; /* 将iframe定位到容器的左侧 */      width: 100%; /* 设置iframe的宽度为100% */      height: 100%; /* 设置iframe的高度为100% */      border: none; /* 可选：移除iframe的边框 */  }</style><div class="container1">      <iframe class="container-iframe" src="https://viewer.diagrams.net/?tags=%7B%7D&highlight=0000ff&edit=_blank&layers=1&nav=1&title=SystemBlockDiagramA#R7VpLc9owEP41PiZj4wf2MQGSTGeaZIaZNu0l49gKqAiLygJMfn0lLL9kORCICQzlgrReVvJ%2B%2B9IKzexNk1viz8bfcQiQ1tHDRDP7WqdjOI7BvjhllVI8w0oJIwJDwVQQhvANCKIuqHMYgrjCSDFGFM6qxABHEQhoheYTgpdVtleMqqvO%2FBGoEYaBj%2BrUnzCk45TqdroF%2FQ7A0Thb2XC89MnUz5iFiHjsh3iZktYvZw40s0cwpulomvQA4srL9JJq4Kbhab4xAiK61Q%2BeF3Yc2L8n0XSCkvHg9Uf4dCGkLHw0Fy8sNktXmQZAFF5xRbJZgPw4hoFmXo%2FpFDGCwYYEz6MQ8EV0NnvFERUoGg6b13cplgRhRfFiz7cATwElK8awLNRtC2MYlzSd0QhAPoWLKly%2BQH2Ui8tXeMSQ7aSjCws1hdZ0YZ%2BW6V26VSExnpMAiN%2BVFSyJsvSNoqhPRoDWRLFB6dUL0hrBD6DZUaDJ3M26eda611q3n85qCFcRXI4hBcOZH%2FCnS%2BbVVbi3BngBCAXJuxA3KS7DpGQCrsIELL0Z7YpqP6pHs0GPCdcjZU7TqEr2xrSqr5gSPAE9jDBhlAhHgCsRIiSRfARHEfcxpkfA6Ndcf5AFoivxYArDkC%2BjBGhHJ9weI9OUMNJz4y6h5ChQMttCqXvusctyJUxkh9g2ctnOBkEtxy13M5Ise874EJMBQiz5c0eYAQLZ0txb%2BiClPhakTYHsxQ8mo7UBPMwpghFoL8DV9KsIcNYhA5zXEOCuTytR2PoXJ4qsSj3fGCTXT7bhXdq7RaEaunVRLcchQ1UOc0%2BYax0H8cT%2BQirgOn%2FnvHxfo3YRr2G7YgyGM0vW2GXP2WjEv%2F%2FXD3kIdL1Lr%2FyxvraYMFS1816eDBJIn8QTPv7F6cyg01k%2FKbH1V9kkYu%2FyVDDy6a9MBp8UP1vPVh8FLPXFzZkhdbTNKftYopAnW9eOlVBe%2BeRnuO0qIWYX%2FqrENuMMcfOGbal0s6uHdzZIJX5ueFOda%2Faz8QZ71T%2FLXk%2FMDmVYzV0rcseWBBmtVeTf9P593PHCyd1QX%2F25n6CHB0PZF%2BIJa%2FpMzy1z2VKFYzr1orOtVKXE5tMz1anVnI7cL9rZyzYdoFv2svf7TGdYJTqGBIjxxb5mNSB0d9wH5ZphH7CjqtSjquFwVjHLlRHZ%2FZ7Bk7tJbd4zqKsDVduDO8LbuQYuVz6AHLQ9rgapqYaLzq%2BGc%2FUjq%2BFaOIrt0G7YqW3wXp4sH9eUfN2jCsrdTfceW4dk%2BRb5wIXkFldhJ32B4sptmQNeoKj9V1UYHncr5Uh8zrXzzLhvk6QuKreLvf2OTYu%2F5qTsxR%2BczME%2F" frameborder="0"></iframe>  </div><h3 id="参数分析">参数分析</h3><p>  噪音服从均值为零的正态分布，可以记为公式 <code>噪音服从正态分布</code>：</p><p><a id= "eq:噪音服从正态分布"></a><br>$$<br>\begin{aligned}<br>m_t \in N(0,Q) \<br>n_t \in N(0,R)<br>\end{aligned}<br>$$</p><p>他们的均值均为零，方差分别为 $Q$ 和 $R$，方差为常数，与时间无关。$m_t$ 和 $n_t$ 就是其中的一个取值，只是取得这个结果的概率服从正态分布，用公式 <code>噪音服从正态分布的表达式</code> 表示：</p><p><a id= "eq:噪音服从正态分布的表达式"></a><br>$$<br>\begin{aligned}<br>f (m_t)<br>= \frac {1}<br>{\sqrt{2 \cdot \pi \cdot Q}}<br>\cdot e^{<br>- \frac {m_t^2}<br>{2 \cdot Q}<br>} \<br>f (n_t)<br>= \frac {1}<br>{\sqrt{2 \cdot \pi \cdot R}}<br>\cdot e^{<br>- \frac {n_t^2}<br>{2 \cdot R}<br>}<br>\end{aligned}<br>$$</p><h3 id="超参数">超参数</h3><p>  噪音的方差，具体是多少，我们是不知道的，是需要不断调节的参数，从而使系统达到稳定。和调节PID一样，用公式 <code>卡尔曼滤波和PID调参</code> 表示：</p><p><a id= "eq:卡尔曼滤波和PID调参"></a><br>$$<br>Q,R \sim PID<br>$$</p><h3 id="卡尔曼滤波直观图解">卡尔曼滤波直观图解</h3><p>  通过卡尔曼滤波也不会得到真实值，而是每个时刻状态的 <code>最优估计值</code> $\widehat{x}<em>t$，是修正值，也叫 <code>后验估计值</code>。总结来说是，上一时刻的 <code>最优估计值</code> $\widehat{x}</em>{t-1}$，根据物理理论再加上过程噪声（状态方程）得到的 <code>先验估计值</code> $\hat{x}_t^{-}$，然后利用有噪音的观测值（观测方程） $z_t$，进行加权得到最优估计值 $\widehat{x}_t$。这样从先验到后验，也就实现了 <code>预测到更新</code>，而最优估计值的不断变化，也就是 <code>迭代</code>。因为观测值也是有噪声的，通过得到最优估计值，也就是实现了 <code>滤波</code>，去除了部分噪音。</p><h2 id="P4-放弃（通俗公式理解）">P4 放弃（通俗公式理解）</h2><h3 id="预测模型">预测模型</h3><p>  考虑一个情景，一辆匀加速（加速度为 $a$）直线运动的小车行驶在公路上，我们研究小车的状态有位置 $p$ 和速度 $v$，根据物理规律构建状态方程，用公式 <code>匀加速直线运动1</code> 表示：</p><p><a id= "eq:匀加速直线运动1"></a><br>$$<br>\begin{aligned}<br>&amp;p_t = p_{t-1} + v_{t-1}\cdot\Delta t + \frac {a}2\cdot\Delta t^2 \<br>&amp;v_t = v_{t-1} + a\cdot\Delta t<br>\end{aligned}<br>$$</p><p>其中 $t$ 表示当前时刻，$t - 1$ 表示上一时刻。这是高中物理学习的标准的位置和速度公式。写成矩阵形式，用公式 <code>匀加速直线运动2</code> 表示：</p><p><a id= "eq:匀加速直线运动2"></a><br>$$<br>\begin{bmatrix}<br>p_t \<br>v_t<br>\end{bmatrix}<br>= \begin{bmatrix}<br>1 &amp; \Delta t \<br>0 &amp; 1<br>\end{bmatrix}<br>\cdot\begin{bmatrix}<br>p_{t-1} \<br>v_{t-1}<br>\end{bmatrix}<br>+ \begin{bmatrix}<br>\frac{\Delta t^2}2 \<br>\Delta t<br>\end{bmatrix} \cdot a<br>$$</p><p>写成矩阵的形式，用公式 <code>理想的状态方程</code> 表示：</p><p><a id= "eq:理想的状态方程"></a><br>$$<br>\underline{x} = F \cdot \underline{x_{t-1}} + B \cdot u_{t-1}<br>$$</p><p>其中下划线 $\underline{x}$ 表示没用噪音的理想值。上式加上噪音后，用公式 <code>过程噪音</code> 表示：</p><p><a id= "eq:过程噪音"></a><br>$$<br>\begin{bmatrix}<br>1 &amp; 0 \<br>0 &amp; 1<br>\end{bmatrix} \cdot<br>\begin{bmatrix}<br>r_t§ \<br>r_t(v)<br>\end{bmatrix}<br>$$</p><p>满足<a href="#eq:%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B">状态方程</a>。其中，$r_t§$ 是位置噪音，$r_t(v)$ 是速度噪音，均服从正太分布，噪音是随机的，与时间有关，每个时刻产生随机的噪音。</p><h3 id="预测方程">预测方程</h3><h4 id="状态预测">状态预测</h4><p>  依据去除噪音的<a href="#eq:%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B">状态方程</a>，就能直接写出先验估计的表达式，用公式 <code>先验估计</code> 表示：</p><p><a id= "eq:先验估计"></a><br>$$<br>\hat{x}<em>{t}^{-} = F \cdot \hat{x}</em>{t-1} + B \cdot u_{t-1}<br>$$</p><p>符号 $\hat{x}<em>{t}^{-}$ 和 $\hat{x}</em>{t-1}$ 的含义在前文<a href="#%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%9B%B4%E8%A7%82%E5%9B%BE%E8%A7%A3">卡尔曼滤波直观图解</a>中已经提到，引入符号 $\hat{}$ 和$^{-}$ 是为了表示估计和先验。</p><h4 id="状态误差预测">状态误差预测</h4><p>  上式<a href="#eq:%E5%85%88%E9%AA%8C%E4%BC%B0%E8%AE%A1">先验估计</a>对比<a href="#eq:%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B">状态方程</a>，可以求出 <code>先验误差</code> ${e}_{t}^{-}$，用公式 <code>先验误差</code> 表示：</p><p><a id= "eq:先验误差"></a><br>$$<br>{e}<em>{t}^{-} = x</em>{t} - \hat{x}<em>{t}^{-} = F \cdot (x</em>{t-1} - \hat{x}_{t-1}) + m_t<br>$$</p><p>先验误差表示真实值和预测值的差值。其中$x_{t} - \hat{x}_{t}$为 <code>后验误差</code> ${e}_t$，用公式 <code>后验误差</code> 表示：</p><p><a id= "eq:后验误差"></a><br>$$<br>{e}<em>t = x</em>{t} - \hat{x}_{t}<br>$$</p><p>后验误差表示真实值和估计值的差值。所以上式<a href="#eq:%E5%85%88%E9%AA%8C%E8%AF%AF%E5%B7%AE">先验误差</a>可以用公式 <code>匀加速直线运动2</code> 进一步表示为：</p><p><a id= "eq:先验误差和后验误差的关系"></a><br>$$<br>{e}<em>{t}^{-} = F \cdot e</em>{t-1} + m_t<br>$$</p><p>  接下来求先验误差的协方差矩阵，用公式 <code>先验误差的协方差矩阵1</code> 表示：</p><p><a id= "eq:先验误差的协方差矩阵1"></a><br>$$<br>\begin{aligned}<br>Cov({e}<em>{t}^{-},{e}</em>{t}^{-}) &amp;= Cov({e}<em>{t}^{-}) \<br>&amp;= Cov(F \cdot e</em>{t-1} + m_t) \<br>&amp;= F \cdot Cov(e_{t-1}) \cdot F^{T} + Cov(m_t) \<br>\end{aligned}<br>$$</p><p>记 <code>先验误差的协方差矩阵</code> $Cov({e}<em>{t}^{-}) = P</em>{t}^{-}$，则上式可以用公式 <code>先验误差的协方差矩阵2</code> 表示：</p><p><a id= "eq:先验误差的协方差矩阵2"></a><br>$$<br>P_{t}^{-} = F \cdot P_{t-1} \cdot F^{T} + Q<br>$$</p><p>其中 $P_{t-1}$ 是上一时刻的后验误差的协方差矩阵。不同状态之间的噪音很可能不是独立的，他们具有一定的相关性。</p><h3 id="更新模型">更新模型</h3><p>  对于这个小车，我们有卫星测量，卫星只能直接测量小车的位置 $z_p$，卫星无法直接测量速度 $z_v$，所以理想的位置和速度观测方程中不带速度分量，可以用公式 <code>位置和速度观测方程</code> 表示：</p><p><a id= "eq:位置和速度观测方程"></a><br>$$<br>\begin{aligned}<br>z_p &amp;= p_t<br>\end{aligned}<br>$$</p><p>写成矩阵的形式，用公式 <code>位置和速度观测方程的矩阵形式</code> 表示：</p><p><a id= "eq:位置和速度观测方程的矩阵形式"></a><br>$$<br>\begin{bmatrix}<br>z_p<br>\end{bmatrix}<br>= \begin{bmatrix}<br>1 &amp; 0<br>\end{bmatrix}<br>\cdot\begin{bmatrix}<br>p_t \<br>v_t<br>\end{bmatrix}<br>$$</p><p>一定不能写成下面的形式，因为 $z_v$ 没有被观测，而不是 $z_v = 0$，用公式 <code>错误的位置和速度观测方程</code> 表示：</p><p><a id= "eq:错误的位置和速度观测方程"></a><br>$$<br>\begin{aligned}<br>z_p &amp;= p_t \<br>z_v &amp;= 0<br>\end{aligned}<br>$$</p><p>错误的矩阵的形式，用公式 <code>错误的位置和速度观测方程的矩阵形式</code> 表示：</p><p><a id= "eq:错误的位置和速度观测方程的矩阵形式"></a><br>$$<br>\begin{bmatrix}<br>z_p \<br>z_v<br>\end{bmatrix}<br>= \begin{bmatrix}<br>1 &amp; 0 \<br>0 &amp; 0<br>\end{bmatrix}<br>\cdot\begin{bmatrix}<br>p_t \<br>v_t<br>\end{bmatrix}<br>$$</p><p>其中引入了速度观测值 $v_t$，但是速度是没有测量的，可以去掉这个测量量。同样的有其他传感器的话可以增加测量量。所以观测方程的维度可以和状态方程的维度不同。写成矩阵形式，用公式 <code>匀加速直线运动2</code> 表示：</p><p><a id= "eq:理想的观测方程"></a><br>$$<br>\underline{z_t} = H \cdot \underline{x_t}<br>$$</p><p>上式加上以下噪音，用公式 <code>观测噪音</code> 表示：</p><p><a id= "eq:观测噪音"></a><br>$$<br>\begin{bmatrix}<br>1 &amp; 0<br>\end{bmatrix}\cdot<br>\begin{bmatrix}<br>\Delta p_t \<br>\Delta v_t<br>\end{bmatrix}<br>$$</p><p>其中，理想值 $\underline{z_t}$ 和实际值 $z_t$ 之间存在位置观测噪音 $\Delta p_t$，速度观测噪音 $\Delta v_t$。可以看到该<a href="#eq:%E4%BD%8D%E7%BD%AE%E5%92%8C%E9%80%9F%E5%BA%A6%E8%A7%82%E6%B5%8B%E6%96%B9%E7%A8%8B%E7%9A%84%E7%9F%A9%E9%98%B5%E5%BD%A2%E5%BC%8F">位置和速度观测方程的矩阵形式</a>加上噪音后，满足<a href="#eq:%E8%A7%82%E6%B5%8B%E6%96%B9%E7%A8%8B">观测方程</a>。</p><h3 id="更新方程">更新方程</h3><h4 id="修正估计">修正估计</h4><p>  先验估计值是理想状态下，没有噪音，是根据物理理论规律推导出来的当前时刻的预测的状态值 $\hat{x}_t^-$。如果我们把观测方程也去除噪音值，当作一个理想的公式，并把这个先验估计值 $\hat{x}_t^-$ 带入去除噪音的观测方程中，那么实际的观测值和理论上理想的观测值之间存在一个差值，这个值就叫 <code>测量残差</code>，也叫 <code>残差</code>，记为 $l_t$，用公式 <code>残差</code> 表示：</p><p><a id= "eq:残差"></a><br>$$<br>l_t = z_t - H \cdot \hat{x}_t^-<br>$$</p><p>  我们永远无法得到状态的真实值 $x_t$，只能尽量得到一个最优的估计值 $\hat{x}_t$，但是这个值无法直接用先验估计值 $\hat{x}_t^-$ 和残差直接表示，因为残差是理想状态计算的观测值和实际的观测值之间的差值，但是这个值并不能直接表示后验估计值 $\hat{x}_t$ 和先验估计值 $\hat{x}_t^-$ 之间的差值，但是可以用一个系数 $K_t$ 使他们相等，用公式 <code>最优估计偏差和残差的关系</code> 表示：</p><p><a id= "eq:最优估计偏差和残差的关系"></a><br>$$<br>\hat{x}_t - \hat{x}_t^- = K_t \cdot (z_t - H \cdot \hat{x}_t^-)<br>$$</p><p>其中 $K_t$ 又称为 <code>卡尔曼滤波系数</code>，上式我们习惯用公式 <code>最优估计值计算公式</code> 写成：</p><p><a id= "eq:最优估计值计算公式"></a><br>$$<br>\hat{x}_t = \hat{x}_t^- + K_t \cdot (z_t-H \cdot \hat{x}_t^-)<br>$$</p><p>这样，最优估计值 $\hat{x}_t$ 等于当前时刻的预测值 $\hat{x}_t^-$，加上权重 $K_t$乘以观测误差 $z_t-H \cdot \hat{x}_t^-$。</p><h4 id="更新卡尔曼增益">更新卡尔曼增益</h4><p>  那么这个权重 $K_t$ 给多少呢？怎么给呢？是随便给吗？有什么依据吗？</p><p>  答：当然是有依据的。依据当然是真实值和最优估计值之间的差值 ${e}_t$ 最小，即后验误差最小，后验误差见公式<a href="#eq:%E5%90%8E%E9%AA%8C%E8%AF%AF%E5%B7%AE">后验误差</a>。将上式最优估计值带入公式<a href="#eq:%E5%90%8E%E9%AA%8C%E8%AF%AF%E5%B7%AE">后验误差</a>中，用公式 <code>后验误差变换1</code> 表示：</p><p><a id= "eq:后验误差变换1"></a><br>$$<br>\begin{aligned}<br>{e}<em>t = x</em>{t} - [\hat{x}_t^- + K_t \cdot (z_t - H \cdot \hat{x}_t^-)]<br>\end{aligned}<br>$$</p><p>继续化简，将<a href="#eq:%E8%A7%82%E6%B5%8B%E6%96%B9%E7%A8%8B">观测方程</a>带入上式中，用公式 <code>后验误差变换2</code> 表示：</p><p><a id= "eq:后验误差变换2"></a><br>$$<br>\begin{aligned}<br>{e}<em>t &amp;= x</em>{t} - [\hat{x}<em>t^- + K_t \cdot (H \cdot x</em>{t} + n_t - H \cdot \hat{x}<em>t^-)] \<br>&amp;= (x</em>{t} - \hat{x}<em>t^-) - K_t \cdot H \cdot (x</em>{t} - \hat{x}_t^-) - K_t \cdot n_t<br>\end{aligned}<br>$$</p><p>继续化简，将公式<a href="#eq:%E5%85%88%E9%AA%8C%E8%AF%AF%E5%B7%AE">先验误差</a> ${e}_{t}^{-}$ 带入上式中，用公式 <code>后验误差变换3</code> 表示：</p><p><a id= "eq:后验误差变换3"></a><br>$$<br>\begin{aligned}<br>{e}<em>t &amp;= (x</em>{t} - \hat{x}<em>t^-) - K_t \cdot H \cdot (x</em>{t} - \hat{x}<em>t^-) - K_t \cdot n_t \<br>&amp;= {e}</em>{t}^{-} - K_t \cdot H \cdot {e}<em>{t}^{-} - K_t \cdot n_t \<br>&amp;= (I - K_t \cdot H) \cdot {e}</em>{t}^{-} - K_t \cdot n_t<br>\end{aligned}<br>$$</p><p>  接下来求后验误差的协方差矩阵，用公式 <code>后验误差的协方差矩阵1</code> 表示：</p><p><a id= "eq:后验误差的协方差矩阵1"></a><br>$$<br>\begin{aligned}<br>Cov({e}<em>{t},{e}</em>{t}) &amp;= Cov({e}<em>{t}) \<br>&amp;= Cov[(I - K_t \cdot H) \cdot {e}</em>{t}^{-} - K_t \cdot n_t] \<br>&amp;= (I - K_t \cdot H) \cdot Cov({e}_{t}^{-}) \cdot (I - K_t \cdot H)^T +  K_t \cdot Cov(n_t) \cdot K_t^T<br>\end{aligned}<br>$$</p><p>记 <code>后验误差的协方差矩阵</code> $Cov({e}<em>{t}) = P</em>{t}$，则上式可以用公式 <code>后验误差的协方差矩阵2</code> 表示：</p><p><a id= "eq:后验误差的协方差矩阵2"></a><br>$$<br>\begin{aligned}<br>P_{t} &amp;= (I - K_t \cdot H)<br>\cdot P_{t}^{-}<br>\cdot (I - K_t \cdot H)^T<br>+  K_t \cdot R \cdot K_t^T \<br>&amp;= (P_{t}^{-} - K_t \cdot H \cdot P_{t}^{-})<br>\cdot (I - H^T \cdot K_t^T)<br>+ K_t \cdot R \cdot K_t^T \<br>&amp;= P_{t}^{-}<br>- K_t \cdot H \cdot P_{t}^{-}<br>- P_{t}^{-} \cdot H^T \cdot K_t^T \<br>&amp;+ K_t \cdot H \cdot P_{t}^{-} \cdot H^T \cdot K_t^T<br>+ K_t \cdot R \cdot K_t^T \<br>&amp;= P_{t}^{-}<br>- K_t \cdot H \cdot P_{t}^{-}<br>- (K_t \cdot H \cdot P_{t}^{-})^T<br>+ K_t \cdot (H \cdot P_{t}^{-} \cdot H^T + R) \cdot K_t^T<br>\end{aligned}<br>$$</p><p>其中之所以能化简，是由于误差的协方差矩阵 $P_{t}$ 和 $P_{t}^-$ 均是自相关矩阵，即以对角线为分界线，矩阵是对称的，这是协方差矩阵的性质，具体可以参考：<a href="./20231204a.html">协方差</a>。我们想要后验误差的协方差矩阵 $P_{t}$ 最小，只要让该矩阵对角线上的和最小就行了，即矩阵 $P_{t}$ 的迹最小（参考：<a href="20231210a.html">矩阵的迹</a>）。为什么呢？因为对角线上是每个误差本身的协方差，也就是方差，他们的和最小，协方差矩阵 $P_{t}$ 就最小；矩阵的其他位置是两两误差的相关性，与整体误差无关，对整体误差大小没有影响。因此，用公式 <code>后验误差的协方差矩阵的迹</code> 表示：</p><p><a id= "eq:后验误差的协方差矩阵的迹"></a><br>$$<br>\begin{aligned}<br>T(P_{t}) &amp;= T(P_{t}^{-})<br>- 2 \cdot T(K_t \cdot H \cdot P_{t}^{-})<br>+ T[K_t \cdot (H \cdot P_{t}^{-} \cdot H^T + R) \cdot K_t^T] \<br>&amp;= T[K_t \cdot (H \cdot P_{t}^{-} \cdot H^T + R) \cdot K_t^T]<br>- 2 \cdot T(K_t \cdot H \cdot P_{t}^{-})<br>+ T(P_{t}^{-}) \<br>\end{aligned}<br>$$</p><p>其中 $T()$ 代表矩阵的迹。把上式看作是关于 $K_t$ 的函数，用公式 <code>关于卡尔曼滤波系数的函数</code> 表示：</p><p><a id= "eq:关于卡尔曼滤波系数的函数"></a><br>$$<br>\begin{aligned}<br>f(x) &amp;= a \cdot x^2 - b \cdot x + c,<br>\quad(a,b\text{是正的常数}) \<br>f’(x) &amp;= 2 \cdot a \cdot x - b<br>\end{aligned}<br>$$</p><p>显然，这个函数是一个开口向上的一元二次函数，有极小值。它是一个凸函数，导数为0的点就是最小值。公式<a href="#eq:%E5%90%8E%E9%AA%8C%E8%AF%AF%E5%B7%AE%E7%9A%84%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B5%E7%9A%84%E8%BF%B9">后验误差的协方差矩阵的迹</a>求导，用公式 <code>后验误差的协方差矩阵的迹的转置</code> 表示：</p><p><a id= "eq:后验误差的协方差矩阵的迹的转置"></a><br>$$<br>\begin{aligned}<br>{\frac {dT(P_{t})} {dK_{t}}}<br>&amp;= K_{t} \cdot (H \cdot P_{t}^{-} \cdot H^{T} + R)<br>+ K_{t} \cdot (H \cdot P_{t}^{-} \cdot H^{T} + R)<br>-2 \cdot (H \cdot P_{t}^{-})^{T} \<br>&amp;= 2 \cdot K_{t} \cdot (H \cdot P_{t}^{-} \cdot H^{T} + R)<br>-2 \cdot (H \cdot P_{t}^{-})^{T}<br>\end{aligned}<br>$$</p><p>这里是对矩阵的迹的求导，求导公式从函数求导理解，想完全弄清楚，那么具体矩阵迹的求导需要单独学习，这里不做深入探讨。使得上式为零，则可计算出卡尔曼滤波系数 $K_{t}$，用公式 <code>卡尔曼滤波系数</code> 表示：</p><p><a id= "eq:卡尔曼滤波系数"></a><br>$$<br>K_t = \frac {P_t^- \cdot H^T} {H \cdot P_t^- \cdot H^T + R}<br>$$</p><h4 id="更新后验误差的协方差">更新后验误差的协方差</h4><p>  将计算得到的卡尔曼滤波系数 $K_t$ 带入公式<a href="#eq:%E5%90%8E%E9%AA%8C%E8%AF%AF%E5%B7%AE%E7%9A%84%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B52">后验误差的协方差矩阵2</a>，计算得到后验误差协方差矩阵，用公式 <code>后验误差的协方差矩阵3</code> 表示：</p><p><a id= "eq:后验误差的协方差矩阵3"></a><br>$$<br>\begin{aligned}<br>P_{t} &amp;= P_{t}^{-} - K_t \cdot H \cdot P_{t}^{-} \<br>&amp;= (I - K_t \cdot H) \cdot P_{t}^{-} \<br>\end{aligned}<br>$$</p><h2 id="总结">总结</h2><p>  至此，卡尔曼滤波的五个重要的公式已经全部推导完成。分别是：<a href="#eq:%E5%85%88%E9%AA%8C%E4%BC%B0%E8%AE%A1">先验估计</a>、<a href="#eq:%E5%85%88%E9%AA%8C%E8%AF%AF%E5%B7%AE%E7%9A%84%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B52">先验误差的协方差矩阵2</a>、<a href="#eq:%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%B3%BB%E6%95%B0">卡尔曼滤波系数</a>、<a href="#eq:%E6%9C%80%E4%BC%98%E4%BC%B0%E8%AE%A1%E5%80%BC%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F">最优估计值计算公式</a>、<a href="#eq:%E5%90%8E%E9%AA%8C%E8%AF%AF%E5%B7%AE%E7%9A%84%E5%8D%8F%E6%96%B9%E5%B7%AE%E7%9F%A9%E9%98%B53">后验误差的协方差矩阵3</a>。综上，我们把这五个重要的公式写在一起：</p><p>预测公式，用公式 <code>预测</code> 表示：</p><p><a id= "eq:预测"></a><br>$$<br>\begin{aligned}<br>\hat{x}<em>{t}^{-} &amp;= F \cdot \hat{x}</em>{t-1} + B \cdot u_{t-1} \<br>P_{t}^{-} &amp;= F \cdot P_{t-1} \cdot F^{T} + Q<br>\end{aligned}<br>$$</p><p>更新公式，用公式 <code>更新</code> 表示：</p><p><a id= "eq:更新"></a><br>$$<br>\begin{aligned}<br>K_t &amp;= \frac {P_t^- \cdot H^T} {H \cdot P_t^- \cdot H^T + R} \<br>\hat{x}_t &amp;= \hat{x}<em>t^- + K_t \cdot (z_t - H \cdot \hat{x}<em>t^-) \<br>P</em>{t} &amp;= (I - K_t \cdot H) \cdot P</em>{t}^{-}<br>\end{aligned}<br>$$</p><h3 id="matlab仿真">matlab仿真</h3><p>  所有的代码算法，严格按照公式推导进行设计。所有的代码变量全部取自于latex公式符号。这样接口就做好了，这样逻辑思维的一致性，严谨性，可读性，方便性，记忆性，代码的移植性都得到了极大地提升。有两点需要额外设计：一是初始值，这是在公式推导中没有提及的。二是遇到了数值分析问题，需要对公式进行移向等基本变化进行改造；但也是要详细列写公式的，并严格依据公式写代码；数值问题是在跑代码时发现的，发现数值问题，再回头改公式。matlab仿真公式如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 清理</span></span><br><span class="line">close all; clear; clc;</span><br><span class="line"><span class="comment">% 估计小车在每一时刻的位置和速度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 无噪音的理想值</span></span><br><span class="line">T = (<span class="number">1</span> : <span class="number">100</span>); <span class="comment">% 离散的时间序列，单位是s</span></span><br><span class="line">p = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(T)); v = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(T)); </span><br><span class="line">p(<span class="number">1</span>) = <span class="number">0</span> <span class="comment">% 小车的初始位置</span></span><br><span class="line">v(<span class="number">1</span>) = <span class="number">3</span> <span class="comment">% 小车的初始速度</span></span><br><span class="line">a = <span class="number">0.1</span>; <span class="comment">% 加速度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t = <span class="number">2</span> : <span class="built_in">length</span>(T)</span><br><span class="line">    p(t) = p(t - <span class="number">1</span>) + v(t - <span class="number">1</span>) + <span class="number">1</span>/<span class="number">2</span> * a; <span class="comment">% 理想的位置</span></span><br><span class="line">    v(t) = v(t - <span class="number">1</span>) + a; <span class="comment">% 理想的速度值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">underline_x = [p; v];</span><br><span class="line"> </span><br><span class="line"><span class="comment">%% 有噪音的实际值，模拟噪音</span></span><br><span class="line"><span class="comment">% 状态噪音</span></span><br><span class="line">sigma_r = <span class="number">0.01</span></span><br><span class="line">r_p = sigma_r * <span class="built_in">randn</span>(<span class="number">1</span>, <span class="built_in">length</span>(T));</span><br><span class="line">r_v = sigma_r * <span class="built_in">randn</span>(<span class="number">1</span>, <span class="built_in">length</span>(T));</span><br><span class="line">x = underline_x;</span><br><span class="line"><span class="keyword">for</span> t = <span class="number">2</span> : <span class="built_in">length</span>(T)</span><br><span class="line">    x(<span class="number">1</span>, t) = x(<span class="number">1</span>, t - <span class="number">1</span>) + x(<span class="number">2</span>, t - <span class="number">1</span>) + <span class="number">1</span>/<span class="number">2</span> * a + r_p(t); <span class="comment">% 真实的位置</span></span><br><span class="line">    x(<span class="number">2</span>, t) = x(<span class="number">2</span>, t - <span class="number">1</span>) + a + r_v(t); <span class="comment">% 真实的速度值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 观测噪音</span></span><br><span class="line">sigma_Delta_p = <span class="number">3</span></span><br><span class="line">Delta_p = sigma_Delta_p * <span class="built_in">randn</span>(<span class="number">1</span>, <span class="built_in">length</span>(T)); <span class="comment">% GPS测量误差，标准差为3m</span></span><br><span class="line">z = x(<span class="number">1</span>, :) + Delta_p; <span class="comment">% GPS的观测值，带有测量误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 卡尔曼滤波</span></span><br><span class="line"><span class="comment">% 已知量</span></span><br><span class="line"><span class="comment">% 已知的线性变换矩阵</span></span><br><span class="line">F = [<span class="number">1</span>, <span class="number">1</span>; <span class="number">0</span>, <span class="number">1</span>]; <span class="comment">% 状态转移矩阵</span></span><br><span class="line">B = [<span class="number">1</span>/<span class="number">2</span>; <span class="number">1</span>]; <span class="comment">% 控制矩阵</span></span><br><span class="line">u = a;</span><br><span class="line">H = [<span class="number">1</span>, <span class="number">0</span>];</span><br><span class="line">sigma_Q = <span class="number">0.01</span></span><br><span class="line">Q = [sigma_Q^<span class="number">2</span>, <span class="number">0</span>; <span class="number">0</span>, sigma_Q^<span class="number">2</span>]; <span class="comment">% 过程噪声的协方差矩阵，这是一个超参数</span></span><br><span class="line">sigma_R = <span class="number">3</span></span><br><span class="line">R = sigma_R^<span class="number">2</span>; <span class="comment">% 观测噪声的协方差矩阵，也是一个超参数。因为是一维的，就是一个数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化</span></span><br><span class="line">hat_x_ = <span class="built_in">zeros</span>(<span class="number">2</span>, <span class="built_in">length</span>(T)); hat_x = <span class="built_in">zeros</span>(<span class="number">2</span>, <span class="built_in">length</span>(T));</span><br><span class="line">hat_x(:, <span class="number">1</span>) = [<span class="number">0</span>; <span class="number">0</span>]; <span class="comment">% 初始状态，[位置, 速度]，就是我们要估计的内容，开始时都未知，设为0</span></span><br><span class="line">P = [<span class="number">0.1</span>, <span class="number">0</span>; <span class="number">0</span>, <span class="number">0.1</span>]; <span class="comment">% 先验误差协方差矩阵的初始值，根据经验给出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 卡尔曼滤波5个关键公式</span></span><br><span class="line"><span class="keyword">for</span> t = <span class="number">2</span>:<span class="built_in">length</span>(T)</span><br><span class="line">    hat_x_(:, t) = F * hat_x(:, t - <span class="number">1</span>) + B * u;</span><br><span class="line">    P_ = F * P * F&#x27; + Q;</span><br><span class="line">    K = (P_ * H&#x27;) / (H * P_ * H&#x27; + R);</span><br><span class="line">    hat_x(:, t) = hat_x_(:, t) + K * (z(:, t) - H * hat_x_(:, t));</span><br><span class="line">    P = (<span class="built_in">eye</span>(<span class="number">2</span>) - K * H) * P_;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 绘图</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(T, underline_x(<span class="number">1</span>, :), <span class="string">&#x27;b&#x27;</span>); <span class="comment">% 位置的理想值</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(T, x(<span class="number">1</span>, :), <span class="string">&#x27;g&#x27;</span>); <span class="comment">% 位置的实际值</span></span><br><span class="line"><span class="built_in">plot</span>(T, z(<span class="number">1</span>, :), <span class="string">&#x27;m&#x27;</span>); <span class="comment">% 位置的观测值</span></span><br><span class="line"><span class="built_in">plot</span>(T, hat_x(<span class="number">1</span>, :), <span class="string">&#x27;r.&#x27;</span>); <span class="comment">% 位置的最优估计值</span></span><br><span class="line">title(<span class="string">&#x27;对位置的估计&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>); ylabel(<span class="string">&#x27;位置&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(T, underline_x(<span class="number">2</span>, :)); <span class="comment">% 速度的理想值</span></span><br><span class="line"><span class="built_in">hold</span> on;</span><br><span class="line"><span class="built_in">plot</span>(T, x(<span class="number">2</span>, :), <span class="string">&#x27;g&#x27;</span>); <span class="comment">% 速度的实际值</span></span><br><span class="line"><span class="built_in">plot</span>(T, hat_x(<span class="number">2</span>, :), <span class="string">&#x27;r.&#x27;</span>); <span class="comment">% 速度的最优估计值</span></span><br><span class="line">title(<span class="string">&#x27;对速度的估计&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>); ylabel(<span class="string">&#x27;速度&#x27;</span>);</span><br></pre></td></tr></table></figure><p>其中，用matlab做实时脚本时，这些地方可以做数字滑块：1. 初始位置 <code>p(1)</code> 和速度 <code>v(1)</code>，2. 过程噪声的标准差 <code>sigma_r</code> 和观测噪声的标准差 <code>sigma_Delta_p</code>，3. 超参数 $Q$ 和 $R$ 的标准差 <code>sigma_Q</code> 和 <code>sigma_R</code>。</p><p>  不管初始位置和速度时多少，卡尔曼滤波很快就能收敛，跟上脚步，和实际值接近。过程噪声的标准差不能很大，很大说明状态方程的物理模型建立的不合理，且在没有观测速度的条件下，卡尔曼滤波效果特别是对速度的估计值就很差；除非观测噪声很小，观测精度很高，卡尔曼滤波在状态方程的物理模型建立的不合理的条件下，依赖观测值也能得到较好的结果。超参数 $Q$ 和 $R$ 可能需要不断地调试，以达到最佳的曲线效果；可以发现把超参数的标准差和模拟噪音的标准差设置一样时效果最好；实际中由于对过程噪声的未知，需要通过不断调试更改超参数，以使得曲线最佳，此时的超参数基本上就和系统的噪音相差无几。</p><h4 id="时间复杂度">时间复杂度</h4><p>  需要考虑matlab仿真的时间复杂度。就是考虑算力问题。时间复杂度想得到的答案是随着数据规模的增加，程序的运行次数是线性增加还是指数增加的。从这里我们不难看出，数据规模有三个量，一个是状态量的维度 $m$，一个是观测量的维度 $n$，一个是数组的长度 $t$。显然循环停止的条件是数组跑完，所以时间复杂度肯定包含 $\cdot t$ 项。接下来就只用考虑单步预测的时间复杂度：显然不管计算了多少次，复杂度只和维度有关，所以，用公式 <code>时间复杂度</code> 表示：</p><p><a id= "eq:时间复杂度"></a><br>$$<br>\begin{aligned}<br>T &amp;= O(m + n \cdot t) \<br>T &amp;= O(n^2)<br>\end{aligned}<br>$$</p><p>这是对的吗？应该是对的吧？</p><h3 id="GNSS定位领域">GNSS定位领域</h3><h3 id="变换">变换</h3><p>  以上推导的公式形式常用于自动控制领域。在卫星导航领域，状态空间表达式如下，用公式 <code>状态空间表达式</code> 表示：</p><p><a id= "eq:状态空间表达式"></a><br>$$<br>\left{<br>\begin{aligned}<br>X_k &amp;= \Phi_k \cdot X_{k-1} + \psi_{k,k-1} \cdot U_{k-1} + \Gamma_{k,k-1} \cdot \Omega_{k-1} \<br>L_k &amp;= B_k \cdot X_k + G_k \cdot U_k + \Delta_k<br>\end{aligned}<br>\right.<br>$$</p><p>上式和<a href="#eq:%E7%8A%B6%E6%80%81%E6%96%B9%E7%A8%8B">状态方程</a>以及<a href="#eq:%E8%A7%82%E6%B5%8B%E6%96%B9%E7%A8%8B">观测方程</a>还有三个区别：</p><p>一个是下角标 $<em>{k,k-1}$ 出现在一些系数矩阵上，这是为什么呢？是因为系数矩阵所乘以的矩阵变量是上一时刻的，从上一时刻到这一个时刻的矩阵变换关系表示为 ${k,k-1}$。第二个变化是观测方程的单噪音项变成了两项相乘，其中 ${\Omega}</em>{k-1}$ 为上一时刻的动态噪声，${\Gamma}_{k,k-1}$ 为噪音变化矩阵。第三个变化是在观测方程中，该时刻的控制项 $G_k \cdot U_k$，该控制项将影响观测值，在部分传感器中会出现这种观测方程，这种传感器我目前还没见过。</p><p>  同理，可以得到卡尔曼滤波公式：</p><p>时间更新，用公式 <code>时间更新</code> 表示：</p><p><a id= "eq:时间更新"></a><br>$$<br>\left{<br>\begin{aligned}<br>\widehat{X}<em>{k,k-1} &amp;= \Phi</em>{k,k-1} \cdot \widehat{X}<em>{k-1,k-1} + \psi</em>{k,k-1} \cdot U_{k-1} \<br>D_{X_{k,k-1}} &amp;= \Phi_{k,k-1} \cdot D_{X_{k-1,k-1}} \cdot \Phi_{k,k-1}^{T}<br>+ \Gamma_{k,k-1} \cdot D_{\Omega_{k-1}} \cdot \Gamma_{k,k-1}^{T}<br>\end{aligned}<br>\right.<br>$$</p><p>上式与公式<a href="#eq:%E9%A2%84%E6%B5%8B">预测</a>除了符号以外完全相同，但是确实不够优雅，可读性也不如<a href="#eq:%E9%A2%84%E6%B5%8B">预测</a>，比如先验误差符号有点怪怪的。之前叫预测，但是这里叫一步预测公式的时间更新，因为从公式上来说，是从上一个时刻推导到这时刻。但是预测的叫法和时间更新的叫法值得是一个东西。</p><p>测量更新，用公式 <code>测量更新1</code> 表示：</p><p><a id= "eq:测量更新1"></a><br>$$<br>\begin{aligned}<br>\widehat{X}<em>{k,k} &amp;= \widehat{X}</em>{k,k-1} + J_k \cdot l_k \<br>D_{X_{k,k}} &amp;= (I - J_k \cdot B_k) \cdot D_{X_{k,k-1}}<br>\end{aligned}<br>$$</p><p>其中，用公式 <code>测量更新2</code> 表示：</p><p><a id= "eq:测量更新2"></a><br>$$<br>\begin{aligned}<br>J_k &amp;= D_{X_{k,k-1}} \cdot B_k^T\big(B_k \cdot D_{X_{k,k-1}} \cdot B_k^T + D_{\Delta_k}\big)^{-1} \<br>l_k &amp;= L_k - Z_k - B_k \cdot \widehat{X}_{k,k-1}<br>\end{aligned}<br>$$</p><p>其中，用公式 <code>非随机控制向量</code> 表示：</p><p><a id= "eq:非随机控制向量"></a><br>$$<br>Z_{k} = G_{k} \cdot U_{k}<br>$$</p><p>上式和<a href="#eq:%E6%9B%B4%E6%96%B0">更新</a>方程除了符号以及状态方程那儿说的不同之处以外没有任何不同。这里 $J_k$ 除了之前叫卡尔曼滤波系数，这里还叫滤波增益矩阵。$l_k$ 除了叫验前残差以外还叫<code>新息矩阵</code>、<code>OMC向量</code>。</p><h3 id="简化">简化</h3><p>  在GNSS定位数据处理中，通常不涉及控制向量。非随机控制项为零时，即方程和观测方程中 $U_k = 0$，也即卡尔曼滤波公式中 $U_k = 0$ 和 $Z_k = 0$，去掉包含这两项的内容即可。</p>]]></content>
    
    
    <summary type="html">🥧本文推导卡尔曼滤波，并给出matlab仿真代码</summary>
    
    
    
    <category term="数学" scheme="https://www.adunas.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="https://www.adunas.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="卡尔曼滤波" scheme="https://www.adunas.top/tags/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2/"/>
    
    <category term="matlab" scheme="https://www.adunas.top/tags/matlab/"/>
    
  </entry>
  
  <entry>
    <title>博客搭建教程（二）：bug汇总</title>
    <link href="https://www.adunas.top/posts/20231204c.html"/>
    <id>https://www.adunas.top/posts/20231204c.html</id>
    <published>2023-12-04T12:31:21.000Z</published>
    <updated>2023-12-05T15:33:18.000Z</updated>
    
    
    <summary type="html">🥝本文汇总网页端的已知问题，并尝试解决</summary>
    
    
    
    <category term="博客教程" scheme="https://www.adunas.top/categories/%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
    
    <category term="bug" scheme="https://www.adunas.top/tags/bug/"/>
    
    <category term="hexo" scheme="https://www.adunas.top/tags/hexo/"/>
    
    <category term="pandoc" scheme="https://www.adunas.top/tags/pandoc/"/>
    
  </entry>
  
  <entry>
    <title>协方差</title>
    <link href="https://www.adunas.top/posts/20231204a.html"/>
    <id>https://www.adunas.top/posts/20231204a.html</id>
    <published>2023-12-03T17:35:21.000Z</published>
    <updated>2023-12-03T17:35:21.000Z</updated>
    
    
    <summary type="html">🥧本文讲解协方差，并给出matlab仿真代码</summary>
    
    
    
    <category term="数学" scheme="https://www.adunas.top/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数学" scheme="https://www.adunas.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="matlab" scheme="https://www.adunas.top/tags/matlab/"/>
    
    <category term="协方差" scheme="https://www.adunas.top/tags/%E5%8D%8F%E6%96%B9%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>Adunas的游戏账号昵称和ID</title>
    <link href="https://www.adunas.top/posts/20231201b.html"/>
    <id>https://www.adunas.top/posts/20231201b.html</id>
    <published>2023-11-30T18:33:32.000Z</published>
    <updated>2023-12-02T21:22:19.000Z</updated>
    
    
    <summary type="html">🥧本文记录我的游戏账号昵称和ID，欢迎找我玩儿~</summary>
    
    
    
    <category term="游戏" scheme="https://www.adunas.top/categories/%E6%B8%B8%E6%88%8F/"/>
    
    
    <category term="游戏" scheme="https://www.adunas.top/tags/%E6%B8%B8%E6%88%8F/"/>
    
    <category term="游戏ID" scheme="https://www.adunas.top/tags/%E6%B8%B8%E6%88%8FID/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法（一）：基础语法</title>
    <link href="https://www.adunas.top/posts/20231201a.html"/>
    <id>https://www.adunas.top/posts/20231201a.html</id>
    <published>2023-11-30T17:28:03.000Z</published>
    <updated>2023-12-04T20:58:13.000Z</updated>
    
    
    <summary type="html">🥧本文汇总Markdown基础语法，可作为文档进行查询</summary>
    
    
    
    <category term="演示" scheme="https://www.adunas.top/categories/%E6%BC%94%E7%A4%BA/"/>
    
    
    <category term="Markdown" scheme="https://www.adunas.top/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法（三）：Butterfly外挂标签</title>
    <link href="https://www.adunas.top/posts/20231205b.html"/>
    <id>https://www.adunas.top/posts/20231205b.html</id>
    <published>2023-11-30T17:28:03.000Z</published>
    <updated>2023-12-04T20:58:13.000Z</updated>
    
    
    <summary type="html">🥧本文汇总Markdown外挂标签在网页端的渲染效果，可作为文档进行查询</summary>
    
    
    
    <category term="演示" scheme="https://www.adunas.top/categories/%E6%BC%94%E7%A4%BA/"/>
    
    
    <category term="Markdown" scheme="https://www.adunas.top/tags/Markdown/"/>
    
    <category term="外挂标签" scheme="https://www.adunas.top/tags/%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法（二）：Html外挂标签</title>
    <link href="https://www.adunas.top/posts/20231206b.html"/>
    <id>https://www.adunas.top/posts/20231206b.html</id>
    <published>2023-11-30T17:28:03.000Z</published>
    <updated>2023-12-10T20:22:40.000Z</updated>
    
    
    <summary type="html">🥧本文汇总Markdown基础语法，可作为文档进行查询</summary>
    
    
    
    <category term="演示" scheme="https://www.adunas.top/categories/%E6%BC%94%E7%A4%BA/"/>
    
    
    <category term="Markdown" scheme="https://www.adunas.top/tags/Markdown/"/>
    
  </entry>
  
</feed>
